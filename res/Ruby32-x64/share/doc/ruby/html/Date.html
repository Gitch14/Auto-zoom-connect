<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Date - Documentation for Ruby 3.2</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>



  <ul class="link-list" role="directory">
              <li>      <a href="#class-Date-label-Creating+a+Date">Creating a Date</a>
          <li>      <a href="#class-Date-label-Argument+limit">Argument <code>limit</code></a>

  </ul>
</div>


  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="Object.html">Object</a>
</div>

    
<div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
    <li><a class="include" href="Comparable.html">Comparable</a>
  </ul>
</div>

    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-_httpdate">::_httpdate</a>
    <li ><a href="#method-c-_iso8601">::_iso8601</a>
    <li ><a href="#method-c-_jisx0301">::_jisx0301</a>
    <li ><a href="#method-c-_parse">::_parse</a>
    <li ><a href="#method-c-_rfc2822">::_rfc2822</a>
    <li ><a href="#method-c-_rfc3339">::_rfc3339</a>
    <li ><a href="#method-c-_rfc822">::_rfc822</a>
    <li ><a href="#method-c-_strptime">::_strptime</a>
    <li ><a href="#method-c-_xmlschema">::_xmlschema</a>
    <li ><a href="#method-c-civil">::civil</a>
    <li ><a href="#method-c-commercial">::commercial</a>
    <li ><a href="#method-c-gregorian_leap-3F">::gregorian_leap?</a>
    <li ><a href="#method-c-httpdate">::httpdate</a>
    <li ><a href="#method-c-iso8601">::iso8601</a>
    <li ><a href="#method-c-jd">::jd</a>
    <li ><a href="#method-c-jisx0301">::jisx0301</a>
    <li ><a href="#method-c-json_create">::json_create</a>
    <li ><a href="#method-c-julian_leap-3F">::julian_leap?</a>
    <li ><a href="#method-c-leap-3F">::leap?</a>
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-c-ordinal">::ordinal</a>
    <li ><a href="#method-c-parse">::parse</a>
    <li ><a href="#method-c-rfc2822">::rfc2822</a>
    <li ><a href="#method-c-rfc3339">::rfc3339</a>
    <li ><a href="#method-c-rfc822">::rfc822</a>
    <li ><a href="#method-c-strptime">::strptime</a>
    <li ><a href="#method-c-today">::today</a>
    <li ><a href="#method-c-valid_civil-3F">::valid_civil?</a>
    <li ><a href="#method-c-valid_commercial-3F">::valid_commercial?</a>
    <li ><a href="#method-c-valid_date-3F">::valid_date?</a>
    <li ><a href="#method-c-valid_jd-3F">::valid_jd?</a>
    <li ><a href="#method-c-valid_ordinal-3F">::valid_ordinal?</a>
    <li ><a href="#method-c-xmlschema">::xmlschema</a>
    <li ><a href="#method-i-2B">#+</a>
    <li ><a href="#method-i-2D">#-</a>
    <li ><a href="#method-i-3C-3C">#&lt;&lt;</a>
    <li ><a href="#method-i-3C-3D-3E">#&lt;=&gt;</a>
    <li ><a href="#method-i-3D-3D-3D">#===</a>
    <li ><a href="#method-i-3E-3E">#&gt;&gt;</a>
    <li ><a href="#method-i-ajd">#ajd</a>
    <li ><a href="#method-i-amjd">#amjd</a>
    <li ><a href="#method-i-as_json">#as_json</a>
    <li ><a href="#method-i-asctime">#asctime</a>
    <li ><a href="#method-i-ctime">#ctime</a>
    <li ><a href="#method-i-cwday">#cwday</a>
    <li ><a href="#method-i-cweek">#cweek</a>
    <li ><a href="#method-i-cwyear">#cwyear</a>
    <li ><a href="#method-i-day">#day</a>
    <li ><a href="#method-i-day_fraction">#day_fraction</a>
    <li ><a href="#method-i-deconstruct_keys">#deconstruct_keys</a>
    <li ><a href="#method-i-downto">#downto</a>
    <li ><a href="#method-i-england">#england</a>
    <li ><a href="#method-i-friday-3F">#friday?</a>
    <li ><a href="#method-i-gregorian">#gregorian</a>
    <li ><a href="#method-i-gregorian-3F">#gregorian?</a>
    <li ><a href="#method-i-httpdate">#httpdate</a>
    <li ><a href="#method-i-infinite-3F">#infinite?</a>
    <li ><a href="#method-i-inspect">#inspect</a>
    <li ><a href="#method-i-iso8601">#iso8601</a>
    <li ><a href="#method-i-italy">#italy</a>
    <li ><a href="#method-i-jd">#jd</a>
    <li ><a href="#method-i-jisx0301">#jisx0301</a>
    <li ><a href="#method-i-julian">#julian</a>
    <li ><a href="#method-i-julian-3F">#julian?</a>
    <li ><a href="#method-i-ld">#ld</a>
    <li ><a href="#method-i-leap-3F">#leap?</a>
    <li ><a href="#method-i-mday">#mday</a>
    <li ><a href="#method-i-mjd">#mjd</a>
    <li ><a href="#method-i-mon">#mon</a>
    <li ><a href="#method-i-monday-3F">#monday?</a>
    <li ><a href="#method-i-month">#month</a>
    <li ><a href="#method-i-new_start">#new_start</a>
    <li ><a href="#method-i-next">#next</a>
    <li ><a href="#method-i-next_day">#next_day</a>
    <li ><a href="#method-i-next_month">#next_month</a>
    <li ><a href="#method-i-next_year">#next_year</a>
    <li ><a href="#method-i-prev_day">#prev_day</a>
    <li ><a href="#method-i-prev_month">#prev_month</a>
    <li ><a href="#method-i-prev_year">#prev_year</a>
    <li ><a href="#method-i-rfc2822">#rfc2822</a>
    <li ><a href="#method-i-rfc3339">#rfc3339</a>
    <li ><a href="#method-i-rfc822">#rfc822</a>
    <li ><a href="#method-i-saturday-3F">#saturday?</a>
    <li ><a href="#method-i-start">#start</a>
    <li ><a href="#method-i-step">#step</a>
    <li ><a href="#method-i-strftime">#strftime</a>
    <li ><a href="#method-i-succ">#succ</a>
    <li ><a href="#method-i-sunday-3F">#sunday?</a>
    <li ><a href="#method-i-thursday-3F">#thursday?</a>
    <li ><a href="#method-i-to_date">#to_date</a>
    <li ><a href="#method-i-to_datetime">#to_datetime</a>
    <li ><a href="#method-i-to_json">#to_json</a>
    <li ><a href="#method-i-to_s">#to_s</a>
    <li ><a href="#method-i-to_time">#to_time</a>
    <li ><a href="#method-i-tuesday-3F">#tuesday?</a>
    <li ><a href="#method-i-upto">#upto</a>
    <li ><a href="#method-i-wday">#wday</a>
    <li ><a href="#method-i-wednesday-3F">#wednesday?</a>
    <li ><a href="#method-i-xmlschema">#xmlschema</a>
    <li ><a href="#method-i-yday">#yday</a>
    <li ><a href="#method-i-year">#year</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Date">
  <h1 id="class-Date" class="class">
    class Date
  </h1>

  <section class="description">
    
<p>Class Date provides methods for storing and manipulating calendar dates.</p>

<p>Consider using <a href="Time.html">class Time</a> instead of class Date if:</p>
<ul><li>
<p>You need both dates and times; Date handles only dates.</p>
</li><li>
<p>You need only Gregorian dates (and not Julian dates); see Julian and Gregorian Calendars.</p>
</li></ul>

<p>A Date object, once created, is immutable, and cannot be modified.</p>

<h2 id="class-Date-label-Creating+a+Date">Creating a Date<span><a href="#class-Date-label-Creating+a+Date">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>You can create a date for the current date, using <a href="Date.html#method-c-today"><code>Date.today</code></a>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span> <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
</pre>

<p>You can create a specific date from various combinations of arguments:</p>
<ul><li>
<p><a href="Date.html#method-c-new"><code>Date.new</code></a> takes integer year, month, and day-of-month:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1999</span>, <span class="ruby-value">12</span>, <span class="ruby-value">31</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
</pre>
</li><li>
<p><a href="Date.html#method-c-ordinal"><code>Date.ordinal</code></a> takes integer year and day-of-year:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">1999</span>, <span class="ruby-value">365</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
</pre>
</li><li>
<p><a href="Date.html#method-c-jd"><code>Date.jd</code></a> takes integer Julian day:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-value">2451544</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
</pre>
</li><li>
<p><a href="Date.html#method-c-commercial"><code>Date.commercial</code></a> takes integer commercial data (year, week, day-of-week):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">1999</span>, <span class="ruby-value">52</span>, <span class="ruby-value">5</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
</pre>
</li><li>
<p><a href="Date.html#method-c-parse"><code>Date.parse</code></a> takes a string, which it parses heuristically:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;1999-12-31&#39;</span>)    <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;31-12-1999&#39;</span>)    <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;1999-365&#39;</span>)      <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;1999-W52-5&#39;</span>)    <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
</pre>
</li><li>
<p><a href="Date.html#method-c-strptime"><code>Date.strptime</code></a> takes a date string and a format string, then parses the date string according to the format string:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;1999-12-31&#39;</span>, <span class="ruby-string">&#39;%Y-%m-%d&#39;</span>)  <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;31-12-1999&#39;</span>, <span class="ruby-string">&#39;%d-%m-%Y&#39;</span>)  <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;1999-365&#39;</span>, <span class="ruby-string">&#39;%Y-%j&#39;</span>)       <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;1999-W52-5&#39;</span>, <span class="ruby-string">&#39;%G-W%V-%u&#39;</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;1999 52 5&#39;</span>, <span class="ruby-string">&#39;%Y %U %w&#39;</span>)   <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;1999 52 5&#39;</span>, <span class="ruby-string">&#39;%Y %W %u&#39;</span>)   <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;fri31dec99&#39;</span>, <span class="ruby-string">&#39;%a%d%b%y&#39;</span>)  <span class="ruby-comment"># =&gt; #&lt;Date: 1999-12-31&gt;</span>
</pre>
</li></ul>

<p>See also the specialized methods in <a href="strftime_formatting_rdoc.html#label-Specialized+Format+Strings">“Specialized Format Strings” in Formats for Dates and Times</a></p>

<h2 id="class-Date-label-Argument+limit">Argument <code>limit</code><span><a href="#class-Date-label-Argument+limit">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Certain singleton methods in Date that parse string arguments also take optional keyword argument <code>limit</code>, which can limit the length of the string argument.</p>

<p>When <code>limit</code> is:</p>
<ul><li>
<p>Non-negative: raises <a href="ArgumentError.html"><code>ArgumentError</code></a> if the string length is greater than <em>limit</em>.</p>
</li><li>
<p>Other numeric or <code>nil</code>: ignores <code>limit</code>.</p>
</li><li>
<p>Other non-numeric: raises <a href="TypeError.html"><code>TypeError</code></a>.</p>
</li></ul>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">


    <section class="constants-list">
      <header>
        <h3>Constants</h3>
      </header>
      <dl>
        <dt id="ABBR_DAYNAMES">ABBR_DAYNAMES
        <dd><p>An array of strings of abbreviated day names in <a href="English.html"><code>English</code></a>.  The first is “Sun”.</p>
        <dt id="ABBR_MONTHNAMES">ABBR_MONTHNAMES
        <dd><p>An array of strings of abbreviated month names in <a href="English.html"><code>English</code></a>.  The first element is nil.</p>
        <dt id="DAYNAMES">DAYNAMES
        <dd><p>An array of strings of the full names of days of the week in <a href="English.html"><code>English</code></a>. The first is “Sunday”.</p>
        <dt id="ENGLAND">ENGLAND
        <dd><p>The Julian day number of the day of calendar reform for England and her colonies.</p>
        <dt id="GREGORIAN">GREGORIAN
        <dd><p>The Julian day number of the day of calendar reform for the proleptic Gregorian calendar.</p>
        <dt id="ITALY">ITALY
        <dd><p>The Julian day number of the day of calendar reform for Italy and some catholic countries.</p>
        <dt id="JULIAN">JULIAN
        <dd><p>The Julian day number of the day of calendar reform for the proleptic Julian calendar.</p>
        <dt id="MONTHNAMES">MONTHNAMES
        <dd><p>An array of strings of full month names in <a href="English.html"><code>English</code></a>.  The first element is nil.</p>
      </dl>
    </section>



     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-_httpdate" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _httpdate(string, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-HTTP+Format">HTTP date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">httpdate</span> <span class="ruby-comment"># =&gt; &quot;Sat, 03 Feb 2001 00:00:00 GMT&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_httpdate</span>(<span class="ruby-identifier">s</span>)
<span class="ruby-comment"># =&gt; {:wday=&gt;6, :mday=&gt;3, :mon=&gt;2, :year=&gt;2001, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;&quot;GMT&quot;, :offset=&gt;0}</span>
</pre>

<p>Related: <a href="Date.html#method-c-httpdate"><code>Date.httpdate</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_httpdate-source">
            <pre>static VALUE
date_s__httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, &quot;1:&quot;, &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__httpdate(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_iso8601" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _iso8601(string, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code>, which should contain an <a href="strftime_formatting_rdoc.html#label-ISO+8601+Format+Specifications">ISO 8601 formatted date</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">iso8601</span>    <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_iso8601</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; {:mday=&gt;3, :year=&gt;2001, :mon=&gt;2}</span>
</pre>

<p>See argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>

<p>Related: <a href="Date.html#method-c-iso8601"><code>Date.iso8601</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_iso8601-source">
            <pre>static VALUE
date_s__iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, &quot;1:&quot;, &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__iso8601(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_jisx0301" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _jisx0301(string, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-JIS+X+0301+Format">JIS X 0301 date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">jisx0301</span>    <span class="ruby-comment"># =&gt; &quot;H13.02.03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_jisx0301</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}</span>
</pre>

<p>See argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>

<p>Related: <a href="Date.html#method-c-jisx0301"><code>Date.jisx0301</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_jisx0301-source">
            <pre>static VALUE
date_s__jisx0301(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, &quot;1:&quot;, &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__jisx0301(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_parse" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _parse(string, comp = true, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p><strong>Note</strong>: This method recognizes many forms in <code>string</code>, but it is not a validator. For formats, see <a href="strftime_formatting_rdoc.html#label-Specialized+Format+Strings">“Specialized Format Strings” in Formats for Dates and Times</a></p>

<p>If <code>string</code> does not specify a valid date, the result is unpredictable; consider using <a href="Date.html#method-c-_strptime"><code>Date._strptime</code></a> instead.</p>

<p>Returns a hash of values parsed from <code>string</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">_parse</span>(<span class="ruby-string">&#39;2001-02-03&#39;</span>) <span class="ruby-comment"># =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}</span>
</pre>

<p>If <code>comp</code> is <code>true</code> and the given year is in the range <code>(0..99)</code>, the current century is supplied; otherwise, the year is taken as given:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">_parse</span>(<span class="ruby-string">&#39;01-02-03&#39;</span>, <span class="ruby-keyword">true</span>)  <span class="ruby-comment"># =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_parse</span>(<span class="ruby-string">&#39;01-02-03&#39;</span>, <span class="ruby-keyword">false</span>) <span class="ruby-comment"># =&gt; {:year=&gt;1, :mon=&gt;2, :mday=&gt;3}</span>
</pre>

<p>See argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>

<p>Related: <a href="Date.html#method-c-parse"><code>Date.parse</code></a>(returns a Date object).</p>

          <div class="method-source-code" id="_parse-source">
            <pre>static VALUE
date_s__parse(int argc, VALUE *argv, VALUE klass)
{
    return date_s__parse_internal(argc, argv, klass);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_rfc2822" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _rfc2822(string, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">rfc2822</span> <span class="ruby-comment"># =&gt; &quot;Sat, 3 Feb 2001 00:00:00 +0000&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_rfc2822</span>(<span class="ruby-identifier">s</span>)
<span class="ruby-comment"># =&gt; {:wday=&gt;6, :mday=&gt;3, :mon=&gt;2, :year=&gt;2001, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;&quot;+0000&quot;, :offset=&gt;0}</span>
</pre>

<p>See argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>

<p><a href="Date.html#method-c-_rfc822"><code>Date._rfc822</code></a> is an alias for <a href="Date.html#method-c-_rfc2822"><code>Date._rfc2822</code></a>.</p>

<p>Related: <a href="Date.html#method-c-rfc2822"><code>Date.rfc2822</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_rfc2822-source">
            <pre>static VALUE
date_s__rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, &quot;1:&quot;, &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__rfc2822(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_rfc3339" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _rfc3339(string, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+3339+Format">RFC 3339 format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">rfc3339</span>     <span class="ruby-comment"># =&gt; &quot;2001-02-03T00:00:00+00:00&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_rfc3339</span>(<span class="ruby-identifier">s</span>)
<span class="ruby-comment"># =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;&quot;+00:00&quot;, :offset=&gt;0}</span>
</pre>

<p>See argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>

<p>Related: <a href="Date.html#method-c-rfc3339"><code>Date.rfc3339</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_rfc3339-source">
            <pre>static VALUE
date_s__rfc3339(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, &quot;1:&quot;, &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__rfc3339(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_rfc822" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _rfc2822(string, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">rfc2822</span> <span class="ruby-comment"># =&gt; &quot;Sat, 3 Feb 2001 00:00:00 +0000&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_rfc2822</span>(<span class="ruby-identifier">s</span>)
<span class="ruby-comment"># =&gt; {:wday=&gt;6, :mday=&gt;3, :mon=&gt;2, :year=&gt;2001, :hour=&gt;0, :min=&gt;0, :sec=&gt;0, :zone=&gt;&quot;+0000&quot;, :offset=&gt;0}</span>
</pre>

<p>See argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>

<p><a href="Date.html#method-c-_rfc822"><code>Date._rfc822</code></a> is an alias for <a href="Date.html#method-c-_rfc2822"><code>Date._rfc2822</code></a>.</p>

<p>Related: <a href="Date.html#method-c-rfc2822"><code>Date.rfc2822</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_rfc822-source">
            <pre>static VALUE
date_s__rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, &quot;1:&quot;, &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__rfc2822(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_strptime" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _strptime(string, format = &#39;%F&#39;) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code> according to the given <code>format</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">_strptime</span>(<span class="ruby-string">&#39;2001-02-03&#39;</span>, <span class="ruby-string">&#39;%Y-%m-%d&#39;</span>) <span class="ruby-comment"># =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}</span>
</pre>

<p>For other formats, see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>. (Unlike <a href="Date.html#method-i-strftime"><code>Date.strftime</code></a>, does not support flags and width.)</p>

<p>See also <a href="https://man7.org/linux/man-pages/man3/strptime.3.html">strptime(3)</a>.</p>

<p>Related: <a href="Date.html#method-c-strptime"><code>Date.strptime</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_strptime-source">
            <pre>static VALUE
date_s__strptime(int argc, VALUE *argv, VALUE klass)
{
    return date_s__strptime_internal(argc, argv, klass, &quot;%F&quot;);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-_xmlschema" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              _xmlschema(string, limit: 128) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of values parsed from <code>string</code>, which should be a valid XML date format:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">xmlschema</span>    <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">_xmlschema</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}</span>
</pre>

<p>See argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>

<p>Related: <a href="Date.html#method-c-xmlschema"><code>Date.xmlschema</code></a> (returns a Date object).</p>

          <div class="method-source-code" id="_xmlschema-source">
            <pre>static VALUE
date_s__xmlschema(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, opt;

    rb_scan_args(argc, argv, &quot;1:&quot;, &amp;str, &amp;opt);
    check_limit(str, opt);

    return date__xmlschema(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-civil" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">civil</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Same as <a href="Date.html#method-c-new"><code>Date.new</code></a>.</p>

          <div class="method-source-code" id="civil-source">
            <pre>static VALUE
date_s_civil(int argc, VALUE *argv, VALUE klass)
{
    return date_initialize(argc, argv, d_lite_s_alloc_simple(klass));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-commercial" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              commercial(cwyear = -4712, cweek = 1, cwday = 1, start = Date::ITALY) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object constructed from the arguments.</p>

<p>Argument <code>cwyear</code> gives the year, and should be an integer.</p>

<p>Argument <code>cweek</code> gives the index of the week within the year, and should be in range (1..53) or (-53..-1); in some years, 53 or -53 will be out-of-range; if negative, counts backward from the end of the year:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2022-01-03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">52</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2022-12-26&quot;</span>
</pre>

<p>Argument <code>cwday</code> gives the indes of the weekday within the week, and should be in range (1..7) or (-7..-1); 1 or -7 is Monday; if negative, counts backward from the end of the week:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2022-01-03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">1</span>, <span class="ruby-value">-7</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2022-01-03&quot;</span>
</pre>

<p>When <code>cweek</code> is 1:</p>
<ul><li>
<p>If January 1 is a Friday, Saturday, or Sunday, the first week begins in the week after:</p>

<pre class="ruby"><span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ABBR_DAYNAMES</span>[<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2023</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">wday</span>] <span class="ruby-comment"># =&gt; &quot;Sun&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2023</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2023-01-02&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2023</span>, <span class="ruby-value">1</span>, <span class="ruby-value">7</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2023-01-08&quot;</span>
</pre>
</li><li>
<p>Otherwise, the first week is the week of January 1, which may mean some of the days fall on the year before:</p>

<pre class="ruby"><span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ABBR_DAYNAMES</span>[<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2020</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">wday</span>] <span class="ruby-comment"># =&gt; &quot;Wed&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2020</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2019-12-30&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2020</span>, <span class="ruby-value">1</span>, <span class="ruby-value">7</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2020-01-05&quot;</span>
</pre>
</li></ul>

<p>See argument start.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>, <a href="Date.html#method-c-new"><code>Date.new</code></a>, <a href="Date.html#method-c-ordinal"><code>Date.ordinal</code></a>.</p>

          <div class="method-source-code" id="commercial-source">
            <pre>static VALUE
date_s_commercial(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vw, vd, vsg, y, fr, fr2, ret;
    int w, d;
    double sg;

    rb_scan_args(argc, argv, &quot;04&quot;, &amp;vy, &amp;vw, &amp;vd, &amp;vsg);

    y = INT2FIX(-4712);
    w = 1;
    d = 1;
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 4:
        val2sg(vsg, sg);
      case 3:
        check_numeric(vd, &quot;cwday&quot;);
        num2int_with_frac(d, positive_inf);
      case 2:
        check_numeric(vw, &quot;cweek&quot;);
        w = NUM2INT(vw);
      case 1:
        check_numeric(vy, &quot;year&quot;);
        y = vy;
    }

    {
        VALUE nth;
        int ry, rw, rd, rjd, ns;

        if (!valid_commercial_p(y, w, d, sg,
                                &amp;nth, &amp;ry,
                                &amp;rw, &amp;rd, &amp;rjd,
                                &amp;ns))
            rb_raise(eDateError, &quot;invalid date&quot;);

        ret = d_simple_new_internal(klass,
                                    nth, rjd,
                                    sg,
                                    0, 0, 0,
                                    HAVE_JD);
    }
    add_frac();
    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-gregorian_leap-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              gregorian_leap?(year) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the given year is a leap year in the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">gregorian_leap?</span>(<span class="ruby-value">2000</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">gregorian_leap?</span>(<span class="ruby-value">2001</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p><a href="Date.html#method-c-leap-3F"><code>Date.leap?</code></a> is an alias for <a href="Date.html#method-c-gregorian_leap-3F"><code>Date.gregorian_leap?</code></a>.</p>

<p>Related: <a href="Date.html#method-c-julian_leap-3F"><code>Date.julian_leap?</code></a>.</p>

          <div class="method-source-code" id="gregorian_leap-3F-source">
            <pre>static VALUE
date_s_gregorian_leap_p(VALUE klass, VALUE y)
{
    VALUE nth;
    int ry;

    check_numeric(y, &quot;year&quot;);
    decode_year(y, -1, &amp;nth, &amp;ry);
    return f_boolcast(c_gregorian_leap_p(ry));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-httpdate" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              httpdate(string = &#39;Mon, 01 Jan -4712 00:00:00 GMT&#39;, start = Date::ITALY, limit: 128) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-HTTP+Format">HTTP date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">httpdate</span>   <span class="ruby-comment"># =&gt; &quot;Sat, 03 Feb 2001 00:00:00 GMT&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">httpdate</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p>Related: <a href="Date.html#method-c-_httpdate"><code>Date._httpdate</code></a> (returns a hash).</p>

          <div class="method-source-code" id="httpdate-source">
            <pre>static VALUE
date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    rb_scan_args(argc, argv, &quot;02:&quot;, &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;Mon, 01 Jan -4712 00:00:00 GMT&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__httpdate(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-iso8601" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              iso8601(string = &#39;-4712-01-01&#39;, start = Date::ITALY, limit: 128) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should contain an <a href="strftime_formatting_rdoc.html#label-ISO+8601+Format+Specifications">ISO 8601 formatted date</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">iso8601</span>   <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">iso8601</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p>Related: <a href="Date.html#method-c-_iso8601"><code>Date._iso8601</code></a> (returns a hash).</p>

          <div class="method-source-code" id="iso8601-source">
            <pre>static VALUE
date_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    rb_scan_args(argc, argv, &quot;02:&quot;, &amp;str, &amp;sg, &amp;opt);
    if (!NIL_P(opt)) argc--;

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__iso8601(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-jd" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              jd(jd = 0, start = Date::ITALY) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object formed from the arguments:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-value">2451944</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-value">2451945</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-02-04&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-value">0</span>).<span class="ruby-identifier">to_s</span>       <span class="ruby-comment"># =&gt; &quot;-4712-01-01&quot;</span>
</pre>

<p>The returned date is:</p>
<ul><li>
<p>Gregorian, if the argument is greater than or equal to <code>start</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ITALY</span>                         <span class="ruby-comment"># =&gt; 2299161</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ITALY</span>).<span class="ruby-identifier">gregorian?</span>     <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ITALY</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">gregorian?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>
</li><li>
<p>Julian, otherwise</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ITALY</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">julian?</span>    <span class="ruby-comment"># =&gt; true</span>
</pre>
</li></ul>

<p>See argument start.</p>

<p>Related: <a href="Date.html#method-c-new"><code>Date.new</code></a>.</p>

          <div class="method-source-code" id="jd-source">
            <pre>static VALUE
date_s_jd(int argc, VALUE *argv, VALUE klass)
{
    VALUE vjd, vsg, jd, fr, fr2, ret;
    double sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;vjd, &amp;vsg);

    jd = INT2FIX(0);
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 2:
        val2sg(vsg, sg);
      case 1:
        check_numeric(vjd, &quot;jd&quot;);
        num2num_with_frac(jd, positive_inf);
    }

    {
        VALUE nth;
        int rjd;

        decode_jd(jd, &amp;nth, &amp;rjd);
        ret = d_simple_new_internal(klass,
                                    nth, rjd,
                                    sg,
                                    0, 0, 0,
                                    HAVE_JD);
    }
    add_frac();
    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-jisx0301" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              jisx0301(string = &#39;-4712-01-01&#39;, start = Date::ITALY, limit: 128) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-JIS+X+0301+Format">JIS X 0301 format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">jisx0301</span>   <span class="ruby-comment"># =&gt; &quot;H13.02.03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">jisx0301</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>For no-era year, legacy format, Heisei is assumed.</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">jisx0301</span>(<span class="ruby-string">&#39;13.02.03&#39;</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p>Related: <a href="Date.html#method-c-_jisx0301"><code>Date._jisx0301</code></a> (returns a hash).</p>

          <div class="method-source-code" id="jisx0301-source">
            <pre>static VALUE
date_s_jisx0301(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    rb_scan_args(argc, argv, &quot;02:&quot;, &amp;str, &amp;sg, &amp;opt);
    if (!NIL_P(opt)) argc--;

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__jisx0301(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-json_create" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">json_create</span><span
              class="method-args">(object)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Deserializes <a href="JSON.html"><code>JSON</code></a> string by converting Julian year <code>y</code>, month <code>m</code>, day <code>d</code> and Day of Calendar Reform <code>sg</code> to <a href="Date.html"><code>Date</code></a>.</p>

          <div class="method-source-code" id="json_create-source">
            <pre><span class="ruby-comment"># File ext/json/lib/json/add/date.rb, line 11</span>
<span class="ruby-keyword">def</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier ruby-title">json_create</span>(<span class="ruby-identifier">object</span>)
  <span class="ruby-identifier">civil</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">object</span>.<span class="ruby-identifier">values_at</span>(<span class="ruby-string">&#39;y&#39;</span>, <span class="ruby-string">&#39;m&#39;</span>, <span class="ruby-string">&#39;d&#39;</span>, <span class="ruby-string">&#39;sg&#39;</span>))
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-c-julian_leap-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              julian_leap?(year) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the given year is a leap year in the <a href="https://en.wikipedia.org/wiki/Proleptic_Julian_calendar">proleptic Julian calendar</a>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">julian_leap?</span>(<span class="ruby-value">1900</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">julian_leap?</span>(<span class="ruby-value">1901</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Related: <a href="Date.html#method-c-gregorian_leap-3F"><code>Date.gregorian_leap?</code></a>.</p>

          <div class="method-source-code" id="julian_leap-3F-source">
            <pre>static VALUE
date_s_julian_leap_p(VALUE klass, VALUE y)
{
    VALUE nth;
    int ry;

    check_numeric(y, &quot;year&quot;);
    decode_year(y, +1, &amp;nth, &amp;ry);
    return f_boolcast(c_julian_leap_p(ry));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-leap-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              gregorian_leap?(year) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the given year is a leap year in the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">gregorian_leap?</span>(<span class="ruby-value">2000</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">gregorian_leap?</span>(<span class="ruby-value">2001</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p><a href="Date.html#method-c-leap-3F"><code>Date.leap?</code></a> is an alias for <a href="Date.html#method-c-gregorian_leap-3F"><code>Date.gregorian_leap?</code></a>.</p>

<p>Related: <a href="Date.html#method-c-julian_leap-3F"><code>Date.julian_leap?</code></a>.</p>

          <div class="method-source-code" id="leap-3F-source">
            <pre>static VALUE
date_s_gregorian_leap_p(VALUE klass, VALUE y)
{
    VALUE nth;
    int ry;

    check_numeric(y, &quot;year&quot;);
    decode_year(y, -1, &amp;nth, &amp;ry);
    return f_boolcast(c_gregorian_leap_p(ry));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-new" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              new(year = -4712, month = 1, mday = 1, start = Date::ITALY) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object constructed from the given arguments:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>).<span class="ruby-identifier">to_s</span>        <span class="ruby-comment"># =&gt; &quot;2022-01-01&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">2</span>).<span class="ruby-identifier">to_s</span>     <span class="ruby-comment"># =&gt; &quot;2022-02-01&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">2</span>, <span class="ruby-value">4</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2022-02-04&quot;</span>
</pre>

<p>Argument <code>month</code> should be in range (1..12) or range (-12..-1); when the argument is negative, counts backward from the end of the year:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">-11</span>, <span class="ruby-value">4</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2022-02-04&quot;</span>
</pre>

<p>Argument <code>mday</code> should be in range (1..n) or range (-n..-1) where <code>n</code> is the number of days in the month; when the argument is negative, counts backward from the end of the month.</p>

<p>See argument start.</p>

<p><a href="Date.html#method-c-civil"><code>Date.civil</code></a> is an alias for <a href="Date.html#method-c-new"><code>Date.new</code></a>.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>.</p>

          <div class="method-source-code" id="new-source">
            <pre>static VALUE
date_initialize(int argc, VALUE *argv, VALUE self)
{
    VALUE vy, vm, vd, vsg, y, fr, fr2, ret;
    int m, d;
    double sg;
    struct SimpleDateData *dat = rb_check_typeddata(self, &amp;d_lite_type);

    if (!simple_dat_p(dat)) {
        rb_raise(rb_eTypeError, &quot;Date expected&quot;);
    }

    rb_scan_args(argc, argv, &quot;04&quot;, &amp;vy, &amp;vm, &amp;vd, &amp;vsg);

    y = INT2FIX(-4712);
    m = 1;
    d = 1;
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 4:
        val2sg(vsg, sg);
      case 3:
        check_numeric(vd, &quot;day&quot;);
        num2int_with_frac(d, positive_inf);
      case 2:
        check_numeric(vm, &quot;month&quot;);
        m = NUM2INT(vm);
      case 1:
        check_numeric(vy, &quot;year&quot;);
        y = vy;
    }

    if (guess_style(y, sg) &lt; 0) {
        VALUE nth;
        int ry, rm, rd;

        if (!valid_gregorian_p(y, m, d,
                               &amp;nth, &amp;ry,
                               &amp;rm, &amp;rd))
            rb_raise(eDateError, &quot;invalid date&quot;);

        set_to_simple(self, dat, nth, 0, sg, ry, rm, rd, HAVE_CIVIL);
    }
    else {
        VALUE nth;
        int ry, rm, rd, rjd, ns;

        if (!valid_civil_p(y, m, d, sg,
                           &amp;nth, &amp;ry,
                           &amp;rm, &amp;rd, &amp;rjd,
                           &amp;ns))
            rb_raise(eDateError, &quot;invalid date&quot;);

        set_to_simple(self, dat, nth, rjd, sg, ry, rm, rd, HAVE_JD | HAVE_CIVIL);
    }
    ret = self;
    add_frac();
    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-ordinal" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              ordinal(year = -4712, yday = 1, start = Date::ITALY) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object formed fom the arguments.</p>

<p>With no arguments, returns the date for January 1, -4712:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">ordinal</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;-4712-01-01&quot;</span>
</pre>

<p>With argument <code>year</code>, returns the date for January 1 of that year:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">2001</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2001-01-01&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">-2001</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;-2001-01-01&quot;</span>
</pre>

<p>With positive argument <code>yday</code> == <code>n</code>, returns the date for the <code>nth</code> day of the given year:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">14</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-01-14&quot;</span>
</pre>

<p>With negative argument <code>yday</code>, counts backward from the end of the year:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">-14</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-12-18&quot;</span>
</pre>

<p>Raises an exception if <code>yday</code> is zero or out of range.</p>

<p>See argument start.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>, <a href="Date.html#method-c-new"><code>Date.new</code></a>.</p>

          <div class="method-source-code" id="ordinal-source">
            <pre>static VALUE
date_s_ordinal(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vd, vsg, y, fr, fr2, ret;
    int d;
    double sg;

    rb_scan_args(argc, argv, &quot;03&quot;, &amp;vy, &amp;vd, &amp;vsg);

    y = INT2FIX(-4712);
    d = 1;
    fr2 = INT2FIX(0);
    sg = DEFAULT_SG;

    switch (argc) {
      case 3:
        val2sg(vsg, sg);
      case 2:
        check_numeric(vd, &quot;yday&quot;);
        num2int_with_frac(d, positive_inf);
      case 1:
        check_numeric(vy, &quot;year&quot;);
        y = vy;
    }

    {
        VALUE nth;
        int ry, rd, rjd, ns;

        if (!valid_ordinal_p(y, d, sg,
                             &amp;nth, &amp;ry,
                             &amp;rd, &amp;rjd,
                             &amp;ns))
            rb_raise(eDateError, &quot;invalid date&quot;);

        ret = d_simple_new_internal(klass,
                                     nth, rjd,
                                     sg,
                                     0, 0, 0,
                                     HAVE_JD);
    }
    add_frac();
    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-parse" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              parse(string = &#39;-4712-01-01&#39;, comp = true, start = Date::ITALY, limit: 128) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p><strong>Note</strong>: This method recognizes many forms in <code>string</code>, but it is not a validator. For formats, see <a href="strftime_formatting_rdoc.html#label-Specialized+Format+Strings">“Specialized Format Strings” in Formats for Dates and Times</a> If <code>string</code> does not specify a valid date, the result is unpredictable; consider using <a href="Date.html#method-c-_strptime"><code>Date._strptime</code></a> instead.</p>

<p>Returns a new Date object with values parsed from <code>string</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;2001-02-03&#39;</span>)   <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;20010203&#39;</span>)     <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;3rd Feb 2001&#39;</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>If <code>comp</code> is <code>true</code> and the given year is in the range <code>(0..99)</code>, the current century is supplied; otherwise, the year is taken as given:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;01-02-03&#39;</span>, <span class="ruby-keyword">true</span>)  <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&#39;01-02-03&#39;</span>, <span class="ruby-keyword">false</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 0001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p>Related: <a href="Date.html#method-c-_parse"><code>Date._parse</code></a> (returns a hash).</p>

          <div class="method-source-code" id="parse-source">
            <pre>static VALUE
date_s_parse(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, comp, sg, opt;

    rb_scan_args(argc, argv, &quot;03:&quot;, &amp;str, &amp;comp, &amp;sg, &amp;opt);
    if (!NIL_P(opt)) argc--;

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01&quot;);
      case 1:
        comp = Qtrue;
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 2;
        VALUE argv2[3], hash;
        argv2[0] = str;
        argv2[1] = comp;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__parse(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-rfc2822" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rfc2822(string = &#39;Mon, 1 Jan -4712 00:00:00 +0000&#39;, start = Date::ITALY, limit: 128) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">rfc2822</span>   <span class="ruby-comment"># =&gt; &quot;Sat, 3 Feb 2001 00:00:00 +0000&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">rfc2822</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p><a href="Date.html#method-c-rfc822"><code>Date.rfc822</code></a> is an alias for <a href="Date.html#method-c-rfc2822"><code>Date.rfc2822</code></a>.</p>

<p>Related: <a href="Date.html#method-c-_rfc2822"><code>Date._rfc2822</code></a> (returns a hash).</p>

          <div class="method-source-code" id="rfc2822-source">
            <pre>static VALUE
date_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    rb_scan_args(argc, argv, &quot;02:&quot;, &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;Mon, 1 Jan -4712 00:00:00 +0000&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__rfc2822(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-rfc3339" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rfc3339(string = &#39;-4712-01-01T00:00:00+00:00&#39;, start = Date::ITALY, limit: 128) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+3339+Format">RFC 3339 format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">rfc3339</span>   <span class="ruby-comment"># =&gt; &quot;2001-02-03T00:00:00+00:00&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">rfc3339</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p>Related: <a href="Date.html#method-c-_rfc3339"><code>Date._rfc3339</code></a> (returns a hash).</p>

          <div class="method-source-code" id="rfc3339-source">
            <pre>static VALUE
date_s_rfc3339(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    rb_scan_args(argc, argv, &quot;02:&quot;, &amp;str, &amp;sg, &amp;opt);
    if (!NIL_P(opt)) argc--;

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01T00:00:00+00:00&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__rfc3339(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-rfc822" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rfc2822(string = &#39;Mon, 1 Jan -4712 00:00:00 +0000&#39;, start = Date::ITALY, limit: 128) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">rfc2822</span>   <span class="ruby-comment"># =&gt; &quot;Sat, 3 Feb 2001 00:00:00 +0000&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">rfc2822</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p><a href="Date.html#method-c-rfc822"><code>Date.rfc822</code></a> is an alias for <a href="Date.html#method-c-rfc2822"><code>Date.rfc2822</code></a>.</p>

<p>Related: <a href="Date.html#method-c-_rfc2822"><code>Date._rfc2822</code></a> (returns a hash).</p>

          <div class="method-source-code" id="rfc822-source">
            <pre>static VALUE
date_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    rb_scan_args(argc, argv, &quot;02:&quot;, &amp;str, &amp;sg, &amp;opt);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;Mon, 1 Jan -4712 00:00:00 +0000&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__rfc2822(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-strptime" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              strptime(string = &#39;-4712-01-01&#39;, format = &#39;%F&#39;, start = Date::ITALY) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, according to the given <code>format</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;2001-02-03&#39;</span>, <span class="ruby-string">&#39;%Y-%m-%d&#39;</span>)  <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;03-02-2001&#39;</span>, <span class="ruby-string">&#39;%d-%m-%Y&#39;</span>)  <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;2001-034&#39;</span>, <span class="ruby-string">&#39;%Y-%j&#39;</span>)       <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;2001-W05-6&#39;</span>, <span class="ruby-string">&#39;%G-W%V-%u&#39;</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;2001 04 6&#39;</span>, <span class="ruby-string">&#39;%Y %U %w&#39;</span>)   <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;2001 05 6&#39;</span>, <span class="ruby-string">&#39;%Y %W %u&#39;</span>)   <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">&#39;sat3feb01&#39;</span>, <span class="ruby-string">&#39;%a%d%b%y&#39;</span>)   <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>For other formats, see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>. (Unlike <a href="Date.html#method-i-strftime"><code>Date.strftime</code></a>, does not support flags and width.)</p>

<p>See argument start.</p>

<p>See also <a href="https://man7.org/linux/man-pages/man3/strptime.3.html">strptime(3)</a>.</p>

<p>Related: <a href="Date.html#method-c-_strptime"><code>Date._strptime</code></a> (returns a hash).</p>

          <div class="method-source-code" id="strptime-source">
            <pre>static VALUE
date_s_strptime(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, fmt, sg;

    rb_scan_args(argc, argv, &quot;03&quot;, &amp;str, &amp;fmt, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01&quot;);
      case 1:
        fmt = rb_str_new2(&quot;%F&quot;);
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE argv2[2], hash;

        argv2[0] = str;
        argv2[1] = fmt;
        hash = date_s__strptime(2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-today" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              today(start = Date::ITALY) &rarr; date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object constructed from the present date:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">today</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2022-07-06&quot;</span>
</pre>

<p>See argument start.</p>

          <div class="method-source-code" id="today-source">
            <pre>static VALUE
date_s_today(int argc, VALUE *argv, VALUE klass)
{
    VALUE vsg, nth, ret;
    double sg;
    time_t t;
    struct tm tm;
    int y, ry, m, d;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;vsg);

    if (argc &lt; 1)
        sg = DEFAULT_SG;
    else
        val2sg(vsg, sg);

    if (time(&amp;t) == -1)
        rb_sys_fail(&quot;time&quot;);
    tzset();
    if (!localtime_r(&amp;t, &amp;tm))
        rb_sys_fail(&quot;localtime&quot;);

    y = tm.tm_year + 1900;
    m = tm.tm_mon + 1;
    d = tm.tm_mday;

    decode_year(INT2FIX(y), -1, &amp;nth, &amp;ry);

    ret = d_simple_new_internal(klass,
                                nth, 0,
                                GREGORIAN,
                                ry, m, d,
                                HAVE_CIVIL);
    {
        get_d1(ret);
        set_sg(dat, sg);
    }
    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-valid_civil-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              valid_civil?(year, month, mday, start = Date::ITALY) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the arguments define a valid ordinal date, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_date?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_date?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">29</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_date?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>See argument start.</p>

<p><a href="Date.html#method-c-valid_date-3F"><code>Date.valid_date?</code></a> is an alias for <a href="Date.html#method-c-valid_civil-3F"><code>Date.valid_civil?</code></a>.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>, <a href="Date.html#method-c-new"><code>Date.new</code></a>.</p>

          <div class="method-source-code" id="valid_civil-3F-source">
            <pre>static VALUE
date_s_valid_civil_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vm, vd, vsg;
    VALUE argv2[4];

    rb_scan_args(argc, argv, &quot;31&quot;, &amp;vy, &amp;vm, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vm);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vm;
    argv2[2] = vd;
    if (argc &lt; 4)
        argv2[3] = INT2FIX(DEFAULT_SG);
    else
        argv2[3] = vsg;

    if (NIL_P(valid_civil_sub(4, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-valid_commercial-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              valid_commercial?(cwyear, cweek, cwday, start = Date::ITALY) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the arguments define a valid commercial date, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_commercial?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">5</span>, <span class="ruby-value">6</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_commercial?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">5</span>, <span class="ruby-value">8</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>See <a href="Date.html#method-c-commercial"><code>Date.commercial</code></a>.</p>

<p>See argument start.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>, <a href="Date.html#method-c-commercial"><code>Date.commercial</code></a>.</p>

          <div class="method-source-code" id="valid_commercial-3F-source">
            <pre>static VALUE
date_s_valid_commercial_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vw, vd, vsg;
    VALUE argv2[4];

    rb_scan_args(argc, argv, &quot;31&quot;, &amp;vy, &amp;vw, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vw);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vw;
    argv2[2] = vd;
    if (argc &lt; 4)
        argv2[3] = INT2FIX(DEFAULT_SG);
    else
        argv2[3] = vsg;

    if (NIL_P(valid_commercial_sub(4, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-valid_date-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              valid_civil?(year, month, mday, start = Date::ITALY) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the arguments define a valid ordinal date, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_date?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_date?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">29</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_date?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>See argument start.</p>

<p><a href="Date.html#method-c-valid_date-3F"><code>Date.valid_date?</code></a> is an alias for <a href="Date.html#method-c-valid_civil-3F"><code>Date.valid_civil?</code></a>.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>, <a href="Date.html#method-c-new"><code>Date.new</code></a>.</p>

          <div class="method-source-code" id="valid_date-3F-source">
            <pre>static VALUE
date_s_valid_civil_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vm, vd, vsg;
    VALUE argv2[4];

    rb_scan_args(argc, argv, &quot;31&quot;, &amp;vy, &amp;vm, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vm);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vm;
    argv2[2] = vd;
    if (argc &lt; 4)
        argv2[3] = INT2FIX(DEFAULT_SG);
    else
        argv2[3] = vsg;

    if (NIL_P(valid_civil_sub(4, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-valid_jd-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              valid_jd?(jd, start = Date::ITALY) &rarr; true
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Implemented for compatibility; returns <code>true</code> unless <code>jd</code> is invalid (i.e., not a <a href="Numeric.html"><code>Numeric</code></a>).</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_jd?</span>(<span class="ruby-value">2451944</span>) <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>See argument start.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>.</p>

          <div class="method-source-code" id="valid_jd-3F-source">
            <pre>static VALUE
date_s_valid_jd_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vjd, vsg;
    VALUE argv2[2];

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;vjd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vjd);
    argv2[0] = vjd;
    if (argc &lt; 2)
        argv2[1] = INT2FIX(DEFAULT_SG);
    else
        argv2[1] = vsg;

    if (NIL_P(valid_jd_sub(2, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-valid_ordinal-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              valid_ordinal?(year, yday, start = Date::ITALY) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the arguments define a valid ordinal date, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_ordinal?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">34</span>)  <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">valid_ordinal?</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">366</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>See argument start.</p>

<p>Related: <a href="Date.html#method-c-jd"><code>Date.jd</code></a>, <a href="Date.html#method-c-ordinal"><code>Date.ordinal</code></a>.</p>

          <div class="method-source-code" id="valid_ordinal-3F-source">
            <pre>static VALUE
date_s_valid_ordinal_p(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vd, vsg;
    VALUE argv2[3];

    rb_scan_args(argc, argv, &quot;21&quot;, &amp;vy, &amp;vd, &amp;vsg);

    RETURN_FALSE_UNLESS_NUMERIC(vy);
    RETURN_FALSE_UNLESS_NUMERIC(vd);
    argv2[0] = vy;
    argv2[1] = vd;
    if (argc &lt; 3)
        argv2[2] = INT2FIX(DEFAULT_SG);
    else
        argv2[2] = vsg;

    if (NIL_P(valid_ordinal_sub(3, argv2, klass, 0)))
        return Qfalse;
    return Qtrue;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-xmlschema" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              xmlschema(string = &#39;-4712-01-01&#39;, start = Date::ITALY, limit: 128)  &rarr;  date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid XML date format:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">xmlschema</span>   <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">xmlschema</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p>Related: <a href="Date.html#method-c-_xmlschema"><code>Date._xmlschema</code></a> (returns a hash).</p>

          <div class="method-source-code" id="xmlschema-source">
            <pre>static VALUE
date_s_xmlschema(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg, opt;

    rb_scan_args(argc, argv, &quot;02:&quot;, &amp;str, &amp;sg, &amp;opt);
    if (!NIL_P(opt)) argc--;

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        int argc2 = 1;
        VALUE argv2[2], hash;
        argv2[0] = str;
        if (!NIL_P(opt)) argv2[argc2++] = opt;
        hash = date_s__xmlschema(argc2, argv2, klass);
        return d_new_by_frags(klass, hash, sg);
    }
}</pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-2B" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              d + other  &rarr;  date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a date object pointing <code>other</code> days after self.  The other should be a numeric value.  If the other is a fractional number, assumes its precision is at most nanosecond.</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>) <span class="ruby-operator">+</span> <span class="ruby-value">1</span>    <span class="ruby-comment">#=&gt; #&lt;Date: 2001-02-04 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">Rational</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T12:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">Rational</span>(<span class="ruby-value">-1</span>,<span class="ruby-value">2</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-02T12:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-value">0</span>,<span class="ruby-value">12</span>) <span class="ruby-operator">+</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>).<span class="ruby-identifier">ajd</span>
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;</span>
</pre>

          <div class="method-source-code" id="2B-source">
            <pre>static VALUE
d_lite_plus(VALUE self, VALUE other)
{
    int try_rational = 1;
    get_d1(self);

  again:
    switch (TYPE(other)) {
      case T_FIXNUM:
        {
            VALUE nth;
            long t;
            int jd;

            nth = m_nth(dat);
            t = FIX2LONG(other);
            if (DIV(t, CM_PERIOD)) {
                nth = f_add(nth, INT2FIX(DIV(t, CM_PERIOD)));
                t = MOD(t, CM_PERIOD);
            }

            if (!t)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + (int)t;
                canonicalize_jd(nth, jd);
            }

            if (simple_dat_p(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, jd,
                                             dat-&gt;s.sg,
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~HAVE_CIVIL);
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, jd,
                                              dat-&gt;c.df, dat-&gt;c.sf,
                                              dat-&gt;c.of, dat-&gt;c.sg,
                                              0, 0, 0,
#ifndef USE_PACK
                                              dat-&gt;c.hour,
                                              dat-&gt;c.min,
                                              dat-&gt;c.sec,
#else
                                              EX_HOUR(dat-&gt;c.pc),
                                              EX_MIN(dat-&gt;c.pc),
                                              EX_SEC(dat-&gt;c.pc),
#endif
                                              (dat-&gt;c.flags | HAVE_JD) &amp;
                                              ~HAVE_CIVIL);
        }
        break;
      case T_BIGNUM:
        {
            VALUE nth;
            int jd, s;

            if (f_positive_p(other))
                s = +1;
            else {
                s = -1;
                other = f_negate(other);
            }

            nth = f_idiv(other, INT2FIX(CM_PERIOD));
            jd = FIX2INT(f_mod(other, INT2FIX(CM_PERIOD)));

            if (s &lt; 0) {
                nth = f_negate(nth);
                jd = -jd;
            }

            if (!jd)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + jd;
                canonicalize_jd(nth, jd);
            }

            if (f_zero_p(nth))
                nth = m_nth(dat);
            else
                nth = f_add(m_nth(dat), nth);

            if (simple_dat_p(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, jd,
                                             dat-&gt;s.sg,
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~HAVE_CIVIL);
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, jd,
                                              dat-&gt;c.df, dat-&gt;c.sf,
                                              dat-&gt;c.of, dat-&gt;c.sg,
                                              0, 0, 0,
#ifndef USE_PACK
                                              dat-&gt;c.hour,
                                              dat-&gt;c.min,
                                              dat-&gt;c.sec,
#else
                                              EX_HOUR(dat-&gt;c.pc),
                                              EX_MIN(dat-&gt;c.pc),
                                              EX_SEC(dat-&gt;c.pc),
#endif
                                              (dat-&gt;c.flags | HAVE_JD) &amp;
                                              ~HAVE_CIVIL);
        }
        break;
      case T_FLOAT:
        {
            double jd, o, tmp;
            int s, df;
            VALUE nth, sf;

            o = RFLOAT_VALUE(other);

            if (o &gt; 0)
                s = +1;
            else {
                s = -1;
                o = -o;
            }

            o = modf(o, &amp;tmp);

            if (!floor(tmp / CM_PERIOD)) {
                nth = INT2FIX(0);
                jd = (int)tmp;
            }
            else {
                double i, f;

                f = modf(tmp / CM_PERIOD, &amp;i);
                nth = f_floor(DBL2NUM(i));
                jd = (int)(f * CM_PERIOD);
            }

            o *= DAY_IN_SECONDS;
            o = modf(o, &amp;tmp);
            df = (int)tmp;
            o *= SECOND_IN_NANOSECONDS;
            sf = INT2FIX((int)round(o));

            if (s &lt; 0) {
                jd = -jd;
                df = -df;
                sf = f_negate(sf);
            }

            if (f_zero_p(sf))
                sf = m_sf(dat);
            else {
                sf = f_add(m_sf(dat), sf);
                if (f_lt_p(sf, INT2FIX(0))) {
                    df -= 1;
                    sf = f_add(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
                else if (f_ge_p(sf, INT2FIX(SECOND_IN_NANOSECONDS))) {
                    df += 1;
                    sf = f_sub(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
            }

            if (!df)
                df = m_df(dat);
            else {
                df = m_df(dat) + df;
                if (df &lt; 0) {
                    jd -= 1;
                    df += DAY_IN_SECONDS;
                }
                else if (df &gt;= DAY_IN_SECONDS) {
                    jd += 1;
                    df -= DAY_IN_SECONDS;
                }
            }

            if (!jd)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + jd;
                canonicalize_jd(nth, jd);
            }

            if (f_zero_p(nth))
                nth = m_nth(dat);
            else
                nth = f_add(m_nth(dat), nth);

            if (!df &amp;&amp; f_zero_p(sf) &amp;&amp; !m_of(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, (int)jd,
                                             m_sg(dat),
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~(HAVE_CIVIL | HAVE_TIME |
                                               COMPLEX_DAT));
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, (int)jd,
                                              df, sf,
                                              m_of(dat), m_sg(dat),
                                              0, 0, 0,
                                              0, 0, 0,
                                              (dat-&gt;c.flags |
                                               HAVE_JD | HAVE_DF) &amp;
                                              ~(HAVE_CIVIL | HAVE_TIME));
        }
        break;
      default:
        expect_numeric(other);
        other = f_to_r(other);
        if (!k_rational_p(other)) {
            if (!try_rational) Check_Type(other, T_RATIONAL);
            try_rational = 0;
            goto again;
        }
        /* fall through */
      case T_RATIONAL:
        {
            VALUE nth, sf, t;
            int jd, df, s;

            if (wholenum_p(other)) {
                other = rb_rational_num(other);
                goto again;
            }

            if (f_positive_p(other))
                s = +1;
            else {
                s = -1;
                other = f_negate(other);
            }

            nth = f_idiv(other, INT2FIX(CM_PERIOD));
            t = f_mod(other, INT2FIX(CM_PERIOD));

            jd = FIX2INT(f_idiv(t, INT2FIX(1)));
            t = f_mod(t, INT2FIX(1));

            t = f_mul(t, INT2FIX(DAY_IN_SECONDS));
            df = FIX2INT(f_idiv(t, INT2FIX(1)));
            t = f_mod(t, INT2FIX(1));

            sf = f_mul(t, INT2FIX(SECOND_IN_NANOSECONDS));

            if (s &lt; 0) {
                nth = f_negate(nth);
                jd = -jd;
                df = -df;
                sf = f_negate(sf);
            }

            if (f_zero_p(sf))
                sf = m_sf(dat);
            else {
                sf = f_add(m_sf(dat), sf);
                if (f_lt_p(sf, INT2FIX(0))) {
                    df -= 1;
                    sf = f_add(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
                else if (f_ge_p(sf, INT2FIX(SECOND_IN_NANOSECONDS))) {
                    df += 1;
                    sf = f_sub(sf, INT2FIX(SECOND_IN_NANOSECONDS));
                }
            }

            if (!df)
                df = m_df(dat);
            else {
                df = m_df(dat) + df;
                if (df &lt; 0) {
                    jd -= 1;
                    df += DAY_IN_SECONDS;
                }
                else if (df &gt;= DAY_IN_SECONDS) {
                    jd += 1;
                    df -= DAY_IN_SECONDS;
                }
            }

            if (!jd)
                jd = m_jd(dat);
            else {
                jd = m_jd(dat) + jd;
                canonicalize_jd(nth, jd);
            }

            if (f_zero_p(nth))
                nth = m_nth(dat);
            else
                nth = f_add(m_nth(dat), nth);

            if (!df &amp;&amp; f_zero_p(sf) &amp;&amp; !m_of(dat))
                return d_simple_new_internal(rb_obj_class(self),
                                             nth, jd,
                                             m_sg(dat),
                                             0, 0, 0,
                                             (dat-&gt;s.flags | HAVE_JD) &amp;
                                             ~(HAVE_CIVIL | HAVE_TIME |
                                               COMPLEX_DAT));
            else
                return d_complex_new_internal(rb_obj_class(self),
                                              nth, jd,
                                              df, sf,
                                              m_of(dat), m_sg(dat),
                                              0, 0, 0,
                                              0, 0, 0,
                                              (dat-&gt;c.flags |
                                               HAVE_JD | HAVE_DF) &amp;
                                              ~(HAVE_CIVIL | HAVE_TIME));
        }
        break;
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2D" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              d - other  &rarr;  date or rational
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the difference between the two dates if the other is a date object.  If the other is a numeric value, returns a date object pointing <code>other</code> days before self.  If the other is a fractional number, assumes its precision is at most nanosecond.</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>) <span class="ruby-operator">-</span> <span class="ruby-value">1</span>   <span class="ruby-comment">#=&gt; #&lt;Date: 2001-02-02 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>) <span class="ruby-operator">-</span> <span class="ruby-constant">Rational</span>(<span class="ruby-value">1</span>,<span class="ruby-value">2</span>)
                         <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-02T12:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>) <span class="ruby-operator">-</span> <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>)
                         <span class="ruby-comment">#=&gt; (33/1)</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>) <span class="ruby-operator">-</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">2</span>,<span class="ruby-value">12</span>)
                         <span class="ruby-comment">#=&gt; (1/2)</span>
</pre>

          <div class="method-source-code" id="2D-source">
            <pre>static VALUE
d_lite_minus(VALUE self, VALUE other)
{
    if (k_date_p(other))
        return minus_dd(self, other);

    switch (TYPE(other)) {
      case T_FIXNUM:
        return d_lite_plus(self, LONG2NUM(-FIX2LONG(other)));
      case T_FLOAT:
        return d_lite_plus(self, DBL2NUM(-RFLOAT_VALUE(other)));
      default:
        expect_numeric(other);
        /* fall through */
      case T_BIGNUM:
      case T_RATIONAL:
        return d_lite_plus(self, f_negate(other));
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3C-3C" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              d &lt;&lt; n  &rarr;  date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object representing the date <code>n</code> months earlier; <code>n</code> should be a numeric:</p>

<pre class="ruby">(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2001-01-03&quot;</span>
(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">-2</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-04-03&quot;</span>
</pre>

<p>When the same day does not exist for the new month, the last day of that month is used instead:</p>

<pre class="ruby">(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">3</span>, <span class="ruby-value">31</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2001-02-28&quot;</span>
(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">3</span>, <span class="ruby-value">31</span>) <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">-6</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-09-30&quot;</span>
</pre>

<p>This results in the following, possibly unexpected, behaviors:</p>

<pre class="ruby"><span class="ruby-identifier">d0</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">3</span>, <span class="ruby-value">31</span>)
<span class="ruby-identifier">d0</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">2</span>      <span class="ruby-comment"># =&gt; #&lt;Date: 2001-01-31&gt;</span>
<span class="ruby-identifier">d0</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">1</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">1</span> <span class="ruby-comment"># =&gt; #&lt;Date: 2001-01-28&gt;</span>

<span class="ruby-identifier">d0</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">3</span>, <span class="ruby-value">31</span>)
<span class="ruby-identifier">d1</span> = <span class="ruby-identifier">d0</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">1</span>  <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-28&gt;</span>
<span class="ruby-identifier">d2</span> = <span class="ruby-identifier">d1</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">-1</span> <span class="ruby-comment"># =&gt; #&lt;Date: 2001-03-28&gt;</span>
</pre>

          <div class="method-source-code" id="3C-3C-source">
            <pre>static VALUE
d_lite_lshift(VALUE self, VALUE other)
{
    expect_numeric(other);
    return d_lite_rshift(self, f_negate(other));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3C-3D-3E" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              self &lt;=&gt; other  &rarr; -1, 0, 1 or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Compares <code>self</code> and <code>other</code>, returning:</p>
<ul><li>
<p><code>-1</code> if <code>other</code> is larger.</p>
</li><li>
<p><code>0</code> if the two are equal.</p>
</li><li>
<p><code>1</code> if <code>other</code> is smaller.</p>
</li><li>
<p><code>nil</code> if the two are incomparable.</p>
</li></ul>

<p>Argument <code>other</code> may be:</p>
<ul><li>
<p>Another Date object:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">27</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2022-07-27 ((2459788j,0s,0n),+0s,2299161j)&gt;</span>
<span class="ruby-identifier">prev_date</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">prev_day</span>    <span class="ruby-comment"># =&gt; #&lt;Date: 2022-07-26 ((2459787j,0s,0n),+0s,2299161j)&gt;</span>
<span class="ruby-identifier">next_date</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">next_day</span>    <span class="ruby-comment"># =&gt; #&lt;Date: 2022-07-28 ((2459789j,0s,0n),+0s,2299161j)&gt;</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">next_date</span>           <span class="ruby-comment"># =&gt; -1</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">d</span>                   <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">prev_date</span>           <span class="ruby-comment"># =&gt; 1</span>
</pre>
</li><li>
<p>A <a href="DateTime.html"><code>DateTime</code></a> object:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">26</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">27</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">28</span>) <span class="ruby-comment"># =&gt; -1</span>
</pre>
</li><li>
<p>A numeric (compares <code>self.ajd</code> to <code>other</code>):</p>

<pre class="ruby"><span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-value">2459788</span> <span class="ruby-comment"># =&gt; -1</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-value">2459787</span> <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-value">2459786</span> <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-identifier">d</span>.<span class="ruby-identifier">ajd</span>   <span class="ruby-comment"># =&gt; 0</span>
</pre>
</li><li>
<p>Any other object:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-constant">Object</span>.<span class="ruby-identifier">new</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>
</li></ul>

          <div class="method-source-code" id="3C-3D-3E-source">
            <pre>static VALUE
d_lite_cmp(VALUE self, VALUE other)
{
    if (!k_date_p(other))
        return cmp_gen(self, other);

    {
        get_d2(self, other);

        if (!(simple_dat_p(adat) &amp;&amp; simple_dat_p(bdat) &amp;&amp;
              m_gregorian_p(adat) == m_gregorian_p(bdat)))
            return cmp_dd(self, other);

        {
            VALUE a_nth, b_nth;
            int a_jd, b_jd;

            m_canonicalize_jd(self, adat);
            m_canonicalize_jd(other, bdat);
            a_nth = m_nth(adat);
            b_nth = m_nth(bdat);
            if (f_eqeq_p(a_nth, b_nth)) {
                a_jd = m_jd(adat);
                b_jd = m_jd(bdat);
                if (a_jd == b_jd) {
                    return INT2FIX(0);
                }
                else if (a_jd &lt; b_jd) {
                    return INT2FIX(-1);
                }
                else {
                    return INT2FIX(1);
                }
            }
            else if (f_lt_p(a_nth, b_nth)) {
                return INT2FIX(-1);
            }
            else {
                return INT2FIX(1);
            }
        }
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3D-3D-3D" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              self === other &rarr; true, false, or nil.
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> and <code>other</code> represent the same date, <code>false</code> if not, <code>nil</code> if the two are not comparable.</p>

<p>Argument <code>other</code> may be:</p>
<ul><li>
<p>Another Date object:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">27</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2022-07-27 ((2459788j,0s,0n),+0s,2299161j)&gt;</span>
<span class="ruby-identifier">prev_date</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">prev_day</span>    <span class="ruby-comment"># =&gt; #&lt;Date: 2022-07-26 ((2459787j,0s,0n),+0s,2299161j)&gt;</span>
<span class="ruby-identifier">next_date</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">next_day</span>    <span class="ruby-comment"># =&gt; #&lt;Date: 2022-07-28 ((2459789j,0s,0n),+0s,2299161j)&gt;</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">prev_date</span>           <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">d</span>                   <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">next_date</span>           <span class="ruby-comment"># =&gt; false</span>
</pre>
</li><li>
<p>A <a href="DateTime.html"><code>DateTime</code></a> object:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">26</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">27</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">7</span>, <span class="ruby-value">28</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>
</li><li>
<p>A numeric (compares <code>self.jd</code> to <code>other</code>):</p>

<pre class="ruby"><span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-value">2459788</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-value">2459787</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-value">2459786</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">d</span>.<span class="ruby-identifier">jd</span>    <span class="ruby-comment"># =&gt; true</span>
</pre>
</li><li>
<p>An object not comparable:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> <span class="ruby-operator">===</span> <span class="ruby-constant">Object</span>.<span class="ruby-identifier">new</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>
</li></ul>

          <div class="method-source-code" id="3D-3D-3D-source">
            <pre>static VALUE
d_lite_equal(VALUE self, VALUE other)
{
    if (!k_date_p(other))
        return equal_gen(self, other);

    {
        get_d2(self, other);

        if (!(m_gregorian_p(adat) == m_gregorian_p(bdat)))
            return equal_gen(self, other);

        {
            VALUE a_nth, b_nth;
            int a_jd, b_jd;

            m_canonicalize_jd(self, adat);
            m_canonicalize_jd(other, bdat);
            a_nth = m_nth(adat);
            b_nth = m_nth(bdat);
            a_jd = m_local_jd(adat);
            b_jd = m_local_jd(bdat);
            if (f_eqeq_p(a_nth, b_nth) &amp;&amp;
                a_jd == b_jd)
                return Qtrue;
            return Qfalse;
        }
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3E-3E" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              d &gt;&gt; n &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object representing the date <code>n</code> months later; <code>n</code> should be a numeric:</p>

<pre class="ruby">(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>) <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2001-03-03&quot;</span>
(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>) <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">-2</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2000-12-03&quot;</span>
</pre>

<p>When the same day does not exist for the new month, the last day of that month is used instead:</p>

<pre class="ruby">(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">1</span>, <span class="ruby-value">31</span>) <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">to_s</span>  <span class="ruby-comment"># =&gt; &quot;2001-02-28&quot;</span>
(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">1</span>, <span class="ruby-value">31</span>) <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">-4</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2000-09-30&quot;</span>
</pre>

<p>This results in the following, possibly unexpected, behaviors:</p>

<pre class="ruby"><span class="ruby-identifier">d0</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">1</span>, <span class="ruby-value">31</span>)
<span class="ruby-identifier">d1</span> = <span class="ruby-identifier">d0</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">1</span> <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-28&gt;</span>
<span class="ruby-identifier">d2</span> = <span class="ruby-identifier">d1</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">1</span> <span class="ruby-comment"># =&gt; #&lt;Date: 2001-03-28&gt;</span>

<span class="ruby-identifier">d0</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">1</span>, <span class="ruby-value">31</span>)
<span class="ruby-identifier">d1</span> = <span class="ruby-identifier">d0</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">1</span>  <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-28&gt;</span>
<span class="ruby-identifier">d2</span> = <span class="ruby-identifier">d1</span> <span class="ruby-operator">&gt;&gt;</span> <span class="ruby-value">-1</span> <span class="ruby-comment"># =&gt; #&lt;Date: 2001-01-28&gt;</span>
</pre>

          <div class="method-source-code" id="3E-3E-source">
            <pre>static VALUE
d_lite_rshift(VALUE self, VALUE other)
{
    VALUE t, y, nth, rjd2;
    int m, d, rjd;
    double sg;

    get_d1(self);
    t = f_add3(f_mul(m_real_year(dat), INT2FIX(12)),
               INT2FIX(m_mon(dat) - 1),
               other);
    if (FIXNUM_P(t)) {
        long it = FIX2LONG(t);
        y = LONG2NUM(DIV(it, 12));
        it = MOD(it, 12);
        m = (int)it + 1;
    }
    else {
        y = f_idiv(t, INT2FIX(12));
        t = f_mod(t, INT2FIX(12));
        m = FIX2INT(t) + 1;
    }
    d = m_mday(dat);
    sg = m_sg(dat);

    while (1) {
        int ry, rm, rd, ns;

        if (valid_civil_p(y, m, d, sg,
                          &amp;nth, &amp;ry,
                          &amp;rm, &amp;rd, &amp;rjd, &amp;ns))
            break;
        if (--d &lt; 1)
            rb_raise(eDateError, &quot;invalid date&quot;);
    }
    encode_jd(nth, rjd, &amp;rjd2);
    return d_lite_plus(self, f_sub(rjd2, m_real_local_jd(dat)));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-ajd" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              ajd  &rarr;  rational
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the astronomical Julian day number.  This is a fractional number, which is not adjusted by the offset.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;+7&#39;</span>).<span class="ruby-identifier">ajd</span>     <span class="ruby-comment">#=&gt; (11769328217/4800)</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">2</span>,<span class="ruby-value">14</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;-7&#39;</span>).<span class="ruby-identifier">ajd</span>    <span class="ruby-comment">#=&gt; (11769328217/4800)</span>
</pre>

          <div class="method-source-code" id="ajd-source">
            <pre>static VALUE
d_lite_ajd(VALUE self)
{
    get_d1(self);
    return m_ajd(dat);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-amjd" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              amjd  &rarr;  rational
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the astronomical modified Julian day number.  This is a fractional number, which is not adjusted by the offset.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;+7&#39;</span>).<span class="ruby-identifier">amjd</span>    <span class="ruby-comment">#=&gt; (249325817/4800)</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">2</span>,<span class="ruby-value">14</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;-7&#39;</span>).<span class="ruby-identifier">amjd</span>   <span class="ruby-comment">#=&gt; (249325817/4800)</span>
</pre>

          <div class="method-source-code" id="amjd-source">
            <pre>static VALUE
d_lite_amjd(VALUE self)
{
    get_d1(self);
    return m_amjd(dat);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-as_json" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">as_json</span><span
              class="method-args">(*)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash, that will be turned into a <a href="JSON.html"><code>JSON</code></a> object and represent this object.</p>

          <div class="method-source-code" id="as_json-source">
            <pre><span class="ruby-comment"># File ext/json/lib/json/add/date.rb, line 19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">as_json</span>(<span class="ruby-operator">*</span>)
  {
    <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">create_id</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">class</span>.<span class="ruby-identifier">name</span>,
    <span class="ruby-string">&#39;y&#39;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-identifier">year</span>,
    <span class="ruby-string">&#39;m&#39;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-identifier">month</span>,
    <span class="ruby-string">&#39;d&#39;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-identifier">day</span>,
    <span class="ruby-string">&#39;sg&#39;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-identifier">start</span>,
  }
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-asctime" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">asctime</span><span
              class="method-args"> -&gt; string</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-strftime"><code>strftime</code></a> with argument <code>&#39;%a %b %e %T %Y&#39;</code> (or its <a href="strftime_formatting_rdoc.html#label-Shorthand+Conversion+Specifiers">shorthand form</a> <code>&#39;%c&#39;</code>):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">asctime</span> <span class="ruby-comment"># =&gt; &quot;Sat Feb  3 00:00:00 2001&quot;</span>
</pre>

<p>See <a href="https://linux.die.net/man/3/asctime">asctime</a>.</p>

<p><a href="Date.html#method-i-ctime"><code>Date#ctime</code></a> is an alias for <a href="Date.html#method-i-asctime"><code>Date#asctime</code></a>.</p>

          <div class="method-source-code" id="asctime-source">
            <pre>static VALUE
d_lite_asctime(VALUE self)
{
    return strftimev(&quot;%a %b %e %H:%M:%S %Y&quot;, self, set_tmx);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Date.html#method-i-ctime">ctime</a>
        </div>

      </div>

      <div id="method-i-ctime" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">ctime</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-strftime"><code>strftime</code></a> with argument <code>&#39;%a %b %e %T %Y&#39;</code> (or its <a href="strftime_formatting_rdoc.html#label-Shorthand+Conversion+Specifiers">shorthand form</a> <code>&#39;%c&#39;</code>):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">asctime</span> <span class="ruby-comment"># =&gt; &quot;Sat Feb  3 00:00:00 2001&quot;</span>
</pre>

<p>See <a href="https://linux.die.net/man/3/asctime">asctime</a>.</p>

<p><a href="Date.html#method-i-ctime"><code>Date#ctime</code></a> is an alias for <a href="Date.html#method-i-asctime"><code>Date#asctime</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Date.html#method-i-asctime">asctime</a>
        </div>
      </div>

      <div id="method-i-cwday" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              cwday &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the commercial-date weekday index for <code>self</code> (see <a href="Date.html#method-c-commercial"><code>Date.commercial</code></a>); 1 is Monday:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">cwday</span> <span class="ruby-comment"># =&gt; 6</span>
</pre>

          <div class="method-source-code" id="cwday-source">
            <pre>static VALUE
d_lite_cwday(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_cwday(dat));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-cweek" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              cweek &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns commercial-date week index for <code>self</code> (see <a href="Date.html#method-c-commercial"><code>Date.commercial</code></a>):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">cweek</span> <span class="ruby-comment"># =&gt; 5</span>
</pre>

          <div class="method-source-code" id="cweek-source">
            <pre>static VALUE
d_lite_cweek(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_cweek(dat));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-cwyear" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              cwyear &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns commercial-date year for <code>self</code> (see <a href="Date.html#method-c-commercial"><code>Date.commercial</code></a>):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">cwyear</span> <span class="ruby-comment"># =&gt; 2001</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2000</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>).<span class="ruby-identifier">cwyear</span> <span class="ruby-comment"># =&gt; 1999</span>
</pre>

          <div class="method-source-code" id="cwyear-source">
            <pre>static VALUE
d_lite_cwyear(VALUE self)
{
    get_d1(self);
    return m_real_cwyear(dat);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-day" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">day</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the day of the month in range (1..31):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">mday</span> <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p><a href="Date.html#method-i-day"><code>Date#day</code></a> is an alias for <a href="Date.html#method-i-mday"><code>Date#mday</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Date.html#method-i-mday">mday</a>
        </div>
      </div>

      <div id="method-i-day_fraction" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              day_fraction &rarr; rational
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the fractional part of the day in range (Rational(0, 1)…Rational(1, 1)):</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">12</span>).<span class="ruby-identifier">day_fraction</span> <span class="ruby-comment"># =&gt; (1/2)</span>
</pre>

          <div class="method-source-code" id="day_fraction-source">
            <pre>static VALUE
d_lite_day_fraction(VALUE self)
{
    get_d1(self);
    if (simple_dat_p(dat))
        return INT2FIX(0);
    return m_fr(dat);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-deconstruct_keys" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              deconstruct_keys(array_of_names_or_nil) &rarr; hash
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a hash of the name/value pairs, to use in pattern matching. Possible keys are: <code>:year</code>, <code>:month</code>, <code>:day</code>, <code>:wday</code>, <code>:yday</code>.</p>

<p>Possible usages:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2022</span>, <span class="ruby-value">10</span>, <span class="ruby-value">5</span>)

<span class="ruby-keyword">if</span> <span class="ruby-identifier">d</span> <span class="ruby-keyword">in</span> <span class="ruby-value">wday:</span> <span class="ruby-value">3</span>, <span class="ruby-value">day:</span> <span class="ruby-operator">..</span><span class="ruby-value">7</span>  <span class="ruby-comment"># uses deconstruct_keys underneath</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;first Wednesday of the month&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-comment">#=&gt; prints &quot;first Wednesday of the month&quot;</span>

<span class="ruby-keyword">case</span> <span class="ruby-identifier">d</span>
<span class="ruby-keyword">in</span> <span class="ruby-value">year:</span> <span class="ruby-operator">...</span><span class="ruby-value">2022</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;too old&quot;</span>
<span class="ruby-keyword">in</span> <span class="ruby-value">month:</span> <span class="ruby-operator">..</span><span class="ruby-value">9</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;quarter 1-3&quot;</span>
<span class="ruby-keyword">in</span> <span class="ruby-value">wday:</span> <span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>, <span class="ruby-value">month:</span>
  <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;working day in month #{month}&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-comment">#=&gt; prints &quot;working day in month 10&quot;</span>
</pre>

<p>Note that deconstruction by pattern can also be combined with class check:</p>

<pre class="ruby"><span class="ruby-keyword">if</span> <span class="ruby-identifier">d</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">Date</span>(<span class="ruby-value">wday:</span> <span class="ruby-value">3</span>, <span class="ruby-value">day:</span> <span class="ruby-operator">..</span><span class="ruby-value">7</span>)
  <span class="ruby-identifier">puts</span> <span class="ruby-string">&quot;first Wednesday of the month&quot;</span>
<span class="ruby-keyword">end</span>
</pre>

          <div class="method-source-code" id="deconstruct_keys-source">
            <pre>static VALUE
d_lite_deconstruct_keys(VALUE self, VALUE keys)
{
    return deconstruct_keys(self, keys, /* is_datetime=false */ 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-downto" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              downto(min){|date| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-step"><code>step</code></a> with arguments <code>min</code> and <code>-1</code>.</p>

          <div class="method-source-code" id="downto-source">
            <pre>static VALUE
d_lite_downto(VALUE self, VALUE min)
{
    VALUE date;

    RETURN_ENUMERATOR(self, 1, &amp;min);

    date = self;
    while (FIX2INT(d_lite_cmp(date, min)) &gt;= 0) {
        rb_yield(date);
        date = d_lite_plus(date, INT2FIX(-1));
    }
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-england" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              england &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="Date.html#ENGLAND"><code>Date::ENGLAND</code></a>.</p>

          <div class="method-source-code" id="england-source">
            <pre>static VALUE
d_lite_england(VALUE self)
{
    return dup_obj_with_new_start(self, ENGLAND);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-friday-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              friday? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is a Friday, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="friday-3F-source">
            <pre>static VALUE
d_lite_friday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 5);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-gregorian" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              gregorian &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="Date.html#GREGORIAN"><code>Date::GREGORIAN</code></a>.</p>

          <div class="method-source-code" id="gregorian-source">
            <pre>static VALUE
d_lite_gregorian(VALUE self)
{
    return dup_obj_with_new_start(self, GREGORIAN);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-gregorian-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              gregorian? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the date is on or after the date of calendar reform, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1582</span>, <span class="ruby-value">10</span>, <span class="ruby-value">15</span>).<span class="ruby-identifier">gregorian?</span>       <span class="ruby-comment"># =&gt; true</span>
(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1582</span>, <span class="ruby-value">10</span>, <span class="ruby-value">15</span>) <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">gregorian?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="gregorian-3F-source">
            <pre>static VALUE
d_lite_gregorian_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_gregorian_p(dat));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-httpdate" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              httpdate &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-strftime"><code>strftime</code></a> with argument <code>&#39;%a, %d %b %Y %T GMT&#39;</code>; see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">httpdate</span> <span class="ruby-comment"># =&gt; &quot;Sat, 03 Feb 2001 00:00:00 GMT&quot;</span>
</pre>

          <div class="method-source-code" id="httpdate-source">
            <pre>static VALUE
d_lite_httpdate(VALUE self)
{
    volatile VALUE dup = dup_obj_with_new_offset(self, 0);
    return strftimev(&quot;%a, %d %b %Y %T GMT&quot;, dup, set_tmx);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-infinite-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              infinite? &rarr; false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>false</code></p>

          <div class="method-source-code" id="infinite-3F-source">
            <pre><span class="ruby-comment"># File ext/date/lib/date.rb, line 13</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">infinite?</span>
  <span class="ruby-keyword">false</span>
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-inspect" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              inspect &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string representation of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">inspect</span>
<span class="ruby-comment"># =&gt; &quot;#&lt;Date: 2001-02-03 ((2451944j,0s,0n),+0s,2299161j)&gt;&quot;</span>
</pre>

          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE
d_lite_inspect(VALUE self)
{
    get_d1(self);
    return mk_inspect(dat, rb_obj_class(self), self);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-iso8601" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              iso8601    &rarr;  string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-strftime"><code>strftime</code></a> with argument <code>&#39;%Y-%m-%d&#39;</code> (or its <a href="strftime_formatting_rdoc.html#label-Shorthand+Conversion+Specifiers">shorthand form</a> <code>&#39;%F&#39;</code>);</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">iso8601</span> <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
</pre>

<p><a href="Date.html#method-i-xmlschema"><code>Date#xmlschema</code></a> is an alias for <a href="Date.html#method-i-iso8601"><code>Date#iso8601</code></a>.</p>

          <div class="method-source-code" id="iso8601-source">
            <pre>static VALUE
d_lite_iso8601(VALUE self)
{
    return strftimev(&quot;%Y-%m-%d&quot;, self, set_tmx);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Date.html#method-i-xmlschema">xmlschema</a>
        </div>

      </div>

      <div id="method-i-italy" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              italy &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="Date.html#ITALY"><code>Date::ITALY</code></a>.</p>

          <div class="method-source-code" id="italy-source">
            <pre>static VALUE
d_lite_italy(VALUE self)
{
    return dup_obj_with_new_start(self, ITALY);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-jd" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              jd  &rarr;  integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the Julian day number.  This is a whole number, which is adjusted by the offset as the local time.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;+7&#39;</span>).<span class="ruby-identifier">jd</span>      <span class="ruby-comment">#=&gt; 2451944</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;-7&#39;</span>).<span class="ruby-identifier">jd</span>      <span class="ruby-comment">#=&gt; 2451944</span>
</pre>

          <div class="method-source-code" id="jd-source">
            <pre>static VALUE
d_lite_jd(VALUE self)
{
    get_d1(self);
    return m_real_local_jd(dat);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-jisx0301" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              jisx0301 &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string representation of the date in <code>self</code> in JIS X 0301 format.</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">jisx0301</span> <span class="ruby-comment"># =&gt; &quot;H13.02.03&quot;</span>
</pre>

          <div class="method-source-code" id="jisx0301-source">
            <pre>static VALUE
d_lite_jisx0301(VALUE self)
{
    char fmtbuf[JISX0301_DATE_SIZE];
    const char *fmt;

    get_d1(self);
    fmt = jisx0301_date_format(fmtbuf, sizeof(fmtbuf),
                               m_real_local_jd(dat),
                               m_real_year(dat));
    return strftimev(fmt, self, set_tmx);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-julian" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              julian &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-new_start"><code>Date#new_start</code></a> with argument <a href="Date.html#JULIAN"><code>Date::JULIAN</code></a>.</p>

          <div class="method-source-code" id="julian-source">
            <pre>static VALUE
d_lite_julian(VALUE self)
{
    return dup_obj_with_new_start(self, JULIAN);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-julian-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              julian? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the date is before the date of calendar reform, <code>false</code> otherwise:</p>

<pre class="ruby">(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1582</span>, <span class="ruby-value">10</span>, <span class="ruby-value">15</span>) <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">julian?</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1582</span>, <span class="ruby-value">10</span>, <span class="ruby-value">15</span>).<span class="ruby-identifier">julian?</span>       <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="julian-3F-source">
            <pre>static VALUE
d_lite_julian_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_julian_p(dat));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-ld" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              ld &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the <a href="https://en.wikipedia.org/wiki/Lilian_date">Lilian day number</a>, which is the number of days since the beginning of the Gregorian calendar, October 15, 1582.</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">ld</span> <span class="ruby-comment"># =&gt; 152784</span>
</pre>

          <div class="method-source-code" id="ld-source">
            <pre>static VALUE
d_lite_ld(VALUE self)
{
    get_d1(self);
    return f_sub(m_real_local_jd(dat), INT2FIX(2299160));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-leap-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              leap? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the year is a leap year, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2000</span>).<span class="ruby-identifier">leap?</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>).<span class="ruby-identifier">leap?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="leap-3F-source">
            <pre>static VALUE
d_lite_leap_p(VALUE self)
{
    int rjd, ns, ry, rm, rd;

    get_d1(self);
    if (m_gregorian_p(dat))
        return f_boolcast(c_gregorian_leap_p(m_year(dat)));

    c_civil_to_jd(m_year(dat), 3, 1, m_virtual_sg(dat),
                  &amp;rjd, &amp;ns);
    c_jd_to_civil(rjd - 1, m_virtual_sg(dat), &amp;ry, &amp;rm, &amp;rd);
    return f_boolcast(rd == 29);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-mday" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">mday</span><span
              class="method-args"> -&gt; integer</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the day of the month in range (1..31):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">mday</span> <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p><a href="Date.html#method-i-day"><code>Date#day</code></a> is an alias for <a href="Date.html#method-i-mday"><code>Date#mday</code></a>.</p>

          <div class="method-source-code" id="mday-source">
            <pre>static VALUE
d_lite_mday(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_mday(dat));
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Date.html#method-i-day">day</a>
        </div>

      </div>

      <div id="method-i-mjd" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              mjd  &rarr;  integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the modified Julian day number.  This is a whole number, which is adjusted by the offset as the local time.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;+7&#39;</span>).<span class="ruby-identifier">mjd</span>     <span class="ruby-comment">#=&gt; 51943</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">&#39;-7&#39;</span>).<span class="ruby-identifier">mjd</span>     <span class="ruby-comment">#=&gt; 51943</span>
</pre>

          <div class="method-source-code" id="mjd-source">
            <pre>static VALUE
d_lite_mjd(VALUE self)
{
    get_d1(self);
    return f_sub(m_real_local_jd(dat), INT2FIX(2400001));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-mon" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              mon &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the month in range (1..12):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">mon</span> <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p><a href="Date.html#method-i-month"><code>Date#month</code></a> is an alias for <a href="Date.html#method-i-mon"><code>Date#mon</code></a>.</p>

          <div class="method-source-code" id="mon-source">
            <pre>static VALUE
d_lite_mon(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_mon(dat));
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Date.html#method-i-month">month</a>
        </div>

      </div>

      <div id="method-i-monday-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              monday? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is a Monday, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="monday-3F-source">
            <pre>static VALUE
d_lite_monday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-month" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">month</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the month in range (1..12):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">mon</span> <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p><a href="Date.html#method-i-month"><code>Date#month</code></a> is an alias for <a href="Date.html#method-i-mon"><code>Date#mon</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Date.html#method-i-mon">mon</a>
        </div>
      </div>

      <div id="method-i-new_start" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              new_start(start = Date::ITALY]) &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with the given <code>start</code> value:</p>

<pre class="ruby"><span class="ruby-identifier">d0</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2000</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">d0</span>.<span class="ruby-identifier">julian?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">d1</span> = <span class="ruby-identifier">d0</span>.<span class="ruby-identifier">new_start</span>(<span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">JULIAN</span>)
<span class="ruby-identifier">d1</span>.<span class="ruby-identifier">julian?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>See argument start.</p>

          <div class="method-source-code" id="new_start-source">
            <pre>static VALUE
d_lite_new_start(int argc, VALUE *argv, VALUE self)
{
    VALUE vsg;
    double sg;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;vsg);

    sg = DEFAULT_SG;
    if (argc &gt;= 1)
        val2sg(vsg, sg);

    return dup_obj_with_new_start(self, sg);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-next" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              next &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object representing the following day:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">to_s</span>      <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">next</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-02-04&quot;</span>
</pre>

<p><a href="Date.html#method-i-succ"><code>Date#succ</code></a> is an alias for <a href="Date.html#method-i-next"><code>Date#next</code></a>.</p>

          <div class="method-source-code" id="next-source">
            <pre>static VALUE
d_lite_next(VALUE self)
{
    return d_lite_next_day(0, (VALUE *)NULL, self);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Date.html#method-i-succ">succ</a>
        </div>

      </div>

      <div id="method-i-next_day" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              next_day(n = 1) &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-2B"><code>Date#+</code></a> with argument <code>n</code>.</p>

          <div class="method-source-code" id="next_day-source">
            <pre>static VALUE
d_lite_next_day(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_plus(self, n);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-next_month" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              next_month(n = 1) &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-3E-3E"><code>&gt;&gt;</code></a> with argument <code>n</code>.</p>

          <div class="method-source-code" id="next_month-source">
            <pre>static VALUE
d_lite_next_month(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_rshift(self, n);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-next_year" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              next_year(n = 1) &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-3E-3E"><code>&gt;&gt;</code></a> with argument <code>n * 12</code>.</p>

          <div class="method-source-code" id="next_year-source">
            <pre>static VALUE
d_lite_next_year(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_rshift(self, f_mul(n, INT2FIX(12)));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-prev_day" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              prev_day(n = 1) &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-2D"><code>Date#-</code></a> with argument <code>n</code>.</p>

          <div class="method-source-code" id="prev_day-source">
            <pre>static VALUE
d_lite_prev_day(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_minus(self, n);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-prev_month" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              prev_month(n = 1) &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-3C-3C"><code>&lt;&lt;</code></a> with argument <code>n</code>.</p>

          <div class="method-source-code" id="prev_month-source">
            <pre>static VALUE
d_lite_prev_month(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_lshift(self, n);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-prev_year" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              prev_year(n = 1) &rarr; new_date
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-3C-3C"><code>&lt;&lt;</code></a> with argument <code>n * 12</code>.</p>

          <div class="method-source-code" id="prev_year-source">
            <pre>static VALUE
d_lite_prev_year(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);
    if (argc &lt; 1)
        n = INT2FIX(1);
    return d_lite_lshift(self, f_mul(n, INT2FIX(12)));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rfc2822" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rfc2822 &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-strftime"><code>strftime</code></a> with argument <code>&#39;%a, %-d %b %Y %T %z&#39;</code>; see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">rfc2822</span> <span class="ruby-comment"># =&gt; &quot;Sat, 3 Feb 2001 00:00:00 +0000&quot;</span>
</pre>

<p><a href="Date.html#method-i-rfc822"><code>Date#rfc822</code></a> is an alias for <a href="Date.html#method-i-rfc2822"><code>Date#rfc2822</code></a>.</p>

          <div class="method-source-code" id="rfc2822-source">
            <pre>static VALUE
d_lite_rfc2822(VALUE self)
{
    return strftimev(&quot;%a, %-d %b %Y %T %z&quot;, self, set_tmx);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="Date.html#method-i-rfc822">rfc822</a>, rfc822
        </div>

      </div>

      <div id="method-i-rfc3339" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rfc3339 &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-strftime"><code>strftime</code></a> with argument <code>&#39;%FT%T%:z&#39;</code>; see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">rfc3339</span> <span class="ruby-comment"># =&gt; &quot;2001-02-03T00:00:00+00:00&quot;</span>
</pre>

          <div class="method-source-code" id="rfc3339-source">
            <pre>static VALUE
d_lite_rfc3339(VALUE self)
{
    return strftimev(&quot;%Y-%m-%dT%H:%M:%S%:z&quot;, self, set_tmx);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rfc822" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">rfc822</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object with values parsed from <code>string</code>, which should be a valid <a href="strftime_formatting_rdoc.html#label-RFC+2822+Format">RFC 2822 date format</a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">rfc2822</span>   <span class="ruby-comment"># =&gt; &quot;Sat, 3 Feb 2001 00:00:00 +0000&quot;</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">rfc2822</span>(<span class="ruby-identifier">s</span>) <span class="ruby-comment"># =&gt; #&lt;Date: 2001-02-03&gt;</span>
</pre>

<p>See:</p>
<ul><li>
<p>Argument start.</p>
</li><li>
<p>Argument <a href="Date.html#class-Date-label-Argument+limit">limit</a>.</p>
</li></ul>

<p><a href="Date.html#method-c-rfc822"><code>Date.rfc822</code></a> is an alias for <a href="Date.html#method-c-rfc2822"><code>Date.rfc2822</code></a>.</p>

<p>Related: <a href="Date.html#method-c-_rfc2822"><code>Date._rfc2822</code></a> (returns a hash).</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Date.html#method-i-rfc2822">rfc2822</a>
        </div>
      </div>

      <div id="method-i-saturday-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              saturday? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is a Saturday, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="saturday-3F-source">
            <pre>static VALUE
d_lite_saturday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 6);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-start" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              start &rarr; float
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the Julian start date for calendar reform; if not an infinity, the returned value is suitable for passing to <a href="Date.html#method-i-jd"><code>Date#jd</code></a>:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ITALY</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">start</span>     <span class="ruby-comment"># =&gt; 2299161.0</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-identifier">s</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;1582-10-15&quot;</span>

<span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">ENGLAND</span>)
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">d</span>.<span class="ruby-identifier">start</span>     <span class="ruby-comment"># =&gt; 2361222.0</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-identifier">s</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;1752-09-14&quot;</span>

<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">GREGORIAN</span>).<span class="ruby-identifier">start</span> <span class="ruby-comment"># =&gt; -Infinity</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">JULIAN</span>).<span class="ruby-identifier">start</span>    <span class="ruby-comment"># =&gt; Infinity</span>
</pre>

<p>See argument start.</p>

          <div class="method-source-code" id="start-source">
            <pre>static VALUE
d_lite_start(VALUE self)
{
    get_d1(self);
    return DBL2NUM(m_sg(dat));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-step" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              step(limit, step = 1){|date| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Calls the block with specified dates; returns <code>self</code>.</p>
<ul><li>
<p>The first <code>date</code> is <code>self</code>.</p>
</li><li>
<p>Each successive <code>date</code> is <code>date + step</code>, where <code>step</code> is the numeric step size in days.</p>
</li><li>
<p>The last date is the last one that is before or equal to <code>limit</code>, which should be a Date object.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-identifier">limit</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">12</span>, <span class="ruby-value">31</span>)
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>).<span class="ruby-identifier">step</span>(<span class="ruby-identifier">limit</span>){<span class="ruby-operator">|</span><span class="ruby-identifier">date</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">date</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">date</span>.<span class="ruby-identifier">mday</span> <span class="ruby-operator">==</span> <span class="ruby-value">31</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-string">&quot;2001-01-31&quot;</span>
<span class="ruby-string">&quot;2001-03-31&quot;</span>
<span class="ruby-string">&quot;2001-05-31&quot;</span>
<span class="ruby-string">&quot;2001-07-31&quot;</span>
<span class="ruby-string">&quot;2001-08-31&quot;</span>
<span class="ruby-string">&quot;2001-10-31&quot;</span>
<span class="ruby-string">&quot;2001-12-31&quot;</span>
</pre>

<p>Returns an <a href="Enumerator.html"><code>Enumerator</code></a> if no block is given.</p>

          <div class="method-source-code" id="step-source">
            <pre>static VALUE
d_lite_step(int argc, VALUE *argv, VALUE self)
{
    VALUE limit, step, date;
    int c;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;limit, &amp;step);

    if (argc &lt; 2)
        step = INT2FIX(1);

#if 0
    if (f_zero_p(step))
        rb_raise(rb_eArgError, &quot;step can&#39;t be 0&quot;);
#endif

    RETURN_ENUMERATOR(self, argc, argv);

    date = self;
    c = f_cmp(step, INT2FIX(0));
    if (c &lt; 0) {
        while (FIX2INT(d_lite_cmp(date, limit)) &gt;= 0) {
            rb_yield(date);
            date = d_lite_plus(date, step);
        }
    }
    else if (c == 0) {
        while (1)
            rb_yield(date);
    }
    else /* if (c &gt; 0) */ {
        while (FIX2INT(d_lite_cmp(date, limit)) &lt;= 0) {
            rb_yield(date);
            date = d_lite_plus(date, step);
        }
    }
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-strftime" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              strftime(format = &#39;%F&#39;) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string representation of the date in <code>self</code>, formatted according the given <code>format</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">strftime</span> <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
</pre>

<p>For other formats, see <a href="strftime_formatting_rdoc.html">Formats for Dates and Times</a>.</p>

          <div class="method-source-code" id="strftime-source">
            <pre>static VALUE
d_lite_strftime(int argc, VALUE *argv, VALUE self)
{
    return date_strftime_internal(argc, argv, self,
                                  &quot;%Y-%m-%d&quot;, set_tmx);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-succ" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">succ</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new Date object representing the following day:</p>

<pre class="ruby"><span class="ruby-identifier">d</span> = <span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>)
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">to_s</span>      <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
<span class="ruby-identifier">d</span>.<span class="ruby-identifier">next</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-02-04&quot;</span>
</pre>

<p><a href="Date.html#method-i-succ"><code>Date#succ</code></a> is an alias for <a href="Date.html#method-i-next"><code>Date#next</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Date.html#method-i-next">next</a>
        </div>
      </div>

      <div id="method-i-sunday-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              sunday? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is a Sunday, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="sunday-3F-source">
            <pre>static VALUE
d_lite_sunday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-thursday-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              thursday? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is a Thursday, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="thursday-3F-source">
            <pre>static VALUE
d_lite_thursday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 4);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_date" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_date &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code>.</p>

          <div class="method-source-code" id="to_date-source">
            <pre>static VALUE
date_to_date(VALUE self)
{
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_datetime" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_datetime  &rarr; datetime
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a <a href="DateTime.html"><code>DateTime</code></a> whose value is the same as <code>self</code>:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">to_datetime</span> <span class="ruby-comment"># =&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00&gt;</span>
</pre>

          <div class="method-source-code" id="to_datetime-source">
            <pre>static VALUE
date_to_datetime(VALUE self)
{
    get_d1a(self);

    if (simple_dat_p(adat)) {
        VALUE new = d_lite_s_alloc_simple(cDateTime);
        {
            get_d1b(new);
            bdat-&gt;s = adat-&gt;s;
            return new;
        }
    }
    else {
        VALUE new = d_lite_s_alloc_complex(cDateTime);
        {
            get_d1b(new);
            bdat-&gt;c = adat-&gt;c;
            bdat-&gt;c.df = 0;
            RB_OBJ_WRITE(new, &amp;bdat-&gt;c.sf, INT2FIX(0));
#ifndef USE_PACK
            bdat-&gt;c.hour = 0;
            bdat-&gt;c.min = 0;
            bdat-&gt;c.sec = 0;
#else
            bdat-&gt;c.pc = PACK5(EX_MON(adat-&gt;c.pc), EX_MDAY(adat-&gt;c.pc),
                               0, 0, 0);
            bdat-&gt;c.flags |= HAVE_DF | HAVE_TIME;
#endif
            return new;
        }
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_json" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">to_json</span><span
              class="method-args">(*args)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Stores class name (<a href="Date.html"><code>Date</code></a>) with Julian year <code>y</code>, month <code>m</code>, day <code>d</code> and Day of Calendar Reform <code>sg</code> as <a href="JSON.html"><code>JSON</code></a> string</p>

          <div class="method-source-code" id="to_json-source">
            <pre><span class="ruby-comment"># File ext/json/lib/json/add/date.rb, line 31</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_json</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
  <span class="ruby-identifier">as_json</span>.<span class="ruby-identifier">to_json</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">args</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_s" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_s &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string representation of the date in <code>self</code> in <a href="strftime_formatting_rdoc.html#label-ISO+8601+Format+Specifications">ISO 8601 extended date format</a> (<code>&#39;%Y-%m-%d&#39;</code>):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
</pre>

          <div class="method-source-code" id="to_s-source">
            <pre>static VALUE
d_lite_to_s(VALUE self)
{
    return strftimev(&quot;%Y-%m-%d&quot;, self, set_tmx);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_time" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_time &rarr; time
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new <a href="Time.html"><code>Time</code></a> object with the same value as <code>self</code>; if <code>self</code> is a Julian date, derives its Gregorian date for conversion to the Time object:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">to_time</span>               <span class="ruby-comment"># =&gt; 2001-02-03 00:00:00 -0600</span>
<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>, <span class="ruby-constant">Date</span><span class="ruby-operator">::</span><span class="ruby-constant">JULIAN</span>).<span class="ruby-identifier">to_time</span> <span class="ruby-comment"># =&gt; 2001-02-16 00:00:00 -0600</span>
</pre>

          <div class="method-source-code" id="to_time-source">
            <pre>static VALUE
date_to_time(VALUE self)
{
    get_d1a(self);

    if (m_julian_p(adat)) {
        VALUE tmp = d_lite_gregorian(self);
        get_d1b(tmp);
        adat = bdat;
    }

    return f_local3(rb_cTime,
        m_real_year(adat),
        INT2FIX(m_mon(adat)),
        INT2FIX(m_mday(adat)));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-tuesday-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              tuesday? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is a Tuesday, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="tuesday-3F-source">
            <pre>static VALUE
d_lite_tuesday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 2);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-upto" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              upto(max){|date| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-step"><code>step</code></a> with arguments <code>max</code> and <code>1</code>.</p>

          <div class="method-source-code" id="upto-source">
            <pre>static VALUE
d_lite_upto(VALUE self, VALUE max)
{
    VALUE date;

    RETURN_ENUMERATOR(self, 1, &amp;max);

    date = self;
    while (FIX2INT(d_lite_cmp(date, max)) &lt;= 0) {
        rb_yield(date);
        date = d_lite_plus(date, INT2FIX(1));
    }
    return self;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-wday" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              wday &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the day of week in range (0..6); Sunday is 0:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">wday</span> <span class="ruby-comment"># =&gt; 6</span>
</pre>

          <div class="method-source-code" id="wday-source">
            <pre>static VALUE
d_lite_wday(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_wday(dat));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-wednesday-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              wednesday? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is a Wednesday, <code>false</code> otherwise.</p>

          <div class="method-source-code" id="wednesday-3F-source">
            <pre>static VALUE
d_lite_wednesday_p(VALUE self)
{
    get_d1(self);
    return f_boolcast(m_wday(dat) == 3);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-xmlschema" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">xmlschema</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="Date.html#method-i-strftime"><code>strftime</code></a> with argument <code>&#39;%Y-%m-%d&#39;</code> (or its <a href="strftime_formatting_rdoc.html#label-Shorthand+Conversion+Specifiers">shorthand form</a> <code>&#39;%F&#39;</code>);</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">iso8601</span> <span class="ruby-comment"># =&gt; &quot;2001-02-03&quot;</span>
</pre>

<p><a href="Date.html#method-i-xmlschema"><code>Date#xmlschema</code></a> is an alias for <a href="Date.html#method-i-iso8601"><code>Date#iso8601</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="Date.html#method-i-iso8601">iso8601</a>
        </div>
      </div>

      <div id="method-i-yday" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              yday &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the day of the year, in range (1..366):</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">yday</span> <span class="ruby-comment"># =&gt; 34</span>
</pre>

          <div class="method-source-code" id="yday-source">
            <pre>static VALUE
d_lite_yday(VALUE self)
{
    get_d1(self);
    return INT2FIX(m_yday(dat));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-year" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              year &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the year:</p>

<pre class="ruby"><span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>, <span class="ruby-value">2</span>, <span class="ruby-value">3</span>).<span class="ruby-identifier">year</span>    <span class="ruby-comment"># =&gt; 2001</span>
(<span class="ruby-constant">Date</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">1</span>, <span class="ruby-value">1</span>, <span class="ruby-value">1</span>) <span class="ruby-operator">-</span> <span class="ruby-value">1</span>).<span class="ruby-identifier">year</span> <span class="ruby-comment"># =&gt; 0</span>
</pre>

          <div class="method-source-code" id="year-source">
            <pre>static VALUE
d_lite_year(VALUE self)
{
    get_d1(self);
    return m_real_year(dat);
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.5.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

