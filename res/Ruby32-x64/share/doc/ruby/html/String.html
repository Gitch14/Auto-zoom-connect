<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class String - Documentation for Ruby 3.2</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>



  <ul class="link-list" role="directory">
              <li>      <a href="#class-String-label-Substitution+Methods">Substitution Methods</a>
          <li>      <a href="#class-String-label-Whitespace+in+Strings">Whitespace in Strings</a>
          <li>      <a href="#class-String-label-String+Slices">String Slices</a>
          <li>
            <details open>
              <summary>      <a href="#class-String-label-What-27s+Here">What’s Here</a>
</summary>
              <ul class="link-list" role="directory">
                          <li>      <a href="#class-String-label-Methods+for+Creating+a+String">Methods for Creating a String</a>
          <li>      <a href="#class-String-label-Methods+for+a+Frozen-2FUnfrozen+String">Methods for a Frozen/Unfrozen String</a>
          <li>      <a href="#class-String-label-Methods+for+Querying">Methods for Querying</a>
          <li>      <a href="#class-String-label-Methods+for+Comparing">Methods for Comparing</a>
          <li>      <a href="#class-String-label-Methods+for+Modifying+a+String">Methods for Modifying a String</a>
          <li>      <a href="#class-String-label-Methods+for+Converting+to+New+String">Methods for Converting to New String</a>
          <li>      <a href="#class-String-label-Methods+for+Converting+to+Non--5CString">Methods for Converting to Non-String</a>
          <li>      <a href="#class-String-label-Methods+for+Iterating">Methods for Iterating</a>

              </ul>
            </details>
          </li>

  </ul>
</div>


  <div id="class-metadata">
    
    
<div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  <p class="link"><a href="Object.html">Object</a>
</div>

    
<div id="includes-section" class="nav-section">
  <h3>Included Modules</h3>

  <ul class="link-list">
    <li><a class="include" href="Comparable.html">Comparable</a>
  </ul>
</div>

    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-c-new">::new</a>
    <li ><a href="#method-c-try_convert">::try_convert</a>
    <li ><a href="#method-i-25">#%</a>
    <li ><a href="#method-i-2A">#*</a>
    <li ><a href="#method-i-2B">#+</a>
    <li ><a href="#method-i-2B-40">#+@</a>
    <li ><a href="#method-i-2D-40">#-@</a>
    <li ><a href="#method-i-3C-3C">#&lt;&lt;</a>
    <li ><a href="#method-i-3C-3D-3E">#&lt;=&gt;</a>
    <li ><a href="#method-i-3D-3D">#==</a>
    <li ><a href="#method-i-3D-3D-3D">#===</a>
    <li ><a href="#method-i-3D~">#=~</a>
    <li ><a href="#method-i-5B-5D">#[]</a>
    <li ><a href="#method-i-5B-5D-3D">#[]=</a>
    <li ><a href="#method-i-ascii_only-3F">#ascii_only?</a>
    <li ><a href="#method-i-b">#b</a>
    <li ><a href="#method-i-byteindex">#byteindex</a>
    <li ><a href="#method-i-byterindex">#byterindex</a>
    <li ><a href="#method-i-bytes">#bytes</a>
    <li ><a href="#method-i-bytesize">#bytesize</a>
    <li ><a href="#method-i-byteslice">#byteslice</a>
    <li ><a href="#method-i-bytesplice">#bytesplice</a>
    <li ><a href="#method-i-capitalize">#capitalize</a>
    <li ><a href="#method-i-capitalize-21">#capitalize!</a>
    <li ><a href="#method-i-casecmp">#casecmp</a>
    <li ><a href="#method-i-casecmp-3F">#casecmp?</a>
    <li ><a href="#method-i-center">#center</a>
    <li ><a href="#method-i-chars">#chars</a>
    <li ><a href="#method-i-chomp">#chomp</a>
    <li ><a href="#method-i-chomp-21">#chomp!</a>
    <li ><a href="#method-i-chop">#chop</a>
    <li ><a href="#method-i-chop-21">#chop!</a>
    <li ><a href="#method-i-chr">#chr</a>
    <li ><a href="#method-i-clear">#clear</a>
    <li ><a href="#method-i-codepoints">#codepoints</a>
    <li ><a href="#method-i-concat">#concat</a>
    <li ><a href="#method-i-count">#count</a>
    <li ><a href="#method-i-crypt">#crypt</a>
    <li ><a href="#method-i-dedup">#dedup</a>
    <li ><a href="#method-i-delete">#delete</a>
    <li ><a href="#method-i-delete-21">#delete!</a>
    <li ><a href="#method-i-delete_prefix">#delete_prefix</a>
    <li ><a href="#method-i-delete_prefix-21">#delete_prefix!</a>
    <li ><a href="#method-i-delete_suffix">#delete_suffix</a>
    <li ><a href="#method-i-delete_suffix-21">#delete_suffix!</a>
    <li ><a href="#method-i-downcase">#downcase</a>
    <li ><a href="#method-i-downcase-21">#downcase!</a>
    <li ><a href="#method-i-dump">#dump</a>
    <li ><a href="#method-i-each_byte">#each_byte</a>
    <li ><a href="#method-i-each_char">#each_char</a>
    <li ><a href="#method-i-each_codepoint">#each_codepoint</a>
    <li ><a href="#method-i-each_grapheme_cluster">#each_grapheme_cluster</a>
    <li ><a href="#method-i-each_line">#each_line</a>
    <li ><a href="#method-i-empty-3F">#empty?</a>
    <li ><a href="#method-i-encode">#encode</a>
    <li ><a href="#method-i-encode-21">#encode!</a>
    <li ><a href="#method-i-encoding">#encoding</a>
    <li ><a href="#method-i-end_with-3F">#end_with?</a>
    <li ><a href="#method-i-eql-3F">#eql?</a>
    <li ><a href="#method-i-force_encoding">#force_encoding</a>
    <li ><a href="#method-i-freeze">#freeze</a>
    <li ><a href="#method-i-getbyte">#getbyte</a>
    <li ><a href="#method-i-grapheme_clusters">#grapheme_clusters</a>
    <li ><a href="#method-i-gsub">#gsub</a>
    <li ><a href="#method-i-gsub-21">#gsub!</a>
    <li ><a href="#method-i-hash">#hash</a>
    <li ><a href="#method-i-hex">#hex</a>
    <li ><a href="#method-i-include-3F">#include?</a>
    <li ><a href="#method-i-index">#index</a>
    <li ><a href="#method-i-initialize_copy">#initialize_copy</a>
    <li ><a href="#method-i-insert">#insert</a>
    <li ><a href="#method-i-inspect">#inspect</a>
    <li ><a href="#method-i-intern">#intern</a>
    <li ><a href="#method-i-iseuc">#iseuc</a>
    <li ><a href="#method-i-isjis">#isjis</a>
    <li ><a href="#method-i-issjis">#issjis</a>
    <li ><a href="#method-i-isutf8">#isutf8</a>
    <li ><a href="#method-i-kconv">#kconv</a>
    <li ><a href="#method-i-length">#length</a>
    <li ><a href="#method-i-lines">#lines</a>
    <li ><a href="#method-i-ljust">#ljust</a>
    <li ><a href="#method-i-lstrip">#lstrip</a>
    <li ><a href="#method-i-lstrip-21">#lstrip!</a>
    <li ><a href="#method-i-match">#match</a>
    <li ><a href="#method-i-match-3F">#match?</a>
    <li ><a href="#method-i-next">#next</a>
    <li ><a href="#method-i-next-21">#next!</a>
    <li ><a href="#method-i-oct">#oct</a>
    <li ><a href="#method-i-ord">#ord</a>
    <li ><a href="#method-i-partition">#partition</a>
    <li ><a href="#method-i-prepend">#prepend</a>
    <li ><a href="#method-i-replace">#replace</a>
    <li ><a href="#method-i-reverse">#reverse</a>
    <li ><a href="#method-i-reverse-21">#reverse!</a>
    <li ><a href="#method-i-rindex">#rindex</a>
    <li ><a href="#method-i-rjust">#rjust</a>
    <li ><a href="#method-i-rpartition">#rpartition</a>
    <li ><a href="#method-i-rstrip">#rstrip</a>
    <li ><a href="#method-i-rstrip-21">#rstrip!</a>
    <li ><a href="#method-i-scan">#scan</a>
    <li ><a href="#method-i-scrub">#scrub</a>
    <li ><a href="#method-i-scrub-21">#scrub!</a>
    <li ><a href="#method-i-setbyte">#setbyte</a>
    <li ><a href="#method-i-shellescape">#shellescape</a>
    <li ><a href="#method-i-shellsplit">#shellsplit</a>
    <li ><a href="#method-i-size">#size</a>
    <li ><a href="#method-i-slice">#slice</a>
    <li ><a href="#method-i-slice-21">#slice!</a>
    <li ><a href="#method-i-split">#split</a>
    <li ><a href="#method-i-squeeze">#squeeze</a>
    <li ><a href="#method-i-squeeze-21">#squeeze!</a>
    <li ><a href="#method-i-start_with-3F">#start_with?</a>
    <li ><a href="#method-i-strip">#strip</a>
    <li ><a href="#method-i-strip-21">#strip!</a>
    <li ><a href="#method-i-sub">#sub</a>
    <li ><a href="#method-i-sub-21">#sub!</a>
    <li ><a href="#method-i-succ">#succ</a>
    <li ><a href="#method-i-succ-21">#succ!</a>
    <li ><a href="#method-i-sum">#sum</a>
    <li ><a href="#method-i-swapcase">#swapcase</a>
    <li ><a href="#method-i-swapcase-21">#swapcase!</a>
    <li ><a href="#method-i-to_c">#to_c</a>
    <li ><a href="#method-i-to_d">#to_d</a>
    <li ><a href="#method-i-to_f">#to_f</a>
    <li ><a href="#method-i-to_i">#to_i</a>
    <li ><a href="#method-i-to_r">#to_r</a>
    <li ><a href="#method-i-to_s">#to_s</a>
    <li ><a href="#method-i-to_str">#to_str</a>
    <li ><a href="#method-i-to_sym">#to_sym</a>
    <li ><a href="#method-i-toeuc">#toeuc</a>
    <li ><a href="#method-i-tojis">#tojis</a>
    <li ><a href="#method-i-tolocale">#tolocale</a>
    <li ><a href="#method-i-tosjis">#tosjis</a>
    <li ><a href="#method-i-toutf16">#toutf16</a>
    <li ><a href="#method-i-toutf32">#toutf32</a>
    <li ><a href="#method-i-toutf8">#toutf8</a>
    <li ><a href="#method-i-tr">#tr</a>
    <li ><a href="#method-i-tr-21">#tr!</a>
    <li ><a href="#method-i-tr_s">#tr_s</a>
    <li ><a href="#method-i-tr_s-21">#tr_s!</a>
    <li ><a href="#method-i-undump">#undump</a>
    <li ><a href="#method-i-unicode_normalize">#unicode_normalize</a>
    <li ><a href="#method-i-unicode_normalize-21">#unicode_normalize!</a>
    <li ><a href="#method-i-unicode_normalized-3F">#unicode_normalized?</a>
    <li ><a href="#method-i-unpack">#unpack</a>
    <li ><a href="#method-i-unpack1">#unpack1</a>
    <li ><a href="#method-i-upcase">#upcase</a>
    <li ><a href="#method-i-upcase-21">#upcase!</a>
    <li ><a href="#method-i-upto">#upto</a>
    <li ><a href="#method-i-valid_encoding-3F">#valid_encoding?</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-String">
  <h1 id="class-String" class="class">
    class String
  </h1>

  <section class="description">
    
<p>A String object has an arbitrary sequence of bytes, typically representing text or binary data. A String object may be created using <a href="String.html#method-c-new"><code>String::new</code></a> or as literals.</p>

<p><a href="String.html"><code>String</code></a> objects differ from <a href="Symbol.html"><code>Symbol</code></a> objects in that <a href="Symbol.html"><code>Symbol</code></a> objects are designed to be used as identifiers, instead of text or data.</p>

<p>You can create a String object explicitly with:</p>
<ul><li>
<p>A <a href="syntax/literals_rdoc.html#label-String+Literals">string literal</a>.</p>
</li><li>
<p>A <a href="syntax/literals_rdoc.html#label-Here+Document+Literals">heredoc literal</a>.</p>
</li></ul>

<p>You can convert certain objects to Strings with:</p>
<ul><li>
<p>Method <a href="Kernel.html#method-i-String"><code>String</code></a>.</p>
</li></ul>

<p>Some String methods modify <code>self</code>. Typically, a method whose name ends with <code>!</code> modifies <code>self</code> and returns <code>self</code>; often a similarly named method (without the <code>!</code>) returns a new string.</p>

<p>In general, if there exist both bang and non-bang version of method, the bang! mutates and the non-bang! does not. However, a method without a bang can also mutate, such as <a href="String.html#method-i-replace"><code>String#replace</code></a>.</p>

<h2 id="class-String-label-Substitution+Methods">Substitution Methods<span><a href="#class-String-label-Substitution+Methods">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>These methods perform substitutions:</p>
<ul><li>
<p><a href="String.html#method-i-sub"><code>String#sub</code></a>: One substitution (or none); returns a new string.</p>
</li><li>
<p><a href="String.html#method-i-sub-21"><code>String#sub!</code></a>: One substitution (or none); returns <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-gsub"><code>String#gsub</code></a>: Zero or more substitutions; returns a new string.</p>
</li><li>
<p><a href="String.html#method-i-gsub-21"><code>String#gsub!</code></a>: Zero or more substitutions; returns <code>self</code>.</p>
</li></ul>

<p>Each of these methods takes:</p>
<ul><li>
<p>A first argument, <code>pattern</code> (string or regexp), that specifies the substring(s) to be replaced.</p>
</li><li>
<p>Either of these:</p>
<ul><li>
<p>A second argument, <code>replacement</code> (string or hash), that determines the replacing string.</p>
</li><li>
<p>A block that will determine the replacing string.</p>
</li></ul>
</li></ul>

<p>The examples in this section mostly use methods <a href="String.html#method-i-sub"><code>String#sub</code></a> and <a href="String.html#method-i-gsub"><code>String#gsub</code></a>; the principles illustrated apply to all four substitution methods.</p>

<p><strong>Argument <code>pattern</code></strong></p>

<p>Argument <code>pattern</code> is commonly a regular expression:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;hello&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/[aeiou]/</span>, <span class="ruby-string">&#39;*&#39;</span>)<span class="ruby-comment"># =&gt; &quot;h*llo&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/[aeiou]/</span>, <span class="ruby-string">&#39;*&#39;</span>) <span class="ruby-comment"># =&gt; &quot;h*ll*&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/[aeiou]/</span>, <span class="ruby-string">&#39;&#39;</span>)<span class="ruby-comment"># =&gt; &quot;hll&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-regexp">/ell/</span>, <span class="ruby-string">&#39;al&#39;</span>)   <span class="ruby-comment"># =&gt; &quot;halo&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/xyzzy/</span>, <span class="ruby-string">&#39;*&#39;</span>) <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
<span class="ruby-string">&#39;THX1138&#39;</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/\d+/</span>, <span class="ruby-string">&#39;00&#39;</span>) <span class="ruby-comment"># =&gt; &quot;THX00&quot;</span>
</pre>

<p>When <code>pattern</code> is a string, all its characters are treated as ordinary characters (not as regexp special characters):</p>

<pre class="ruby"><span class="ruby-string">&#39;THX1138&#39;</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-string">&#39;\d+&#39;</span>, <span class="ruby-string">&#39;00&#39;</span>) <span class="ruby-comment"># =&gt; &quot;THX1138&quot;</span>
</pre>

<p><strong>String <code>replacement</code></strong></p>

<p>If <code>replacement</code> is a string, that string will determine the replacing string that is to be substituted for the matched text.</p>

<p>Each of the examples above uses a simple string as the replacing string.</p>

<p>String <code>replacement</code> may contain back-references to the pattern’s captures:</p>
<ul><li>
<p><code>\n</code> (<em>n</em> a non-negative integer) refers to <code>$n</code>.</p>
</li><li>
<p><code>\k&lt;name&gt;</code> refers to the named capture <code>name</code>.</p>
</li></ul>

<p>See <a href="regexp_rdoc.html">regexp.rdoc</a> for details.</p>

<p>Note that within the string <code>replacement</code>, a character combination such as <code>$&amp;</code> is treated as ordinary text, and not as a special match variable. However, you may refer to some special match variables using these combinations:</p>
<ul><li>
<p><code>\&amp;</code> and <code>\0</code> correspond to <code>$&amp;</code>, which contains the complete matched text.</p>
</li><li>
<p><code>\&#39;</code> corresponds to <code>$&#39;</code>, which contains string after match.</p>
</li><li>
<p><code>\`</code> corresponds to <code>$`</code>, which contains string before match.</p>
</li><li>
<p><code>+</code> corresponds to <code>$+</code>, which contains last capture group.</p>
</li></ul>

<p>See <a href="regexp_rdoc.html">regexp.rdoc</a> for details.</p>

<p>Note that <code>\\</code> is interpreted as an escape, i.e., a single backslash.</p>

<p>Note also that a string literal consumes backslashes. See <a href="syntax/literals_rdoc.html#label-String+Literals">String Literals</a> for details about string literals.</p>

<p>A back-reference is typically preceded by an additional backslash. For example, if you want to write a back-reference <code>\&amp;</code> in <code>replacement</code> with a double-quoted string literal, you need to write <code>&quot;..\\&amp;..&quot;</code>.</p>

<p>If you want to write a non-back-reference string <code>\&amp;</code> in <code>replacement</code>, you need first to escape the backslash to prevent this method from interpreting it as a back-reference, and then you need to escape the backslashes again to prevent a string literal from consuming them: <code>&quot;..\\\\&amp;..&quot;</code>.</p>

<p>You may want to use the block form to avoid a lot of backslashes.</p>

<p><strong>Hash <code>replacement</code></strong></p>

<p>If argument <code>replacement</code> is a hash, and <code>pattern</code> matches one of its keys, the replacing string is the value for that key:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;baz&#39;</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&#39;bat&#39;</span>}
<span class="ruby-string">&#39;food&#39;</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-identifier">h</span>) <span class="ruby-comment"># =&gt; &quot;bard&quot;</span>
</pre>

<p>Note that a symbol key does not match:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> = {<span class="ruby-value">foo:</span> <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">baz:</span> <span class="ruby-string">&#39;bat&#39;</span>}
<span class="ruby-string">&#39;food&#39;</span>.<span class="ruby-identifier">sub</span>(<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-identifier">h</span>) <span class="ruby-comment"># =&gt; &quot;d&quot;</span>
</pre>

<p><strong>Block</strong></p>

<p>In the block form, the current match string is passed to the block; the block’s return value becomes the replacing string:</p>

<pre class="ruby"> <span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;@&#39;</span>
<span class="ruby-string">&#39;1234&#39;</span>.<span class="ruby-identifier">gsub</span>(<span class="ruby-regexp">/\d/</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">match</span><span class="ruby-operator">|</span> <span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ!</span> } <span class="ruby-comment"># =&gt; &quot;ABCD&quot;</span>
</pre>

<p>Special match variables such as <code>$1</code>, <code>$2</code>, <code>$`</code>, <code>$&amp;</code>, and <code>$&#39;</code> are set appropriately.</p>

<h2 id="class-String-label-Whitespace+in+Strings">Whitespace in Strings<span><a href="#class-String-label-Whitespace+in+Strings">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>In class String, <em>whitespace</em> is defined as a contiguous sequence of characters consisting of any mixture of the following:</p>
<ul><li>
<p>NL (null): <code>&quot;\x00&quot;</code>, <code>&quot;\u0000&quot;</code>.</p>
</li><li>
<p>HT (horizontal tab): <code>&quot;\x09&quot;</code>, <code>&quot;\t&quot;</code>.</p>
</li><li>
<p>LF (line feed): <code>&quot;\x0a&quot;</code>, <code>&quot;\n&quot;</code>.</p>
</li><li>
<p>VT (vertical tab): <code>&quot;\x0b&quot;</code>, <code>&quot;\v&quot;</code>.</p>
</li><li>
<p>FF (form feed): <code>&quot;\x0c&quot;</code>, <code>&quot;\f&quot;</code>.</p>
</li><li>
<p>CR (carriage return): <code>&quot;\x0d&quot;</code>, <code>&quot;\r&quot;</code>.</p>
</li><li>
<p>SP (space): <code>&quot;\x20&quot;</code>, <code>&quot; &quot;</code>.</p>
</li></ul>

<p>Whitespace is relevant for these methods:</p>
<ul><li>
<p><a href="String.html#method-i-lstrip"><code>lstrip</code></a>, <a href="String.html#method-i-lstrip-21"><code>lstrip!</code></a>: strip leading whitespace.</p>
</li><li>
<p><a href="String.html#method-i-rstrip"><code>rstrip</code></a>, <a href="String.html#method-i-rstrip-21"><code>rstrip!</code></a>: strip trailing whitespace.</p>
</li><li>
<p><a href="String.html#method-i-strip"><code>strip</code></a>, <a href="String.html#method-i-strip-21"><code>strip!</code></a>: strip leading and trailing whitespace.</p>
</li></ul>

<h2 id="class-String-label-String+Slices">String Slices<span><a href="#class-String-label-String+Slices">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>A <em>slice</em> of a string is a substring that is selected by certain criteria.</p>

<p>These instance methods make use of slicing:</p>
<ul><li>
<p><a href="String.html#method-i-5B-5D"><code>String#[]</code></a> (also aliased as <a href="String.html#method-i-slice"><code>String#slice</code></a>) returns a slice copied from <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-5B-5D-3D"><code>String#[]=</code></a> returns a copy of <code>self</code> with a slice replaced.</p>
</li><li>
<p><a href="String.html#method-i-slice-21"><code>String#slice!</code></a> returns <code>self</code> with a slice removed.</p>
</li></ul>

<p>Each of the above methods takes arguments that determine the slice to be copied or replaced.</p>

<p>The arguments have several forms. For string <code>string</code>,  the forms are:</p>
<ul><li>
<p><code>string[index]</code>.</p>
</li><li>
<p><code>string[start, length]</code>.</p>
</li><li>
<p><code>string[range]</code>.</p>
</li><li>
<p><code>string[regexp, capture = 0]</code>.</p>
</li><li>
<p><code>string[substring]</code>.</p>
</li></ul>

<p><strong><code>string[index]</code></strong></p>

<p>When non-negative integer argument <code>index</code> is given, the slice is the 1-character substring found in <code>self</code> at character offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;bar&#39;</span>[<span class="ruby-value">0</span>]       <span class="ruby-comment"># =&gt; &quot;b&quot;</span>
<span class="ruby-string">&#39;bar&#39;</span>[<span class="ruby-value">2</span>]       <span class="ruby-comment"># =&gt; &quot;r&quot;</span>
<span class="ruby-string">&#39;bar&#39;</span>[<span class="ruby-value">20</span>]      <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;тест&#39;</span>[<span class="ruby-value">2</span>]      <span class="ruby-comment"># =&gt; &quot;с&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>[<span class="ruby-value">4</span>]  <span class="ruby-comment"># =&gt; &quot;は&quot;</span>
</pre>

<p>When negative integer <code>index</code> is given, the slice begins at the offset given by counting backward from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;bar&#39;</span>[<span class="ruby-value">-3</span>]         <span class="ruby-comment"># =&gt; &quot;b&quot;</span>
<span class="ruby-string">&#39;bar&#39;</span>[<span class="ruby-value">-1</span>]         <span class="ruby-comment"># =&gt; &quot;r&quot;</span>
<span class="ruby-string">&#39;bar&#39;</span>[<span class="ruby-value">-20</span>]        <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p><strong><code>string[start, length]</code></strong></p>

<p>When non-negative integer arguments <code>start</code> and <code>length</code> are given, the slice begins at character offset <code>start</code>, if it exists, and continues for <code>length</code> characters, if available:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>]       <span class="ruby-comment"># =&gt; &quot;fo&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">2</span>]      <span class="ruby-comment"># =&gt; &quot;ес&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>[<span class="ruby-value">2</span>, <span class="ruby-value">2</span>]  <span class="ruby-comment"># =&gt; &quot;にち&quot;</span>
<span class="ruby-comment"># Zero length.</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">2</span>, <span class="ruby-value">0</span>]       <span class="ruby-comment"># =&gt; &quot;&quot;</span>
<span class="ruby-comment"># Length not entirely available.</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">200</span>]     <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
<span class="ruby-comment"># Start out of range.</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">4</span>, <span class="ruby-value">2</span>]      <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Special case: if <code>start</code> is equal to the length of <code>self</code>, the slice is a new empty string:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">3</span>, <span class="ruby-value">2</span>]   <span class="ruby-comment"># =&gt; &quot;&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">3</span>, <span class="ruby-value">200</span>] <span class="ruby-comment"># =&gt; &quot;&quot;</span>
</pre>

<p>When negative <code>start</code> and non-negative <code>length</code> are given, the slice beginning is determined by counting backward from the end of <code>self</code>, and the slice continues for <code>length</code> characters, if available:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">2</span>]    <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">200</span>]  <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
<span class="ruby-comment"># Start out of range.</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-4</span>, <span class="ruby-value">2</span>]     <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>When negative <code>length</code> is given, there is no slice:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">-1</span>]  <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">-1</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p><strong><code>string[range]</code></strong></p>

<p>When <a href="Range.html"><code>Range</code></a> argument <code>range</code> is given, creates a substring of <code>string</code> using the indices in <code>range</code>. The slice is then determined as above:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">0</span><span class="ruby-operator">..</span><span class="ruby-value">1</span>]    <span class="ruby-comment"># =&gt; &quot;fo&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">0</span>, <span class="ruby-value">2</span>]    <span class="ruby-comment"># =&gt; &quot;fo&quot;</span>

<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">2</span><span class="ruby-operator">...</span><span class="ruby-value">2</span>]   <span class="ruby-comment"># =&gt; &quot;&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">2</span>, <span class="ruby-value">0</span>]    <span class="ruby-comment"># =&gt; &quot;&quot;</span>

<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">1</span><span class="ruby-operator">..</span><span class="ruby-value">200</span>]  <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">1</span>, <span class="ruby-value">200</span>]  <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>

<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">5</span>]    <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">4</span>, <span class="ruby-value">2</span>]    <span class="ruby-comment"># =&gt; nil</span>

<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-4</span><span class="ruby-operator">..</span><span class="ruby-value">-3</span>]  <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-4</span>, <span class="ruby-value">2</span>]   <span class="ruby-comment"># =&gt; nil</span>

<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>]    <span class="ruby-comment"># =&gt; &quot;&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">3</span>, <span class="ruby-value">2</span>]    <span class="ruby-comment"># =&gt; &quot;&quot;</span>

<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">-1</span>]  <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">2</span>]   <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>

<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-2</span><span class="ruby-operator">..</span><span class="ruby-value">197</span>] <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-value">-2</span>, <span class="ruby-value">200</span>] <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
</pre>

<p><strong><code>string[regexp, capture = 0]</code></strong></p>

<p>When the Regexp argument <code>regexp</code> is given, and the <code>capture</code> argument is <code>0</code>, the slice is the first matching substring found in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-regexp">/o/</span>] <span class="ruby-comment"># =&gt; &quot;o&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-regexp">/x/</span>] <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;hello there&#39;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-regexp">/[aeiou](.)\1/</span>] <span class="ruby-comment"># =&gt; &quot;ell&quot;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-regexp">/[aeiou](.)\1/</span>, <span class="ruby-value">0</span>] <span class="ruby-comment"># =&gt; &quot;ell&quot;</span>
</pre>

<p>If argument <code>capture</code> is given and not <code>0</code>, it should be either an capture group index (integer) or a capture group name (string or symbol); the slice is the specified capture (see <a href="Regexp.html#class-Regexp-label-Capturing">Capturing at <code>Regexp</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;hello there&#39;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-regexp">/[aeiou](.)\1/</span>, <span class="ruby-value">1</span>] <span class="ruby-comment"># =&gt; &quot;l&quot;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-regexp">/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/</span>, <span class="ruby-string">&quot;non_vowel&quot;</span>] <span class="ruby-comment"># =&gt; &quot;l&quot;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-regexp">/(?&lt;vowel&gt;[aeiou])(?&lt;non_vowel&gt;[^aeiou])/</span>, <span class="ruby-value">:vowel</span>] <span class="ruby-comment"># =&gt; &quot;e&quot;</span>
</pre>

<p>If an invalid capture group index is given, there is no slice. If an invalid capture group name is given, <code>IndexError</code> is raised.</p>

<p><strong><code>string[substring]</code></strong></p>

<p>When the single String argument <code>substring</code> is given, returns the substring from <code>self</code> if found, otherwise <code>nil</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-string">&#39;oo&#39;</span>] <span class="ruby-comment"># =&gt; &quot;oo&quot;</span>
<span class="ruby-string">&#39;foo&#39;</span>[<span class="ruby-string">&#39;xx&#39;</span>] <span class="ruby-comment"># =&gt; nil</span>
</pre>

<h2 id="class-String-label-What-27s+Here">What’s Here<span><a href="#class-String-label-What-27s+Here">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>First, what’s elsewhere. Class String:</p>
<ul><li>
<p>Inherits from <a href="Object.html#class-Object-label-What-27s+Here">class Object</a>.</p>
</li><li>
<p>Includes <a href="Comparable.html#module-Comparable-label-What-27s+Here">module Comparable</a>.</p>
</li></ul>

<p>Here, class String provides methods that are useful for:</p>
<ul><li>
<p><a href="String.html#class-String-label-Methods+for+Creating+a+String">Creating a String</a></p>
</li><li>
<p><a href="String.html#class-String-label-Methods+for+a+Frozen-2FUnfrozen+String">Frozen/Unfrozen Strings</a></p>
</li><li>
<p><a href="String.html#class-String-label-Methods+for+Querying">Querying</a></p>
</li><li>
<p><a href="String.html#class-String-label-Methods+for+Comparing">Comparing</a></p>
</li><li>
<p><a href="String.html#class-String-label-Methods+for+Modifying+a+String">Modifying a String</a></p>
</li><li>
<p><a href="String.html#class-String-label-Methods+for+Converting+to+New+String">Converting to New String</a></p>
</li><li>
<p><a href="String.html#class-String-label-Methods+for+Converting+to+Non--5CString">Converting to Non-String</a></p>
</li><li>
<p><a href="String.html#class-String-label-Methods+for+Iterating">Iterating</a></p>
</li></ul>

<h3 id="class-String-label-Methods+for+Creating+a+String">Methods for Creating a String<span><a href="#class-String-label-Methods+for+Creating+a+String">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="String.html#method-c-new"><code>::new</code></a>: Returns a new string.</p>
</li><li>
<p><a href="String.html#method-c-try_convert"><code>::try_convert</code></a>: Returns a new string created from a given object.</p>
</li></ul>

<h3 id="class-String-label-Methods+for+a+Frozen-2FUnfrozen+String">Methods for a Frozen/Unfrozen <a href="String.html"><code>String</code></a><span><a href="#class-String-label-Methods+for+a+Frozen-2FUnfrozen+String">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="String.html#method-i-2B-40"><code>+@</code></a>: Returns a string that is not frozen: <code>self</code>, if not frozen; <code>self.dup</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-2D-40"><code>-@</code></a>: Returns a string that is frozen: <code>self</code>, if already frozen; <code>self.freeze</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-freeze"><code>freeze</code></a>: Freezes <code>self</code>, if not already frozen; returns <code>self</code>.</p>
</li></ul>

<h3 id="class-String-label-Methods+for+Querying">Methods for Querying<span><a href="#class-String-label-Methods+for+Querying">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p><em>Counts</em></p>
<ul><li>
<p><a href="String.html#method-i-length"><code>length</code></a>, <a href="String.html#method-i-size"><code>size</code></a>: Returns the count of characters (not bytes).</p>
</li><li>
<p><a href="String.html#method-i-empty-3F"><code>empty?</code></a>: Returns <code>true</code> if <code>self.length</code> is zero; <code>false</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-bytesize"><code>bytesize</code></a>: Returns the count of bytes.</p>
</li><li>
<p><a href="String.html#method-i-count"><code>count</code></a>: Returns the count of substrings matching given strings.</p>
</li></ul>

<p><em>Substrings</em></p>
<ul><li>
<p><a href="String.html#method-i-3D~"><code>=~</code></a>: Returns the index of the first substring that matches a given <a href="Regexp.html"><code>Regexp</code></a> or other object; returns <code>nil</code> if no match is found.</p>
</li><li>
<p><a href="String.html#method-i-index"><code>index</code></a>: Returns the index of the <em>first</em> occurrence of a given substring; returns <code>nil</code> if none found.</p>
</li><li>
<p><a href="String.html#method-i-rindex"><code>rindex</code></a>: Returns the index of the <em>last</em> occurrence of a given substring; returns <code>nil</code> if none found.</p>
</li><li>
<p><a href="String.html#method-i-include-3F"><code>include?</code></a>: Returns <code>true</code> if the string contains a given substring; <code>false</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-match"><code>match</code></a>: Returns a <a href="MatchData.html"><code>MatchData</code></a> object if the string matches a given <a href="Regexp.html"><code>Regexp</code></a>; <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-match-3F"><code>match?</code></a>: Returns <code>true</code> if the string matches a given <a href="Regexp.html"><code>Regexp</code></a>; <code>false</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-start_with-3F"><code>start_with?</code></a>: Returns <code>true</code> if the string begins with any of the given substrings.</p>
</li><li>
<p><a href="String.html#method-i-end_with-3F"><code>end_with?</code></a>: Returns <code>true</code> if the string ends with any of the given substrings.</p>
</li></ul>

<p><em>Encodings</em></p>
<ul><li>
<p><a href="String.html#method-i-encoding"><code>encoding</code></a>: Returns the <a href="Encoding.html"><code>Encoding</code></a> object that represents the encoding of the string.</p>
</li><li>
<p><a href="String.html#method-i-unicode_normalized-3F"><code>unicode_normalized?</code></a>: Returns <code>true</code> if the string is in Unicode normalized form; <code>false</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-valid_encoding-3F"><code>valid_encoding?</code></a>: Returns <code>true</code> if the string contains only characters that are valid for its encoding.</p>
</li><li>
<p><a href="String.html#method-i-ascii_only-3F"><code>ascii_only?</code></a>: Returns <code>true</code> if the string has only ASCII characters; <code>false</code> otherwise.</p>
</li></ul>

<p><em>Other</em></p>
<ul><li>
<p><a href="String.html#method-i-sum"><code>sum</code></a>: Returns a basic checksum for the string: the sum of each byte.</p>
</li><li>
<p><a href="String.html#method-i-hash"><code>hash</code></a>: Returns the integer hash code.</p>
</li></ul>

<h3 id="class-String-label-Methods+for+Comparing">Methods for Comparing<span><a href="#class-String-label-Methods+for+Comparing">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="String.html#method-i-3D-3D"><code>==</code></a>, <a href="String.html#method-i-3D-3D-3D"><code>===</code></a>: Returns <code>true</code> if a given other string has the same content as <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-eql-3F"><code>eql?</code></a>: Returns <code>true</code> if the content is the same as the given other string.</p>
</li><li>
<p><a href="String.html#method-i-3C-3D-3E"><code>&lt;=&gt;</code></a>: Returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-casecmp"><code>casecmp</code></a>: Ignoring case, returns -1, 0, or 1 as a given other string is smaller than, equal to, or larger than <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-casecmp-3F"><code>casecmp?</code></a>: Returns <code>true</code> if the string is equal to a given string after Unicode case folding; <code>false</code> otherwise.</p>
</li></ul>

<h3 id="class-String-label-Methods+for+Modifying+a+String">Methods for Modifying a String<span><a href="#class-String-label-Methods+for+Modifying+a+String">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Each of these methods modifies <code>self</code>.</p>

<p><em>Insertion</em></p>
<ul><li>
<p><a href="String.html#method-i-insert"><code>insert</code></a>: Returns <code>self</code> with a given string inserted at a given offset.</p>
</li><li>
<p><a href="String.html#method-i-3C-3C"><code>&lt;&lt;</code></a>: Returns <code>self</code> concatenated with a given string or integer.</p>
</li></ul>

<p><em>Substitution</em></p>
<ul><li>
<p><a href="String.html#method-i-sub-21"><code>sub!</code></a>: Replaces the first substring that matches a given pattern with a given replacement string; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-gsub-21"><code>gsub!</code></a>: Replaces each substring that matches a given pattern with a given replacement string; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-succ-21"><code>succ!</code></a>, <a href="String.html#method-i-next-21"><code>next!</code></a>: Returns <code>self</code> modified to become its own successor.</p>
</li><li>
<p><a href="String.html#method-i-replace"><code>replace</code></a>: Returns <code>self</code> with its entire content replaced by a given string.</p>
</li><li>
<p><a href="String.html#method-i-reverse-21"><code>reverse!</code></a>: Returns <code>self</code> with its characters in reverse order.</p>
</li><li>
<p><a href="String.html#method-i-setbyte"><code>setbyte</code></a>: Sets the byte at a given integer offset to a given value; returns the argument.</p>
</li><li>
<p><a href="String.html#method-i-tr-21"><code>tr!</code></a>: Replaces specified characters in <code>self</code> with specified replacement characters; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-tr_s-21"><code>tr_s!</code></a>: Replaces specified characters in <code>self</code> with specified replacement characters, removing duplicates from the substrings that were modified; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li></ul>

<p><em>Casing</em></p>
<ul><li>
<p><a href="String.html#method-i-capitalize-21"><code>capitalize!</code></a>: Upcases the initial character and downcases all others; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-downcase-21"><code>downcase!</code></a>: Downcases all characters; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-upcase-21"><code>upcase!</code></a>: Upcases all characters; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-swapcase-21"><code>swapcase!</code></a>: Upcases each downcase character and downcases each upcase character; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li></ul>

<p><em>Encoding</em></p>
<ul><li>
<p><a href="String.html#method-i-encode-21"><code>encode!</code></a>: Returns <code>self</code> with all characters transcoded from one given encoding into another.</p>
</li><li>
<p><a href="String.html#method-i-unicode_normalize-21"><code>unicode_normalize!</code></a>: Unicode-normalizes <code>self</code>; returns <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-scrub-21"><code>scrub!</code></a>: Replaces each invalid byte with a given character; returns <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-force_encoding"><code>force_encoding</code></a>: Changes the encoding to a given encoding; returns <code>self</code>.</p>
</li></ul>

<p><em>Deletion</em></p>
<ul><li>
<p><a href="String.html#method-i-clear"><code>clear</code></a>: Removes all content, so that <code>self</code> is empty; returns <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-slice-21"><code>slice!</code></a>, <a href="String.html#method-i-5B-5D-3D"><code>[]=</code></a>: Removes a substring determined by a given index, start/length, range, regexp, or substring.</p>
</li><li>
<p><a href="String.html#method-i-squeeze-21"><code>squeeze!</code></a>: Removes contiguous duplicate characters; returns <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-delete-21"><code>delete!</code></a>: Removes characters as determined by the intersection of substring arguments.</p>
</li><li>
<p><a href="String.html#method-i-lstrip-21"><code>lstrip!</code></a>: Removes leading whitespace; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-rstrip-21"><code>rstrip!</code></a>: Removes trailing whitespace; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-strip-21"><code>strip!</code></a>: Removes leading and trailing whitespace; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-chomp-21"><code>chomp!</code></a>: Removes trailing record separator, if found; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li><li>
<p><a href="String.html#method-i-chop-21"><code>chop!</code></a>: Removes trailing newline characters if found; otherwise removes the last character; returns <code>self</code> if any changes, <code>nil</code> otherwise.</p>
</li></ul>

<h3 id="class-String-label-Methods+for+Converting+to+New+String">Methods for Converting to New String<span><a href="#class-String-label-Methods+for+Converting+to+New+String">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Each of these methods returns a new String based on <code>self</code>, often just a modified copy of <code>self</code>.</p>

<p><em>Extension</em></p>
<ul><li>
<p><a href="String.html#method-i-2A"><code>*</code></a>: Returns the concatenation of multiple copies of <code>self</code>,</p>
</li><li>
<p><a href="String.html#method-i-2B"><code>+</code></a>: Returns the concatenation of <code>self</code> and a given other string.</p>
</li><li>
<p><a href="String.html#method-i-center"><code>center</code></a>: Returns a copy of <code>self</code> centered between pad substring.</p>
</li><li>
<p><a href="String.html#method-i-concat"><code>concat</code></a>: Returns the concatenation of <code>self</code> with given other strings.</p>
</li><li>
<p><a href="String.html#method-i-prepend"><code>prepend</code></a>: Returns the concatenation of a given other string with <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-ljust"><code>ljust</code></a>: Returns a copy of <code>self</code> of a given length, right-padded with a given other string.</p>
</li><li>
<p><a href="String.html#method-i-rjust"><code>rjust</code></a>: Returns a copy of <code>self</code> of a given length, left-padded with a given other string.</p>
</li></ul>

<p><em>Encoding</em></p>
<ul><li>
<p><a href="String.html#method-i-b"><code>b</code></a>: Returns a copy of <code>self</code> with ASCII-8BIT encoding.</p>
</li><li>
<p><a href="String.html#method-i-scrub"><code>scrub</code></a>: Returns a copy of <code>self</code> with each invalid byte replaced with a given character.</p>
</li><li>
<p><a href="String.html#method-i-unicode_normalize"><code>unicode_normalize</code></a>: Returns a copy of <code>self</code> with each character Unicode-normalized.</p>
</li><li>
<p><a href="String.html#method-i-encode"><code>encode</code></a>: Returns a copy of <code>self</code> with all characters transcoded from one given encoding into another.</p>
</li></ul>

<p><em>Substitution</em></p>
<ul><li>
<p><a href="String.html#method-i-dump"><code>dump</code></a>: Returns a copy of <code>self</code> with all non-printing characters replaced by xHH notation and all special characters escaped.</p>
</li><li>
<p><a href="String.html#method-i-undump"><code>undump</code></a>: Returns a copy of <code>self</code> with all <code>\xNN</code> notation replace by <code>\uNNNN</code> notation and all escaped characters unescaped.</p>
</li><li>
<p><a href="String.html#method-i-sub"><code>sub</code></a>: Returns a copy of <code>self</code> with the first substring matching a given pattern replaced with a given replacement string;.</p>
</li><li>
<p><a href="String.html#method-i-gsub"><code>gsub</code></a>: Returns a copy of <code>self</code> with each substring that matches a given pattern replaced with a given replacement string.</p>
</li><li>
<p><a href="String.html#method-i-succ"><code>succ</code></a>, <a href="String.html#method-i-next"><code>next</code></a>: Returns the string that is the successor to <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-reverse"><code>reverse</code></a>: Returns a copy of <code>self</code> with its characters in reverse order.</p>
</li><li>
<p><a href="String.html#method-i-tr"><code>tr</code></a>: Returns a copy of <code>self</code> with specified characters replaced with specified      replacement characters.</p>
</li><li>
<p><a href="String.html#method-i-tr_s"><code>tr_s</code></a>: Returns a copy of <code>self</code> with specified characters replaced with specified replacement characters, removing duplicates from the substrings that were modified.</p>
</li><li>
<p><a href="String.html#method-i-25"><code>%</code></a>: Returns the string resulting from formatting a given object into <code>self</code></p>
</li></ul>

<p><em>Casing</em></p>
<ul><li>
<p><a href="String.html#method-i-capitalize"><code>capitalize</code></a>: Returns a copy of <code>self</code> with the first character upcased and all other characters downcased.</p>
</li><li>
<p><a href="String.html#method-i-downcase"><code>downcase</code></a>: Returns a copy of <code>self</code> with all characters downcased.</p>
</li><li>
<p><a href="String.html#method-i-upcase"><code>upcase</code></a>: Returns a copy of <code>self</code> with all characters upcased.</p>
</li><li>
<p><a href="String.html#method-i-swapcase"><code>swapcase</code></a>: Returns a copy of <code>self</code> with all upcase characters downcased and all downcase characters upcased.</p>
</li></ul>

<p><em>Deletion</em></p>
<ul><li>
<p><a href="String.html#method-i-delete"><code>delete</code></a>: Returns a copy of <code>self</code> with characters removed</p>
</li><li>
<p><a href="String.html#method-i-delete_prefix"><code>delete_prefix</code></a>: Returns a copy of <code>self</code> with a given prefix removed.</p>
</li><li>
<p><a href="String.html#method-i-delete_suffix"><code>delete_suffix</code></a>: Returns a copy of <code>self</code> with a given suffix removed.</p>
</li><li>
<p><a href="String.html#method-i-lstrip"><code>lstrip</code></a>: Returns a copy of <code>self</code> with leading whitespace removed.</p>
</li><li>
<p><a href="String.html#method-i-rstrip"><code>rstrip</code></a>: Returns a copy of <code>self</code> with trailing whitespace removed.</p>
</li><li>
<p><a href="String.html#method-i-strip"><code>strip</code></a>: Returns a copy of <code>self</code> with leading and trailing whitespace removed.</p>
</li><li>
<p><a href="String.html#method-i-chomp"><code>chomp</code></a>: Returns a copy of <code>self</code> with a trailing record separator removed, if found.</p>
</li><li>
<p><a href="String.html#method-i-chop"><code>chop</code></a>: Returns a copy of <code>self</code> with trailing newline characters or the last character removed.</p>
</li><li>
<p><a href="String.html#method-i-squeeze"><code>squeeze</code></a>: Returns a copy of <code>self</code> with contiguous duplicate characters removed.</p>
</li><li>
<p><a href="String.html#method-i-5B-5D"><code>[]</code></a>, <a href="String.html#method-i-slice"><code>slice</code></a>: Returns a substring determined by a given index, start/length, or range, or string.</p>
</li><li>
<p><a href="String.html#method-i-byteslice"><code>byteslice</code></a>: Returns a substring determined by a given index, start/length, or range.</p>
</li><li>
<p><a href="String.html#method-i-chr"><code>chr</code></a>: Returns the first character.</p>
</li></ul>

<p><em>Duplication</em></p>
<ul><li>
<p><a href="String.html#method-i-to_s"><code>to_s</code></a>, $to_str: If <code>self</code> is a subclass of String, returns <code>self</code> copied into a String; otherwise, returns <code>self</code>.</p>
</li></ul>

<h3 id="class-String-label-Methods+for+Converting+to+Non--5CString">Methods for Converting to Non-String<span><a href="#class-String-label-Methods+for+Converting+to+Non--5CString">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Each of these methods converts the contents of <code>self</code> to a non-String.</p>

<p><em>Characters, Bytes, and Clusters</em></p>
<ul><li>
<p><a href="String.html#method-i-bytes"><code>bytes</code></a>: Returns an array of the bytes in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-chars"><code>chars</code></a>: Returns an array of the characters in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-codepoints"><code>codepoints</code></a>: Returns an array of the integer ordinals in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-getbyte"><code>getbyte</code></a>: Returns an integer byte as determined by a given index.</p>
</li><li>
<p><a href="String.html#method-i-grapheme_clusters"><code>grapheme_clusters</code></a>: Returns an array of the grapheme clusters in <code>self</code>.</p>
</li></ul>

<p><em>Splitting</em></p>
<ul><li>
<p><a href="String.html#method-i-lines"><code>lines</code></a>: Returns an array of the lines in <code>self</code>, as determined by a given record separator.</p>
</li><li>
<p><a href="String.html#method-i-partition"><code>partition</code></a>: Returns a 3-element array determined by the first substring that matches a given substring or regexp,</p>
</li><li>
<p><a href="String.html#method-i-rpartition"><code>rpartition</code></a>: Returns a 3-element array determined by the last substring that matches a given substring or regexp,</p>
</li><li>
<p><a href="String.html#method-i-split"><code>split</code></a>: Returns an array of substrings determined by a given delimiter – regexp or string – or, if a block given, passes those substrings to the block.</p>
</li></ul>

<p><em>Matching</em></p>
<ul><li>
<p><a href="String.html#method-i-scan"><code>scan</code></a>: Returns an array of substrings matching a given regexp or string, or, if a block given, passes each matching substring to the  block.</p>
</li><li>
<p><a href="String.html#method-i-unpack"><code>unpack</code></a>: Returns an array of substrings extracted from <code>self</code> according to a given format.</p>
</li><li>
<p><a href="String.html#method-i-unpack1"><code>unpack1</code></a>: Returns the first substring extracted from <code>self</code> according to a given format.</p>
</li></ul>

<p><em>Numerics</em></p>
<ul><li>
<p><a href="String.html#method-i-hex"><code>hex</code></a>: Returns the integer value of the leading characters, interpreted as hexadecimal digits.</p>
</li><li>
<p><a href="String.html#method-i-oct"><code>oct</code></a>: Returns the integer value of the leading characters, interpreted as octal digits.</p>
</li><li>
<p><a href="String.html#method-i-ord"><code>ord</code></a>: Returns the integer ordinal of the first character in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-to_i"><code>to_i</code></a>: Returns the integer value of leading characters, interpreted as an integer.</p>
</li><li>
<p><a href="String.html#method-i-to_f"><code>to_f</code></a>: Returns the floating-point value of leading characters, interpreted as a floating-point number.</p>
</li></ul>

<p><em>Strings and Symbols</em></p>
<ul><li>
<p><a href="String.html#method-i-inspect"><code>inspect</code></a>: Returns copy of <code>self</code>, enclosed in double-quotes, with special characters escaped.</p>
</li><li>
<p><a href="String.html#method-i-to_sym"><code>to_sym</code></a>, <a href="String.html#method-i-intern"><code>intern</code></a>: Returns the symbol corresponding to <code>self</code>.</p>
</li></ul>

<h3 id="class-String-label-Methods+for+Iterating">Methods for Iterating<span><a href="#class-String-label-Methods+for+Iterating">&para;</a> <a href="#top">&uarr;</a></span></h3>
<ul><li>
<p><a href="String.html#method-i-each_byte"><code>each_byte</code></a>: Calls the given block with each successive byte in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-each_char"><code>each_char</code></a>: Calls the given block with each successive character in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-each_codepoint"><code>each_codepoint</code></a>: Calls the given block with each successive integer codepoint in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-each_grapheme_cluster"><code>each_grapheme_cluster</code></a>: Calls the given block with each successive grapheme cluster in <code>self</code>.</p>
</li><li>
<p><a href="String.html#method-i-each_line"><code>each_line</code></a>: Calls the given block with each successive line in <code>self</code>, as determined by a given record separator.</p>
</li><li>
<p><a href="String.html#method-i-upto"><code>upto</code></a>: Calls the given block with each string value returned by successive calls to <a href="String.html#method-i-succ"><code>succ</code></a>.</p>
</li></ul>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">





     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

      <div id="method-c-new" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              new(string = &#39;&#39;, **opts) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new String that is a copy of <code>string</code>.</p>

<p>With no arguments, returns the empty string with the <a href="Encoding.html"><code>Encoding</code></a> <code>ASCII-8BIT</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">s</span> <span class="ruby-comment"># =&gt; &quot;&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span> <span class="ruby-comment"># =&gt; #&lt;Encoding:ASCII-8BIT&gt;</span>
</pre>

<p>With optional argument <code>string</code> and no keyword arguments, returns a copy of <code>string</code> with the same encoding:</p>

<pre class="ruby"><span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;foo&#39;</span>)               <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;тест&#39;</span>)              <span class="ruby-comment"># =&gt; &quot;тест&quot;</span>
<span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;こんにちは&#39;</span>)          <span class="ruby-comment"># =&gt; &quot;こんにちは&quot;</span>
</pre>

<p>(Unlike String.new, a <a href="syntax/literals_rdoc.html#label-String+Literals">string literal</a> like <code>&#39;&#39;</code> or a <a href="syntax/literals_rdoc.html#label-Here+Document+Literals">here document literal</a> always has <a href="encodings_rdoc.html#label-Script+Encoding">script encoding</a>.)</p>

<p>With optional keyword argument <code>encoding</code>, returns a copy of <code>string</code> with the specified encoding; the <code>encoding</code> may be an <a href="Encoding.html"><code>Encoding</code></a> object, an encoding name, or an encoding name alias:</p>

<pre class="ruby"><span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">encoding:</span> <span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">US_ASCII</span>).<span class="ruby-identifier">encoding</span> <span class="ruby-comment"># =&gt; #&lt;Encoding:US-ASCII&gt;</span>
<span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">encoding:</span> <span class="ruby-string">&#39;US-ASCII&#39;</span>).<span class="ruby-identifier">encoding</span>         <span class="ruby-comment"># =&gt; #&lt;Encoding:US-ASCII&gt;</span>
<span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">encoding:</span> <span class="ruby-string">&#39;ASCII&#39;</span>).<span class="ruby-identifier">encoding</span>            <span class="ruby-comment"># =&gt; #&lt;Encoding:US-ASCII&gt;</span>
</pre>

<p>The given encoding need not be valid for the string’s content, and that validity is not checked:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;こんにちは&#39;</span>, <span class="ruby-value">encoding:</span> <span class="ruby-string">&#39;ascii&#39;</span>)
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">valid_encoding?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>But the given <code>encoding</code> itself is checked:</p>

<pre class="ruby"><span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">encoding:</span> <span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># Raises ArgumentError.</span>
</pre>

<p>With optional keyword argument <code>capacity</code>, returns a copy of <code>string</code> (or an empty string, if <code>string</code> is not given); the given <code>capacity</code> is advisory only, and may or may not set the size of the internal buffer, which may in turn affect performance:</p>

<pre class="ruby"><span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">capacity:</span> <span class="ruby-value">1</span>)
<span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;foo&#39;</span>, <span class="ruby-value">capacity:</span> <span class="ruby-value">4096</span>)
</pre>

<p>The <code>string</code>, <code>encoding</code>, and <code>capacity</code> arguments may all be used together:</p>

<pre class="ruby"><span class="ruby-constant">String</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&#39;hello&#39;</span>, <span class="ruby-value">encoding:</span> <span class="ruby-string">&#39;UTF-8&#39;</span>, <span class="ruby-value">capacity:</span> <span class="ruby-value">25</span>)
</pre>

          <div class="method-source-code" id="new-source">
            <pre>static VALUE
rb_str_init(int argc, VALUE *argv, VALUE str)
{
    static ID keyword_ids[2];
    VALUE orig, opt, venc, vcapa;
    VALUE kwargs[2];
    rb_encoding *enc = 0;
    int n;

    if (!keyword_ids[0]) {
        keyword_ids[0] = rb_id_encoding();
        CONST_ID(keyword_ids[1], &quot;capacity&quot;);
    }

    n = rb_scan_args(argc, argv, &quot;01:&quot;, &amp;orig, &amp;opt);
    if (!NIL_P(opt)) {
        rb_get_kwargs(opt, keyword_ids, 0, 2, kwargs);
        venc = kwargs[0];
        vcapa = kwargs[1];
        if (!UNDEF_P(venc) &amp;&amp; !NIL_P(venc)) {
            enc = rb_to_encoding(venc);
        }
        if (!UNDEF_P(vcapa) &amp;&amp; !NIL_P(vcapa)) {
            long capa = NUM2LONG(vcapa);
            long len = 0;
            int termlen = enc ? rb_enc_mbminlen(enc) : 1;

            if (capa &lt; STR_BUF_MIN_SIZE) {
                capa = STR_BUF_MIN_SIZE;
            }
            if (n == 1) {
                StringValue(orig);
                len = RSTRING_LEN(orig);
                if (capa &lt; len) {
                    capa = len;
                }
                if (orig == str) n = 0;
            }
            str_modifiable(str);
            if (STR_EMBED_P(str)) { /* make noembed always */
                char *new_ptr = ALLOC_N(char, (size_t)capa + termlen);
#if USE_RVARGC
                assert(RSTRING(str)-&gt;as.embed.len + 1 &lt;= str_embed_capa(str));
                memcpy(new_ptr, RSTRING(str)-&gt;as.embed.ary, RSTRING(str)-&gt;as.embed.len + 1);
#else
                memcpy(new_ptr, RSTRING(str)-&gt;as.embed.ary, RSTRING_EMBED_LEN_MAX + 1);
#endif
                RSTRING(str)-&gt;as.heap.ptr = new_ptr;
            }
            else if (FL_TEST(str, STR_SHARED|STR_NOFREE)) {
                const size_t size = (size_t)capa + termlen;
                const char *const old_ptr = RSTRING_PTR(str);
                const size_t osize = RSTRING(str)-&gt;as.heap.len + TERM_LEN(str);
                char *new_ptr = ALLOC_N(char, (size_t)capa + termlen);
                memcpy(new_ptr, old_ptr, osize &lt; size ? osize : size);
                FL_UNSET_RAW(str, STR_SHARED|STR_NOFREE);
                RSTRING(str)-&gt;as.heap.ptr = new_ptr;
            }
            else if (STR_HEAP_SIZE(str) != (size_t)capa + termlen) {
                SIZED_REALLOC_N(RSTRING(str)-&gt;as.heap.ptr, char,
                        (size_t)capa + termlen, STR_HEAP_SIZE(str));
            }
            RSTRING(str)-&gt;as.heap.len = len;
            TERM_FILL(&amp;RSTRING(str)-&gt;as.heap.ptr[len], termlen);
            if (n == 1) {
                memcpy(RSTRING(str)-&gt;as.heap.ptr, RSTRING_PTR(orig), len);
                rb_enc_cr_str_exact_copy(str, orig);
            }
            FL_SET(str, STR_NOEMBED);
            RSTRING(str)-&gt;as.heap.aux.capa = capa;
        }
        else if (n == 1) {
            rb_str_replace(str, orig);
        }
        if (enc) {
            rb_enc_associate(str, enc);
            ENC_CODERANGE_CLEAR(str);
        }
    }
    else if (n == 1) {
        rb_str_replace(str, orig);
    }
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-c-try_convert" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              try_convert(object) &rarr; object, new_string, or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>If <code>object</code> is a String object, returns <code>object</code>.</p>

<p>Otherwise if <code>object</code> responds to <code>:to_str</code>, calls <code>object.to_str</code> and returns the result.</p>

<p>Returns <code>nil</code> if <code>object</code> does not respond to <code>:to_str</code>.</p>

<p>Raises an exception unless <code>object.to_str</code> returns a String object.</p>

          <div class="method-source-code" id="try_convert-source">
            <pre>static VALUE
rb_str_s_try_convert(VALUE dummy, VALUE str)
{
    return rb_check_string_type(str);
}</pre>
          </div>
        </div>


      </div>

    </section>

     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-25" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string % object &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the result of formatting <code>object</code> into the format specification <code>self</code> (see <a href="Kernel.html#method-i-sprintf"><code>Kernel#sprintf</code></a> for formatting details):</p>

<pre class="ruby"><span class="ruby-string">&quot;%05d&quot;</span> <span class="ruby-operator">%</span> <span class="ruby-value">123</span> <span class="ruby-comment"># =&gt; &quot;00123&quot;</span>
</pre>

<p>If <code>self</code> contains multiple substitutions, <code>object</code> must be an Array or Hash containing the values to be substituted:</p>

<pre class="ruby"><span class="ruby-string">&quot;%-5s: %016x&quot;</span> <span class="ruby-operator">%</span> [ <span class="ruby-string">&quot;ID&quot;</span>, <span class="ruby-keyword">self</span>.<span class="ruby-identifier">object_id</span> ] <span class="ruby-comment"># =&gt; &quot;ID   : 00002b054ec93168&quot;</span>
<span class="ruby-string">&quot;foo = %{foo}&quot;</span> <span class="ruby-operator">%</span> {<span class="ruby-value">foo:</span> <span class="ruby-string">&#39;bar&#39;</span>} <span class="ruby-comment"># =&gt; &quot;foo = bar&quot;</span>
<span class="ruby-string">&quot;foo = %{foo}, baz = %{baz}&quot;</span> <span class="ruby-operator">%</span> {<span class="ruby-value">foo:</span> <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">baz:</span> <span class="ruby-string">&#39;bat&#39;</span>} <span class="ruby-comment"># =&gt; &quot;foo = bar, baz = bat&quot;</span>
</pre>

          <div class="method-source-code" id="25-source">
            <pre>static VALUE
rb_str_format_m(VALUE str, VALUE arg)
{
    VALUE tmp = rb_check_array_type(arg);

    if (!NIL_P(tmp)) {
        return rb_str_format(RARRAY_LENINT(tmp), RARRAY_CONST_PTR(tmp), str);
    }
    return rb_str_format(1, &amp;arg, str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2A" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string * integer &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new String containing <code>integer</code> copies of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&quot;Ho! &quot;</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span> <span class="ruby-comment"># =&gt; &quot;Ho! Ho! Ho! &quot;</span>
<span class="ruby-string">&quot;Ho! &quot;</span> <span class="ruby-operator">*</span> <span class="ruby-value">0</span> <span class="ruby-comment"># =&gt; &quot;&quot;</span>
</pre>

          <div class="method-source-code" id="2A-source">
            <pre>VALUE
rb_str_times(VALUE str, VALUE times)
{
    VALUE str2;
    long n, len;
    char *ptr2;
    int termlen;

    if (times == INT2FIX(1)) {
        return str_duplicate(rb_cString, str);
    }
    if (times == INT2FIX(0)) {
        str2 = str_alloc_embed(rb_cString, 0);
        rb_enc_copy(str2, str);
        return str2;
    }
    len = NUM2LONG(times);
    if (len &lt; 0) {
        rb_raise(rb_eArgError, &quot;negative argument&quot;);
    }
    if (RSTRING_LEN(str) == 1 &amp;&amp; RSTRING_PTR(str)[0] == 0) {
        if (STR_EMBEDDABLE_P(len, 1)) {
            str2 = str_alloc_embed(rb_cString, len + 1);
            memset(RSTRING_PTR(str2), 0, len + 1);
        }
        else {
            str2 = str_alloc_heap(rb_cString);
            RSTRING(str2)-&gt;as.heap.aux.capa = len;
            RSTRING(str2)-&gt;as.heap.ptr = ZALLOC_N(char, (size_t)len + 1);
        }
        STR_SET_LEN(str2, len);
        rb_enc_copy(str2, str);
        return str2;
    }
    if (len &amp;&amp; LONG_MAX/len &lt;  RSTRING_LEN(str)) {
        rb_raise(rb_eArgError, &quot;argument too big&quot;);
    }

    len *= RSTRING_LEN(str);
    termlen = TERM_LEN(str);
    str2 = str_new0(rb_cString, 0, len, termlen);
    ptr2 = RSTRING_PTR(str2);
    if (len) {
        n = RSTRING_LEN(str);
        memcpy(ptr2, RSTRING_PTR(str), n);
        while (n &lt;= len/2) {
            memcpy(ptr2 + n, ptr2, n);
            n *= 2;
        }
        memcpy(ptr2 + n, ptr2, len-n);
    }
    STR_SET_LEN(str2, len);
    TERM_FILL(&amp;ptr2[len], termlen);
    rb_enc_cr_str_copy_for_substr(str2, str);

    return str2;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2B" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string + other_string &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new String containing <code>other_string</code> concatenated to <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&quot;Hello from &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">to_s</span> <span class="ruby-comment"># =&gt; &quot;Hello from main&quot;</span>
</pre>

          <div class="method-source-code" id="2B-source">
            <pre>VALUE
rb_str_plus(VALUE str1, VALUE str2)
{
    VALUE str3;
    rb_encoding *enc;
    char *ptr1, *ptr2, *ptr3;
    long len1, len2;
    int termlen;

    StringValue(str2);
    enc = rb_enc_check_str(str1, str2);
    RSTRING_GETMEM(str1, ptr1, len1);
    RSTRING_GETMEM(str2, ptr2, len2);
    termlen = rb_enc_mbminlen(enc);
    if (len1 &gt; LONG_MAX - len2) {
        rb_raise(rb_eArgError, &quot;string size too big&quot;);
    }
    str3 = str_new0(rb_cString, 0, len1+len2, termlen);
    ptr3 = RSTRING_PTR(str3);
    memcpy(ptr3, ptr1, len1);
    memcpy(ptr3+len1, ptr2, len2);
    TERM_FILL(&amp;ptr3[len1+len2], termlen);

    ENCODING_CODERANGE_SET(str3, rb_enc_to_index(enc),
                           ENC_CODERANGE_AND(ENC_CODERANGE(str1), ENC_CODERANGE(str2)));
    RB_GC_GUARD(str1);
    RB_GC_GUARD(str2);
    return str3;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2B-40" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              +string &rarr; new_string or self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code> if <code>self</code> is not frozen.</p>

<p>Otherwise returns <code>self.dup</code>, which is not frozen.</p>

          <div class="method-source-code" id="2B-40-source">
            <pre>static VALUE
str_uplus(VALUE str)
{
    if (OBJ_FROZEN(str)) {
        return rb_str_dup(str);
    }
    else {
        return str;
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-2D-40" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              -string &rarr; frozen_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a frozen, possibly pre-existing copy of the string.</p>

<p>The returned String will be deduplicated as long as it does not have any instance variables set on it and is not a <a href="String.html"><code>String</code></a> subclass.</p>

<p><a href="String.html#method-i-dedup"><code>String#dedup</code></a> is an alias for <a href="String.html#method-i-2D-40"><code>String#-@</code></a>.</p>

          <div class="method-source-code" id="2D-40-source">
            <pre>static VALUE
str_uminus(VALUE str)
{
    if (!BARE_STRING_P(str) &amp;&amp; !rb_obj_frozen_p(str)) {
        str = rb_str_dup(str);
    }
    return rb_fstring(str);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-dedup">dedup</a>
        </div>

      </div>

      <div id="method-i-3C-3C" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string &lt;&lt; object &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Concatenates <code>object</code> to <code>self</code> and returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-string">&#39;bar&#39;</span> <span class="ruby-comment"># =&gt; &quot;foobar&quot;</span>
<span class="ruby-identifier">s</span>          <span class="ruby-comment"># =&gt; &quot;foobar&quot;</span>
</pre>

<p>If <code>object</code> is an Integer, the value is considered a codepoint and converted to a character before concatenation:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-value">33</span> <span class="ruby-comment"># =&gt; &quot;foo!&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-concat"><code>String#concat</code></a>, which takes multiple arguments.</p>

          <div class="method-source-code" id="3C-3C-source">
            <pre>VALUE
rb_str_concat(VALUE str1, VALUE str2)
{
    unsigned int code;
    rb_encoding *enc = STR_ENC_GET(str1);
    int encidx;

    if (RB_INTEGER_TYPE_P(str2)) {
        if (rb_num_to_uint(str2, &amp;code) == 0) {
        }
        else if (FIXNUM_P(str2)) {
            rb_raise(rb_eRangeError, &quot;%ld out of char range&quot;, FIX2LONG(str2));
        }
        else {
            rb_raise(rb_eRangeError, &quot;bignum out of char range&quot;);
        }
    }
    else {
        return rb_str_append(str1, str2);
    }

    encidx = rb_ascii8bit_appendable_encoding_index(enc, code);
    if (encidx &gt;= 0) {
        char buf[1];
        buf[0] = (char)code;
        rb_str_cat(str1, buf, 1);
        if (encidx != rb_enc_to_index(enc)) {
            rb_enc_associate_index(str1, encidx);
            ENC_CODERANGE_SET(str1, ENC_CODERANGE_VALID);
        }
    }
    else {
        long pos = RSTRING_LEN(str1);
        int cr = ENC_CODERANGE(str1);
        int len;
        char *buf;

        switch (len = rb_enc_codelen(code, enc)) {
          case ONIGERR_INVALID_CODE_POINT_VALUE:
            rb_raise(rb_eRangeError, &quot;invalid codepoint 0x%X in %s&quot;, code, rb_enc_name(enc));
            break;
          case ONIGERR_TOO_BIG_WIDE_CHAR_VALUE:
          case 0:
            rb_raise(rb_eRangeError, &quot;%u out of char range&quot;, code);
            break;
        }
        buf = ALLOCA_N(char, len + 1);
        rb_enc_mbcput(code, buf, enc);
        if (rb_enc_precise_mbclen(buf, buf + len + 1, enc) != len) {
            rb_raise(rb_eRangeError, &quot;invalid codepoint 0x%X in %s&quot;, code, rb_enc_name(enc));
        }
        rb_str_resize(str1, pos+len);
        memcpy(RSTRING_PTR(str1) + pos, buf, len);
        if (cr == ENC_CODERANGE_7BIT &amp;&amp; code &gt; 127)
            cr = ENC_CODERANGE_VALID;
        ENC_CODERANGE_SET(str1, cr);
    }
    return str1;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3C-3D-3E" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string &lt;=&gt; other_string &rarr; -1, 0, 1, or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Compares <code>self</code> and <code>other_string</code>, returning:</p>
<ul><li>
<p>-1 if <code>other_string</code> is larger.</p>
</li><li>
<p>0 if the two are equal.</p>
</li><li>
<p>1 if <code>other_string</code> is smaller.</p>
</li><li>
<p><code>nil</code> if the two are incomparable.</p>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">&#39;food&#39;</span> <span class="ruby-comment"># =&gt; -1</span>
<span class="ruby-string">&#39;food&#39;</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;FOO&#39;</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; -1</span>
<span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-string">&#39;FOO&#39;</span> <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">&lt;=&gt;</span> <span class="ruby-value">1</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

          <div class="method-source-code" id="3C-3D-3E-source">
            <pre>static VALUE
rb_str_cmp_m(VALUE str1, VALUE str2)
{
    int result;
    VALUE s = rb_check_string_type(str2);
    if (NIL_P(s)) {
        return rb_invcmp(str1, str2);
    }
    result = rb_str_cmp(str1, s);
    return INT2FIX(result);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-3D-3D" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string == object &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>object</code> has the same length and content; as <code>self</code>; <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;food&#39;</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;FOO&#39;</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Returns <code>false</code> if the two strings’ encodings are not compatible:</p>

<pre class="ruby"><span class="ruby-string">&quot;\u{e4 f6 fc}&quot;</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>) <span class="ruby-operator">==</span> (<span class="ruby-string">&quot;\u{c4 d6 dc}&quot;</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>If <code>object</code> is not an instance of String but responds to <code>to_str</code>, then the two strings are compared using <code>object.==</code>.</p>

          <div class="method-source-code" id="3D-3D-source">
            <pre>VALUE
rb_str_equal(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (!RB_TYPE_P(str2, T_STRING)) {
        if (!rb_respond_to(str2, idTo_str)) {
            return Qfalse;
        }
        return rb_equal(str2, str1);
    }
    return rb_str_eql_internal(str1, str2);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-3D-3D-3D">===</a>
        </div>

      </div>

      <div id="method-i-3D-3D-3D" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string === object &rarr; true or false
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>object</code> has the same length and content; as <code>self</code>; <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;food&#39;</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-string">&#39;FOO&#39;</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Returns <code>false</code> if the two strings’ encodings are not compatible:</p>

<pre class="ruby"><span class="ruby-string">&quot;\u{e4 f6 fc}&quot;</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>) <span class="ruby-operator">==</span> (<span class="ruby-string">&quot;\u{c4 d6 dc}&quot;</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>If <code>object</code> is not an instance of String but responds to <code>to_str</code>, then the two strings are compared using <code>object.==</code>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-3D-3D">==</a>
        </div>
      </div>

      <div id="method-i-3D~" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string =~ regexp &rarr; integer or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string =~ object &rarr; integer or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the Integer index of the first substring that matches the given <code>regexp</code>, or <code>nil</code> if no match found:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/f/</span> <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/o/</span> <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/x/</span> <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Note: also updates <a href="Regexp.html#class-Regexp-label-Special+global+variables">Special global variables at <code>Regexp</code></a>.</p>

<p>If the given <code>object</code> is not a Regexp, returns the value returned by <code>object =~ self</code>.</p>

<p>Note that <code>string =~ regexp</code> is different from <code>regexp =~ string</code> (see <a href="Regexp.html#method-i-3D~"><code>Regexp#=~</code></a>):</p>

<pre class="ruby"><span class="ruby-identifier">number</span>= <span class="ruby-keyword">nil</span>
<span class="ruby-string">&quot;no. 9&quot;</span> <span class="ruby-operator">=~</span> <span class="ruby-regexp">/(?&lt;number&gt;\d+)/</span>
<span class="ruby-identifier">number</span> <span class="ruby-comment"># =&gt; nil (not assigned)</span>
<span class="ruby-regexp">/(?&lt;number&gt;\d+)/</span> <span class="ruby-operator">=~</span> <span class="ruby-string">&quot;no. 9&quot;</span>
<span class="ruby-identifier">number</span> <span class="ruby-comment">#=&gt; &quot;9&quot;</span>
</pre>

          <div class="method-source-code" id="3D~-source">
            <pre>static VALUE
rb_str_match(VALUE x, VALUE y)
{
    switch (OBJ_BUILTIN_TYPE(y)) {
      case T_STRING:
        rb_raise(rb_eTypeError, &quot;type mismatch: String given&quot;);

      case T_REGEXP:
        return rb_reg_match(y, x);

      default:
        return rb_funcall(y, idEqTilde, 1, x);
    }
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-5B-5D" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string[index] &rarr; new_string or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[start, length] &rarr; new_string or nil
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[range] &rarr; new_string or nil
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[regexp, capture = 0] &rarr; new_string or nil
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[substring] &rarr; new_string or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the substring of <code>self</code> specified by the arguments. See examples at <a href="String.html#class-String-label-String+Slices">String Slices</a>.</p>

          <div class="method-source-code" id="5B-5D-source">
            <pre>static VALUE
rb_str_aref_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
        if (RB_TYPE_P(argv[0], T_REGEXP)) {
            return rb_str_subpat(str, argv[0], argv[1]);
        }
        else {
            long beg = NUM2LONG(argv[0]);
            long len = NUM2LONG(argv[1]);
            return rb_str_substr(str, beg, len);
        }
    }
    rb_check_arity(argc, 1, 2);
    return rb_str_aref(str, argv[0]);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-slice">slice</a>
        </div>

      </div>

      <div id="method-i-5B-5D-3D" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              string[index] = new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[start, length] = new_string
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[range] = new_string
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[regexp, capture = 0] = new_string
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              string[substring] = new_string
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Replaces all, some, or none of the contents of <code>self</code>; returns <code>new_string</code>. See <a href="String.html#class-String-label-String+Slices">String Slices</a>.</p>

<p>A few examples:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-value">2</span>] = <span class="ruby-string">&#39;rtune&#39;</span>     <span class="ruby-comment"># =&gt; &quot;rtune&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;fortune&quot;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-value">1</span>, <span class="ruby-value">5</span>] = <span class="ruby-string">&#39;init&#39;</span>   <span class="ruby-comment"># =&gt; &quot;init&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;finite&quot;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">4</span>] = <span class="ruby-string">&#39;al&#39;</span>     <span class="ruby-comment"># =&gt; &quot;al&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;finale&quot;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-regexp">/e$/</span>] = <span class="ruby-string">&#39;ly&#39;</span>     <span class="ruby-comment"># =&gt; &quot;ly&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;finally&quot;</span>
<span class="ruby-identifier">s</span>[<span class="ruby-string">&#39;lly&#39;</span>] = <span class="ruby-string">&#39;ncial&#39;</span> <span class="ruby-comment"># =&gt; &quot;ncial&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;financial&quot;</span>
</pre>

<p><a href="String.html#method-i-slice"><code>String#slice</code></a> is an alias for <a href="String.html#method-i-5B-5D"><code>String#[]</code></a>.</p>

          <div class="method-source-code" id="5B-5D-3D-source">
            <pre>static VALUE
rb_str_aset_m(int argc, VALUE *argv, VALUE str)
{
    if (argc == 3) {
        if (RB_TYPE_P(argv[0], T_REGEXP)) {
            rb_str_subpat_set(str, argv[0], argv[1], argv[2]);
        }
        else {
            rb_str_splice(str, NUM2LONG(argv[0]), NUM2LONG(argv[1]), argv[2]);
        }
        return argv[2];
    }
    rb_check_arity(argc, 2, 3);
    return rb_str_aset(str, argv[0], argv[1]);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-ascii_only-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              ascii_only? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> contains only ASCII characters, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-string">&#39;abc&#39;</span>.<span class="ruby-identifier">ascii_only?</span>         <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&quot;abc\u{6666}&quot;</span>.<span class="ruby-identifier">ascii_only?</span> <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="ascii_only-3F-source">
            <pre>static VALUE
rb_str_is_ascii_only_p(VALUE str)
{
    int cr = rb_enc_str_coderange(str);

    return RBOOL(cr == ENC_CODERANGE_7BIT);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-b" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              b &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> that has ASCII-8BIT encoding; the underlying bytes are not modified:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;\x99&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>   <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-identifier">t</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">b</span>      <span class="ruby-comment"># =&gt; &quot;\x99&quot;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">encoding</span>   <span class="ruby-comment"># =&gt; #&lt;Encoding:ASCII-8BIT&gt;</span>

<span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;\u4095&quot;</span> <span class="ruby-comment"># =&gt; &quot;䂕&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>   <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">bytes</span>      <span class="ruby-comment"># =&gt; [228, 130, 149]</span>
<span class="ruby-identifier">t</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">b</span>      <span class="ruby-comment"># =&gt; &quot;\xE4\x82\x95&quot;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">encoding</span>   <span class="ruby-comment"># =&gt; #&lt;Encoding:ASCII-8BIT&gt;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">bytes</span>      <span class="ruby-comment"># =&gt; [228, 130, 149]</span>
</pre>

          <div class="method-source-code" id="b-source">
            <pre>static VALUE
rb_str_b(VALUE str)
{
    VALUE str2;
    if (FL_TEST(str, STR_NOEMBED)) {
        str2 = str_alloc_heap(rb_cString);
    }
    else {
        str2 = str_alloc_embed(rb_cString, RSTRING_EMBED_LEN(str) + TERM_LEN(str));
    }
    str_replace_shared_without_enc(str2, str);

    if (rb_enc_asciicompat(STR_ENC_GET(str))) {
        // BINARY strings can never be broken; they&#39;re either 7-bit ASCII or VALID.
        // If we know the receiver&#39;s code range then we know the result&#39;s code range.
        int cr = ENC_CODERANGE(str);
        switch (cr) {
          case ENC_CODERANGE_7BIT:
            ENC_CODERANGE_SET(str2, ENC_CODERANGE_7BIT);
            break;
          case ENC_CODERANGE_BROKEN:
          case ENC_CODERANGE_VALID:
            ENC_CODERANGE_SET(str2, ENC_CODERANGE_VALID);
            break;
          default:
            ENC_CODERANGE_CLEAR(str2);
            break;
        }
    }

    return str2;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-byteindex" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              byteindex(substring, offset = 0) &rarr; integer or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              byteindex(regexp, offset = 0) &rarr; integer or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the Integer byte-based index of the first occurrence of the given <code>substring</code>, or <code>nil</code> if none found:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;f&#39;</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;oo&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;ooo&#39;</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Returns the Integer byte-based index of the first match for the given Regexp <code>regexp</code>, or <code>nil</code> if none found:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-regexp">/f/</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-regexp">/o/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-regexp">/oo/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-regexp">/ooo/</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Integer argument <code>offset</code>, if given, specifies the byte-based position in the string to begin the search:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>offset</code> is negative, counts backward from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-3</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-4</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>offset</code> does not land on character (codepoint) boundary, <code>IndexError</code> is raised.</p>

<p>Related: <a href="String.html#method-i-index"><code>String#index</code></a>, <a href="String.html#method-i-byterindex"><code>String#byterindex</code></a>.</p>

          <div class="method-source-code" id="byteindex-source">
            <pre>static VALUE
rb_str_byteindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
    }
    else {
        pos = 0;
    }
    if (pos &lt; 0) {
        pos += RSTRING_LEN(str);
        if (pos &lt; 0) {
            if (RB_TYPE_P(sub, T_REGEXP)) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
    }

    if (!str_check_byte_pos(str, pos)) {
        rb_raise(rb_eIndexError,
                 &quot;offset %ld does not land on character boundary&quot;, pos);
    }

    if (RB_TYPE_P(sub, T_REGEXP)) {
        if (pos &gt; RSTRING_LEN(str))
            return Qnil;
        if (rb_reg_search(sub, str, pos, 0) &lt; 0) {
            return Qnil;
        }
        else {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = BEG(0);
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_strseq_index(str, sub, pos, 1);
    }

    if (pos == -1) return Qnil;
    return LONG2NUM(pos);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-byterindex" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              byterindex(substring, offset = self.bytesize) &rarr; integer or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              byterindex(regexp, offset = self.bytesize) &rarr; integer or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the Integer byte-based index of the <em>last</em> occurrence of the given <code>substring</code>, or <code>nil</code> if none found:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;f&#39;</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;oo&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;ooo&#39;</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Returns the Integer byte-based index of the <em>last</em> match for the given Regexp <code>regexp</code>, or <code>nil</code> if none found:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-regexp">/f/</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-regexp">/o/</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-regexp">/oo/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-regexp">/ooo/</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>The <em>last</em> match means starting at the possible last position, not the last of longest matches.</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-regexp">/o+/</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">$~</span> <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;o&quot;&gt;</span>
</pre>

<p>To get the last longest match, needs to combine with negative lookbehind.</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-regexp">/(?&lt;!o)o+/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">$~</span> <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;oo&quot;&gt;</span>
</pre>

<p>Or <a href="String.html#method-i-byteindex"><code>String#byteindex</code></a> with negative lookforward.</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byteindex</span>(<span class="ruby-regexp">/o+(?!.*o)/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">$~</span> <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;oo&quot;&gt;</span>
</pre>

<p>Integer argument <code>offset</code>, if given and non-negative, specifies the maximum starting byte-based position in the</p>

<pre class="ruby"><span class="ruby-identifier">string</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">_end_</span> <span class="ruby-identifier">the</span> <span class="ruby-value">search:</span>

 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; nil</span>
 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; 1</span>
 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; 2</span>
 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>If <code>offset</code> is a negative Integer, the maximum starting position in the string to <em>end</em> the search is the sum of the string’s length and <code>offset</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-3</span>) <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">byterindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-4</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If <code>offset</code> does not land on character (codepoint) boundary, <code>IndexError</code> is raised.</p>

<p>Related: <a href="String.html#method-i-byteindex"><code>String#byteindex</code></a>.</p>

          <div class="method-source-code" id="byterindex-source">
            <pre>static VALUE
rb_str_byterindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE vpos;
    long pos, len = RSTRING_LEN(str);

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;vpos) == 2) {
        pos = NUM2LONG(vpos);
        if (pos &lt; 0) {
            pos += len;
            if (pos &lt; 0) {
                if (RB_TYPE_P(sub, T_REGEXP)) {
                    rb_backref_set(Qnil);
                }
                return Qnil;
            }
        }
        if (pos &gt; len) pos = len;
    }
    else {
        pos = len;
    }

    if (!str_check_byte_pos(str, pos)) {
        rb_raise(rb_eIndexError,
                 &quot;offset %ld does not land on character boundary&quot;, pos);
    }

    if (RB_TYPE_P(sub, T_REGEXP)) {
        if (rb_reg_search(sub, str, pos, 1) &gt;= 0) {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = BEG(0);
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_str_byterindex(str, sub, pos);
        if (pos &gt;= 0) return LONG2NUM(pos);
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-bytes" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              bytes &rarr; array_of_bytes
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns an array of the bytes in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">bytes</span> <span class="ruby-comment"># =&gt; [104, 101, 108, 108, 111]</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">bytes</span>  <span class="ruby-comment"># =&gt; [209, 130, 208, 181, 209, 129, 209, 130]</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">bytes</span>
<span class="ruby-comment"># =&gt; [227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175]</span>
</pre>

          <div class="method-source-code" id="bytes-source">
            <pre>static VALUE
rb_str_bytes(VALUE str)
{
    VALUE ary = WANTARRAY(&quot;bytes&quot;, RSTRING_LEN(str));
    return rb_str_enumerate_bytes(str, ary);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-bytesize" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              bytesize &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the count of bytes (not characters) in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">bytesize</span>        <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">bytesize</span>       <span class="ruby-comment"># =&gt; 8</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">bytesize</span>   <span class="ruby-comment"># =&gt; 15</span>
</pre>

<p>Contrast with <a href="String.html#method-i-length"><code>String#length</code></a>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">length</span>       <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">length</span>      <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">length</span>  <span class="ruby-comment"># =&gt; 5</span>
</pre>

          <div class="method-source-code" id="bytesize-source">
            <pre>static VALUE
rb_str_bytesize(VALUE str)
{
    return LONG2NUM(RSTRING_LEN(str));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-byteslice" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              byteslice(index, length = 1) &rarr; string or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              byteslice(range)             &rarr; string or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a substring of <code>self</code>, or <code>nil</code> if the substring cannot be constructed.</p>

<p>With integer arguments <code>index</code> and <code>length</code> given, returns the substring beginning at the given <code>index</code> of the given <code>length</code> (if possible), or <code>nil</code> if <code>length</code> is negative or <code>index</code> falls outside of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;0123456789&#39;</span> <span class="ruby-comment"># =&gt; &quot;0123456789&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; &quot;2&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">200</span>) <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">4</span>, <span class="ruby-value">3</span>)  <span class="ruby-comment"># =&gt; &quot;456&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">4</span>, <span class="ruby-value">30</span>) <span class="ruby-comment"># =&gt; &quot;456789&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">4</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">40</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>In either case above, counts backwards from the end of <code>self</code> if <code>index</code> is negative:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;0123456789&#39;</span>   <span class="ruby-comment"># =&gt; &quot;0123456789&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">-4</span>)    <span class="ruby-comment"># =&gt; &quot;6&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">-4</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; &quot;678&quot;</span>
</pre>

<p>With <a href="Range.html"><code>Range</code></a> argument <code>range</code> given, returns <code>byteslice(range.begin, range.size)</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;0123456789&#39;</span>    <span class="ruby-comment"># =&gt; &quot;0123456789&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">4</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>)   <span class="ruby-comment"># =&gt; &quot;456&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">-6</span><span class="ruby-operator">..</span><span class="ruby-value">-4</span>) <span class="ruby-comment"># =&gt; &quot;456&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">5</span><span class="ruby-operator">..</span><span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; &quot;&quot; # range.size is zero.</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">40</span><span class="ruby-operator">..</span><span class="ruby-value">42</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>In all cases, a returned string has the same encoding as <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>              <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">byteslice</span>(<span class="ruby-value">4</span>).<span class="ruby-identifier">encoding</span> <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
</pre>

          <div class="method-source-code" id="byteslice-source">
            <pre>static VALUE
rb_str_byteslice(int argc, VALUE *argv, VALUE str)
{
    if (argc == 2) {
        long beg = NUM2LONG(argv[0]);
        long len = NUM2LONG(argv[1]);
        return str_byte_substr(str, beg, len, TRUE);
    }
    rb_check_arity(argc, 1, 2);
    return str_byte_aref(str, argv[0]);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-bytesplice" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              bytesplice(index, length, str) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              bytesplice(range, str)         &rarr; string
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Replaces some or all of the content of <code>self</code> with <code>str</code>, and returns <code>self</code>. The portion of the string affected is determined using the same criteria as <a href="String.html#method-i-byteslice"><code>String#byteslice</code></a>, except that <code>length</code> cannot be omitted. If the replacement string is not the same length as the text it is replacing, the string will be adjusted accordingly. The form that take an <a href="Integer.html"><code>Integer</code></a> will raise an <a href="IndexError.html"><code>IndexError</code></a> if the value is out of range; the <a href="Range.html"><code>Range</code></a> form will raise a <a href="RangeError.html"><code>RangeError</code></a>. If the beginning or ending offset does not land on character (codepoint) boundary, an <a href="IndexError.html"><code>IndexError</code></a> will be raised.</p>

          <div class="method-source-code" id="bytesplice-source">
            <pre>static VALUE
rb_str_bytesplice(int argc, VALUE *argv, VALUE str)
{
    long beg, end, len, slen;
    VALUE val;
    rb_encoding *enc;
    int cr;

    rb_check_arity(argc, 2, 3);
    if (argc == 2) {
        if (!rb_range_beg_len(argv[0], &amp;beg, &amp;len, RSTRING_LEN(str), 2)) {
            rb_raise(rb_eTypeError, &quot;wrong argument type %s (expected Range)&quot;,
                     rb_builtin_class_name(argv[0]));
        }
        val = argv[1];
    }
    else {
        beg = NUM2LONG(argv[0]);
        len = NUM2LONG(argv[1]);
        val = argv[2];
    }
    if (len &lt; 0) rb_raise(rb_eIndexError, &quot;negative length %ld&quot;, len);
    slen = RSTRING_LEN(str);
    if ((slen &lt; beg) || ((beg &lt; 0) &amp;&amp; (beg + slen &lt; 0))) {
        rb_raise(rb_eIndexError, &quot;index %ld out of string&quot;, beg);
    }
    if (beg &lt; 0) {
        beg += slen;
    }
    assert(beg &gt;= 0);
    assert(beg &lt;= slen);
    if (len &gt; slen - beg) {
        len = slen - beg;
    }
    end = beg + len;
    if (!str_check_byte_pos(str, beg)) {
        rb_raise(rb_eIndexError,
                 &quot;offset %ld does not land on character boundary&quot;, beg);
    }
    if (!str_check_byte_pos(str, end)) {
        rb_raise(rb_eIndexError,
                 &quot;offset %ld does not land on character boundary&quot;, end);
    }
    StringValue(val);
    enc = rb_enc_check(str, val);
    str_modify_keep_cr(str);
    rb_str_splice_0(str, beg, len, val);
    rb_enc_associate(str, enc);
    cr = ENC_CODERANGE_AND(ENC_CODERANGE(str), ENC_CODERANGE(val));
    if (cr != ENC_CODERANGE_BROKEN)
        ENC_CODERANGE_SET(str, cr);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-capitalize" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              capitalize(*options) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string containing the characters in <code>self</code>; the first character is upcased; the remaining characters are downcased:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">capitalize</span>       <span class="ruby-comment"># =&gt; &quot;Hello world!&quot;</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-capitalize-21"><code>String#capitalize!</code></a>.</p>

          <div class="method-source-code" id="capitalize-source">
            <pre>static VALUE
rb_str_capitalize(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_TITLECASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return str;
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }
    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-capitalize-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              capitalize!(*options) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Upcases the first character in <code>self</code>; downcases the remaining characters; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">capitalize!</span>      <span class="ruby-comment"># =&gt; &quot;Hello world!&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;Hello world!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">capitalize!</span>      <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-capitalize"><code>String#capitalize</code></a>.</p>

          <div class="method-source-code" id="capitalize-21-source">
            <pre>static VALUE
rb_str_capitalize_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_TITLECASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-casecmp" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              casecmp(other_string) &rarr; -1, 0, 1, or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Compares <code>self.downcase</code> and <code>other_string.downcase</code>; returns:</p>
<ul><li>
<p>-1 if <code>other_string.downcase</code> is larger.</p>
</li><li>
<p>0 if the two are equal.</p>
</li><li>
<p>1 if <code>other_string.downcase</code> is smaller.</p>
</li><li>
<p><code>nil</code> if the two are incomparable.</p>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">&#39;food&#39;</span>) <span class="ruby-comment"># =&gt; -1</span>
<span class="ruby-string">&#39;food&#39;</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;FOO&#39;</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-string">&#39;FOO&#39;</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>See <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-casecmp-3F"><code>String#casecmp?</code></a>.</p>

          <div class="method-source-code" id="casecmp-source">
            <pre>static VALUE
rb_str_casecmp(VALUE str1, VALUE str2)
{
    VALUE s = rb_check_string_type(str2);
    if (NIL_P(s)) {
        return Qnil;
    }
    return str_casecmp(str1, s);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-casecmp-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              casecmp?(other_string) &rarr; true, false, or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> and <code>other_string</code> are equal after Unicode case folding, otherwise <code>false</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp?</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp?</span>(<span class="ruby-string">&#39;food&#39;</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&#39;food&#39;</span>.<span class="ruby-identifier">casecmp?</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&#39;FOO&#39;</span>.<span class="ruby-identifier">casecmp?</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp?</span>(<span class="ruby-string">&#39;FOO&#39;</span>) <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Returns <code>nil</code> if the two values are incomparable:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">casecmp?</span>(<span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>See <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-casecmp"><code>String#casecmp</code></a>.</p>

          <div class="method-source-code" id="casecmp-3F-source">
            <pre>static VALUE
rb_str_casecmp_p(VALUE str1, VALUE str2)
{
    VALUE s = rb_check_string_type(str2);
    if (NIL_P(s)) {
        return Qnil;
    }
    return str_casecmp_p(str1, s);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-center" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              center(size, pad_string = &#39; &#39;) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a centered copy of <code>self</code>.</p>

<p>If integer argument <code>size</code> is greater than the size (in characters) of <code>self</code>, returns a new string of length <code>size</code> that is a copy of <code>self</code>, centered and padded on both ends with <code>pad_string</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">10</span>)       <span class="ruby-comment"># =&gt; &quot;  hello   &quot;</span>
<span class="ruby-string">&#39;  hello&#39;</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">10</span>)     <span class="ruby-comment"># =&gt; &quot;   hello  &quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">10</span>, <span class="ruby-string">&#39;ab&#39;</span>) <span class="ruby-comment"># =&gt; &quot;abhelloaba&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">10</span>)        <span class="ruby-comment"># =&gt; &quot;   тест   &quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">10</span>)    <span class="ruby-comment"># =&gt; &quot;  こんにちは   &quot;</span>
</pre>

<p>If <code>size</code> is not greater than the size of <code>self</code>, returns a copy of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">5</span>)  <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">center</span>(<span class="ruby-value">1</span>)  <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-ljust"><code>String#ljust</code></a>, <a href="String.html#method-i-rjust"><code>String#rjust</code></a>.</p>

          <div class="method-source-code" id="center-source">
            <pre>static VALUE
rb_str_center(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, &#39;c&#39;);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chars" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              chars &rarr; array_of_characters
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns an array of the characters in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">chars</span>     <span class="ruby-comment"># =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">chars</span>      <span class="ruby-comment"># =&gt; [&quot;т&quot;, &quot;е&quot;, &quot;с&quot;, &quot;т&quot;]</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">chars</span> <span class="ruby-comment"># =&gt; [&quot;こ&quot;, &quot;ん&quot;, &quot;に&quot;, &quot;ち&quot;, &quot;は&quot;]</span>
</pre>

          <div class="method-source-code" id="chars-source">
            <pre>static VALUE
rb_str_chars(VALUE str)
{
    VALUE ary = WANTARRAY(&quot;chars&quot;, rb_str_strlen(str));
    return rb_str_enumerate_chars(str, ary);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chomp" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              chomp(line_sep = $/) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new string copied from <code>self</code>, with trailing characters possibly removed:</p>

<p>When <code>line_sep</code> is <code>&quot;\n&quot;</code>, removes the last one or two characters if they are <code>&quot;\r&quot;</code>, <code>&quot;\n&quot;</code>, or <code>&quot;\r\n&quot;</code> (but not <code>&quot;\n\r&quot;</code>):</p>

<pre class="ruby"><span class="ruby-identifier">$/</span>                    <span class="ruby-comment"># =&gt; &quot;\n&quot;</span>
<span class="ruby-string">&quot;abc\r&quot;</span>.<span class="ruby-identifier">chomp</span>         <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&quot;abc\n&quot;</span>.<span class="ruby-identifier">chomp</span>         <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&quot;abc\r\n&quot;</span>.<span class="ruby-identifier">chomp</span>       <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&quot;abc\n\r&quot;</span>.<span class="ruby-identifier">chomp</span>       <span class="ruby-comment"># =&gt; &quot;abc\n&quot;</span>
<span class="ruby-string">&quot;тест\r\n&quot;</span>.<span class="ruby-identifier">chomp</span>      <span class="ruby-comment"># =&gt; &quot;тест&quot;</span>
<span class="ruby-string">&quot;こんにちは\r\n&quot;</span>.<span class="ruby-identifier">chomp</span>  <span class="ruby-comment"># =&gt; &quot;こんにちは&quot;</span>
</pre>

<p>When <code>line_sep</code> is <code>&#39;&#39;</code> (an empty string), removes multiple trailing occurrences of <code>&quot;\n&quot;</code> or <code>&quot;\r\n&quot;</code> (but not <code>&quot;\r&quot;</code> or <code>&quot;\n\r&quot;</code>):</p>

<pre class="ruby"><span class="ruby-string">&quot;abc\n\n\n&quot;</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;&#39;</span>)           <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&quot;abc\r\n\r\n\r\n&quot;</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;&#39;</span>)     <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&quot;abc\n\n\r\n\r\n\n\n&quot;</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;&#39;</span>) <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&quot;abc\n\r\n\r\n\r&quot;</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;&#39;</span>)     <span class="ruby-comment"># =&gt; &quot;abc\n\r\n\r\n\r&quot;</span>
<span class="ruby-string">&quot;abc\r\r\r&quot;</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;&#39;</span>)           <span class="ruby-comment"># =&gt; &quot;abc\r\r\r&quot;</span>
</pre>

<p>When <code>line_sep</code> is neither <code>&quot;\n&quot;</code> nor <code>&#39;&#39;</code>, removes a single trailing line separator if there is one:</p>

<pre class="ruby"><span class="ruby-string">&#39;abcd&#39;</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;d&#39;</span>)  <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&#39;abcdd&#39;</span>.<span class="ruby-identifier">chomp</span>(<span class="ruby-string">&#39;d&#39;</span>) <span class="ruby-comment"># =&gt; &quot;abcd&quot;</span>
</pre>

          <div class="method-source-code" id="chomp-source">
            <pre>static VALUE
rb_str_chomp(int argc, VALUE *argv, VALUE str)
{
    VALUE rs = chomp_rs(argc, argv);
    if (NIL_P(rs)) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, 0, chompped_length(str, rs));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chomp-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              chomp!(line_sep = $/) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-chomp"><code>String#chomp</code></a>, but modifies <code>self</code> in place; returns <code>nil</code> if no modification made, <code>self</code> otherwise.</p>

          <div class="method-source-code" id="chomp-21-source">
            <pre>static VALUE
rb_str_chomp_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE rs;
    str_modifiable(str);
    if (RSTRING_LEN(str) == 0) return Qnil;
    rs = chomp_rs(argc, argv);
    if (NIL_P(rs)) return Qnil;
    return rb_str_chomp_string(str, rs);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chop" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              chop &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new string copied from <code>self</code>, with trailing characters possibly removed.</p>

<p>Removes <code>&quot;\r\n&quot;</code> if those are the last two characters.</p>

<pre class="ruby"><span class="ruby-string">&quot;abc\r\n&quot;</span>.<span class="ruby-identifier">chop</span>      <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&quot;тест\r\n&quot;</span>.<span class="ruby-identifier">chop</span>     <span class="ruby-comment"># =&gt; &quot;тест&quot;</span>
<span class="ruby-string">&quot;こんにちは\r\n&quot;</span>.<span class="ruby-identifier">chop</span> <span class="ruby-comment"># =&gt; &quot;こんにちは&quot;</span>
</pre>

<p>Otherwise removes the last character if it exists.</p>

<pre class="ruby"><span class="ruby-string">&#39;abcd&#39;</span>.<span class="ruby-identifier">chop</span>     <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">chop</span>     <span class="ruby-comment"># =&gt; &quot;тес&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">chop</span> <span class="ruby-comment"># =&gt; &quot;こんにち&quot;</span>
<span class="ruby-string">&#39;&#39;</span>.<span class="ruby-identifier">chop</span>         <span class="ruby-comment"># =&gt; &quot;&quot;</span>
</pre>

<p>If you only need to remove the newline separator at the end of the string, <a href="String.html#method-i-chomp"><code>String#chomp</code></a> is a better alternative.</p>

          <div class="method-source-code" id="chop-source">
            <pre>static VALUE
rb_str_chop(VALUE str)
{
    return rb_str_subseq(str, 0, chopped_length(str));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chop-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              chop! &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-chop"><code>String#chop</code></a>, but modifies <code>self</code> in place; returns <code>nil</code> if <code>self</code> is empty, <code>self</code> otherwise.</p>

<p>Related: <a href="String.html#method-i-chomp-21"><code>String#chomp!</code></a>.</p>

          <div class="method-source-code" id="chop-21-source">
            <pre>static VALUE
rb_str_chop_bang(VALUE str)
{
    str_modify_keep_cr(str);
    if (RSTRING_LEN(str) &gt; 0) {
        long len;
        len = chopped_length(str);
        STR_SET_LEN(str, len);
        TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
        if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
            ENC_CODERANGE_CLEAR(str);
        }
        return str;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-chr" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              chr &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string containing the first character of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">chr</span>     <span class="ruby-comment"># =&gt; &quot;f&quot;</span>
</pre>

          <div class="method-source-code" id="chr-source">
            <pre>static VALUE
rb_str_chr(VALUE str)
{
    return rb_str_substr(str, 0, 1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-clear" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              clear &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Removes the contents of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span> <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">clear</span>   <span class="ruby-comment"># =&gt; &quot;&quot;</span>
</pre>

          <div class="method-source-code" id="clear-source">
            <pre>static VALUE
rb_str_clear(VALUE str)
{
    str_discard(str);
    STR_SET_EMBED(str);
    STR_SET_EMBED_LEN(str, 0);
    RSTRING_PTR(str)[0] = 0;
    if (rb_enc_asciicompat(STR_ENC_GET(str)))
        ENC_CODERANGE_SET(str, ENC_CODERANGE_7BIT);
    else
        ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-codepoints" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              codepoints &rarr; array_of_integers
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns an array of the codepoints in <code>self</code>; each codepoint is the integer value for a character:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">codepoints</span>     <span class="ruby-comment"># =&gt; [104, 101, 108, 108, 111]</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">codepoints</span>      <span class="ruby-comment"># =&gt; [1090, 1077, 1089, 1090]</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">codepoints</span> <span class="ruby-comment"># =&gt; [12371, 12435, 12395, 12385, 12399]</span>
</pre>

          <div class="method-source-code" id="codepoints-source">
            <pre>static VALUE
rb_str_codepoints(VALUE str)
{
    VALUE ary = WANTARRAY(&quot;codepoints&quot;, rb_str_strlen(str));
    return rb_str_enumerate_codepoints(str, ary);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-concat" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              concat(*objects) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Concatenates each object in <code>objects</code> to <code>self</code> and returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;baz&#39;</span>) <span class="ruby-comment"># =&gt; &quot;foobarbaz&quot;</span>
<span class="ruby-identifier">s</span>                      <span class="ruby-comment"># =&gt; &quot;foobarbaz&quot;</span>
</pre>

<p>For each given object <code>object</code> that is an Integer, the value is considered a codepoint and converted to a character before concatenation:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-value">32</span>, <span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-value">32</span>, <span class="ruby-string">&#39;baz&#39;</span>) <span class="ruby-comment"># =&gt; &quot;foo bar baz&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-3C-3C"><code>String#&lt;&lt;</code></a>, which takes a single argument.</p>

          <div class="method-source-code" id="concat-source">
            <pre>static VALUE
rb_str_concat_multi(int argc, VALUE *argv, VALUE str)
{
    str_modifiable(str);

    if (argc == 1) {
        return rb_str_concat(str, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE arg_str = rb_str_tmp_new(0);
        rb_enc_copy(arg_str, str);
        for (i = 0; i &lt; argc; i++) {
            rb_str_concat(arg_str, argv[i]);
        }
        rb_str_buf_append(str, arg_str);
    }

    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-count" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              count(*selectors) &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the total number of characters in <code>self</code> that are specified by the given <code>selectors</code> (see <a href="character_selectors_rdoc.html#label-Multiple+Character+Selectors">Multiple Character Selectors</a>):</p>

<pre class="ruby"><span class="ruby-identifier">a</span> = <span class="ruby-string">&quot;hello world&quot;</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;lo&quot;</span>                   <span class="ruby-comment">#=&gt; 5</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;lo&quot;</span>, <span class="ruby-string">&quot;o&quot;</span>              <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;hello&quot;</span>, <span class="ruby-string">&quot;^l&quot;</span>          <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-identifier">a</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;ej-m&quot;</span>                 <span class="ruby-comment">#=&gt; 4</span>

<span class="ruby-string">&quot;hello^world&quot;</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;\\^aeiou&quot;</span> <span class="ruby-comment">#=&gt; 4</span>
<span class="ruby-string">&quot;hello-world&quot;</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;a\\-eo&quot;</span>   <span class="ruby-comment">#=&gt; 4</span>

<span class="ruby-identifier">c</span> = <span class="ruby-string">&quot;hello world\\r\\n&quot;</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;\\&quot;</span>                   <span class="ruby-comment">#=&gt; 2</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;\\A&quot;</span>                  <span class="ruby-comment">#=&gt; 0</span>
<span class="ruby-identifier">c</span>.<span class="ruby-identifier">count</span> <span class="ruby-string">&quot;X-\\w&quot;</span>                <span class="ruby-comment">#=&gt; 3</span>
</pre>

          <div class="method-source-code" id="count-source">
            <pre>static VALUE
rb_str_count(int argc, VALUE *argv, VALUE str)
{
    char table[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    VALUE del = 0, nodel = 0, tstr;
    char *s, *send;
    int i;
    int ascompat;
    size_t n = 0;

    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);

    tstr = argv[0];
    StringValue(tstr);
    enc = rb_enc_check(str, tstr);
    if (argc == 1) {
        const char *ptstr;
        if (RSTRING_LEN(tstr) == 1 &amp;&amp; rb_enc_asciicompat(enc) &amp;&amp;
            (ptstr = RSTRING_PTR(tstr),
             ONIGENC_IS_ALLOWED_REVERSE_MATCH(enc, (const unsigned char *)ptstr, (const unsigned char *)ptstr+1)) &amp;&amp;
            !is_broken_string(str)) {
            int clen;
            unsigned char c = rb_enc_codepoint_len(ptstr, ptstr+1, &amp;clen, enc);

            s = RSTRING_PTR(str);
            if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
            send = RSTRING_END(str);
            while (s &lt; send) {
                if (*(unsigned char*)s++ == c) n++;
            }
            return SIZET2NUM(n);
        }
    }

    tr_setup_table(tstr, table, TRUE, &amp;del, &amp;nodel, enc);
    for (i=1; i&lt;argc; i++) {
        tstr = argv[i];
        StringValue(tstr);
        enc = rb_enc_check(str, tstr);
        tr_setup_table(tstr, table, FALSE, &amp;del, &amp;nodel, enc);
    }

    s = RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return INT2FIX(0);
    send = RSTRING_END(str);
    ascompat = rb_enc_asciicompat(enc);
    while (s &lt; send) {
        unsigned int c;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
            if (table[c]) {
                n++;
            }
            s++;
        }
        else {
            int clen;
            c = rb_enc_codepoint_len(s, send, &amp;clen, enc);
            if (tr_find(c, table, del, nodel)) {
                n++;
            }
            s += clen;
        }
    }

    return SIZET2NUM(n);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-crypt" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              crypt(salt_str) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the string generated by calling <code>crypt(3)</code> standard library function with <code>str</code> and <code>salt_str</code>, in this order, as its arguments.  Please do not use this method any longer.  It is legacy; provided only for backward compatibility with ruby scripts in earlier days.  It is bad to use in contemporary programs for several reasons:</p>
<ul><li>
<p>Behaviour of C’s <code>crypt(3)</code> depends on the OS it is run.  The generated string lacks data portability.</p>
</li><li>
<p>On some OSes such as Mac OS, <code>crypt(3)</code> never fails (i.e. silently ends up in unexpected results).</p>
</li><li>
<p>On some OSes such as Mac OS, <code>crypt(3)</code> is not thread safe.</p>
</li><li>
<p>So-called “traditional” usage of <code>crypt(3)</code> is very very very weak.  According to its manpage, Linux’s traditional <code>crypt(3)</code> output has only 2**56 variations; too easy to brute force today.  And this is the default behaviour.</p>
</li><li>
<p>In order to make things robust some OSes implement so-called “modular” usage. To go through, you have to do a complex build-up of the <code>salt_str</code> parameter, by hand. Failure in generation of a proper salt string tends not to yield any errors; typos in parameters are normally not detectable.</p>
<ul><li>
<p>For instance, in the following example, the second invocation of <a href="String.html#method-i-crypt"><code>String#crypt</code></a> is wrong; it has a typo in “round=” (lacks “s”).  However the call does not fail and something unexpected is generated.</p>

<pre class="ruby"><span class="ruby-string">&quot;foo&quot;</span>.<span class="ruby-identifier">crypt</span>(<span class="ruby-string">&quot;$5$rounds=1000$salt$&quot;</span>) <span class="ruby-comment"># OK, proper usage</span>
<span class="ruby-string">&quot;foo&quot;</span>.<span class="ruby-identifier">crypt</span>(<span class="ruby-string">&quot;$5$round=1000$salt$&quot;</span>)  <span class="ruby-comment"># Typo not detected</span>
</pre>
</li></ul>
</li><li>
<p>Even in the “modular” mode, some hash functions are considered archaic and no longer recommended at all; for instance module <code>$1$</code> is officially abandoned by its author: see <a href="http://phk.freebsd.dk/sagas/md5crypt_eol">phk.freebsd.dk/sagas/md5crypt_eol</a>/ .  For another instance module <code>$3$</code> is considered completely broken: see the manpage of FreeBSD.</p>
</li><li>
<p>On some OS such as Mac OS, there is no modular mode. Yet, as written above, <code>crypt(3)</code> on Mac OS never fails. This means even if you build up a proper salt string it generates a traditional DES hash anyways, and there is no way for you to be aware of.</p>

<pre class="ruby"><span class="ruby-string">&quot;foo&quot;</span>.<span class="ruby-identifier">crypt</span>(<span class="ruby-string">&quot;$5$rounds=1000$salt$&quot;</span>) <span class="ruby-comment"># =&gt; &quot;$5fNPQMxC5j6.&quot;</span>
</pre>
</li></ul>

<p>If for some reason you cannot migrate to other secure contemporary password hashing algorithms, install the string-crypt gem and <code>require &#39;string/crypt&#39;</code> to continue using it.</p>

          <div class="method-source-code" id="crypt-source">
            <pre>static VALUE
rb_str_crypt(VALUE str, VALUE salt)
{
#ifdef HAVE_CRYPT_R
    VALUE databuf;
    struct crypt_data *data;
#   define CRYPT_END() ALLOCV_END(databuf)
#else
    extern char *crypt(const char *, const char *);
#   define CRYPT_END() rb_nativethread_lock_unlock(&amp;crypt_mutex.lock)
#endif
    VALUE result;
    const char *s, *saltp;
    char *res;
#ifdef BROKEN_CRYPT
    char salt_8bit_clean[3];
#endif

    StringValue(salt);
    mustnot_wchar(str);
    mustnot_wchar(salt);
    s = StringValueCStr(str);
    saltp = RSTRING_PTR(salt);
    if (RSTRING_LEN(salt) &lt; 2 || !saltp[0] || !saltp[1]) {
        rb_raise(rb_eArgError, &quot;salt too short (need &gt;=2 bytes)&quot;);
    }

#ifdef BROKEN_CRYPT
    if (!ISASCII((unsigned char)saltp[0]) || !ISASCII((unsigned char)saltp[1])) {
        salt_8bit_clean[0] = saltp[0] &amp; 0x7f;
        salt_8bit_clean[1] = saltp[1] &amp; 0x7f;
        salt_8bit_clean[2] = &#39;\0&#39;;
        saltp = salt_8bit_clean;
    }
#endif
#ifdef HAVE_CRYPT_R
    data = ALLOCV(databuf, sizeof(struct crypt_data));
# ifdef HAVE_STRUCT_CRYPT_DATA_INITIALIZED
    data-&gt;initialized = 0;
# endif
    res = crypt_r(s, saltp, data);
#else
    crypt_mutex_initialize();
    rb_nativethread_lock_lock(&amp;crypt_mutex.lock);
    res = crypt(s, saltp);
#endif
    if (!res) {
        int err = errno;
        CRYPT_END();
        rb_syserr_fail(err, &quot;crypt&quot;);
    }
    result = rb_str_new_cstr(res);
    CRYPT_END();
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-dedup" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              -string &rarr; frozen_string
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a frozen, possibly pre-existing copy of the string.</p>

<p>The returned String will be deduplicated as long as it does not have any instance variables set on it and is not a <a href="String.html"><code>String</code></a> subclass.</p>

<p><a href="String.html#method-i-dedup"><code>String#dedup</code></a> is an alias for <a href="String.html#method-i-2D-40"><code>String#-@</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-2D-40">-@</a>
        </div>
      </div>

      <div id="method-i-delete" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              delete(*selectors) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with characters specified by <code>selectors</code> removed (see <a href="character_selectors_rdoc.html#label-Multiple+Character+Selectors">Multiple Character Selectors</a>):</p>

<pre class="ruby"><span class="ruby-string">&quot;hello&quot;</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">&quot;l&quot;</span>,<span class="ruby-string">&quot;lo&quot;</span>        <span class="ruby-comment">#=&gt; &quot;heo&quot;</span>
<span class="ruby-string">&quot;hello&quot;</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">&quot;lo&quot;</span>            <span class="ruby-comment">#=&gt; &quot;he&quot;</span>
<span class="ruby-string">&quot;hello&quot;</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">&quot;aeiou&quot;</span>, <span class="ruby-string">&quot;^e&quot;</span>   <span class="ruby-comment">#=&gt; &quot;hell&quot;</span>
<span class="ruby-string">&quot;hello&quot;</span>.<span class="ruby-identifier">delete</span> <span class="ruby-string">&quot;ej-m&quot;</span>          <span class="ruby-comment">#=&gt; &quot;ho&quot;</span>
</pre>

          <div class="method-source-code" id="delete-source">
            <pre>static VALUE
rb_str_delete(int argc, VALUE *argv, VALUE str)
{
    str = str_duplicate(rb_cString, str);
    rb_str_delete_bang(argc, argv, str);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              delete!(*selectors) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-delete"><code>String#delete</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p>

          <div class="method-source-code" id="delete-21-source">
            <pre>static VALUE
rb_str_delete_bang(int argc, VALUE *argv, VALUE str)
{
    char squeez[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    char *s, *send, *t;
    VALUE del = 0, nodel = 0;
    int modify = 0;
    int i, ascompat, cr;

    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return Qnil;
    rb_check_arity(argc, 1, UNLIMITED_ARGUMENTS);
    for (i=0; i&lt;argc; i++) {
        VALUE s = argv[i];

        StringValue(s);
        enc = rb_enc_check(str, s);
        tr_setup_table(s, squeez, i==0, &amp;del, &amp;nodel, enc);
    }

    str_modify_keep_cr(str);
    ascompat = rb_enc_asciicompat(enc);
    s = t = RSTRING_PTR(str);
    send = RSTRING_END(str);
    cr = ascompat ? ENC_CODERANGE_7BIT : ENC_CODERANGE_VALID;
    while (s &lt; send) {
        unsigned int c;
        int clen;

        if (ascompat &amp;&amp; (c = *(unsigned char*)s) &lt; 0x80) {
            if (squeez[c]) {
                modify = 1;
            }
            else {
                if (t != s) *t = c;
                t++;
            }
            s++;
        }
        else {
            c = rb_enc_codepoint_len(s, send, &amp;clen, enc);

            if (tr_find(c, squeez, del, nodel)) {
                modify = 1;
            }
            else {
                if (t != s) rb_enc_mbcput(c, t, enc);
                t += clen;
                if (cr == ENC_CODERANGE_7BIT) cr = ENC_CODERANGE_VALID;
            }
            s += clen;
        }
    }
    TERM_FILL(t, TERM_LEN(str));
    STR_SET_LEN(str, t - RSTRING_PTR(str));
    ENC_CODERANGE_SET(str, cr);

    if (modify) return str;
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_prefix" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              delete_prefix(prefix) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with leading substring <code>prefix</code> removed:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">delete_prefix</span>(<span class="ruby-string">&#39;hel&#39;</span>)      <span class="ruby-comment"># =&gt; &quot;lo&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">delete_prefix</span>(<span class="ruby-string">&#39;llo&#39;</span>)      <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">delete_prefix</span>(<span class="ruby-string">&#39;те&#39;</span>)        <span class="ruby-comment"># =&gt; &quot;ст&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">delete_prefix</span>(<span class="ruby-string">&#39;こん&#39;</span>)  <span class="ruby-comment"># =&gt; &quot;にちは&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-delete_prefix-21"><code>String#delete_prefix!</code></a>, <a href="String.html#method-i-delete_suffix"><code>String#delete_suffix</code></a>.</p>

          <div class="method-source-code" id="delete_prefix-source">
            <pre>static VALUE
rb_str_delete_prefix(VALUE str, VALUE prefix)
{
    long prefixlen;

    prefixlen = deleted_prefix_length(str, prefix);
    if (prefixlen &lt;= 0) return str_duplicate(rb_cString, str);

    return rb_str_subseq(str, prefixlen, RSTRING_LEN(str) - prefixlen);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_prefix-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              delete_prefix!(prefix) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-delete_prefix"><code>String#delete_prefix</code></a>, except that <code>self</code> is modified in place. Returns <code>self</code> if the prefix is removed, <code>nil</code> otherwise.</p>

          <div class="method-source-code" id="delete_prefix-21-source">
            <pre>static VALUE
rb_str_delete_prefix_bang(VALUE str, VALUE prefix)
{
    long prefixlen;
    str_modify_keep_cr(str);

    prefixlen = deleted_prefix_length(str, prefix);
    if (prefixlen &lt;= 0) return Qnil;

    return rb_str_drop_bytes(str, prefixlen);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_suffix" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              delete_suffix(suffix) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with trailing substring <code>suffix</code> removed:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">delete_suffix</span>(<span class="ruby-string">&#39;llo&#39;</span>)      <span class="ruby-comment"># =&gt; &quot;he&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">delete_suffix</span>(<span class="ruby-string">&#39;hel&#39;</span>)      <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">delete_suffix</span>(<span class="ruby-string">&#39;ст&#39;</span>)        <span class="ruby-comment"># =&gt; &quot;те&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">delete_suffix</span>(<span class="ruby-string">&#39;ちは&#39;</span>)  <span class="ruby-comment"># =&gt; &quot;こんに&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-delete_suffix-21"><code>String#delete_suffix!</code></a>, <a href="String.html#method-i-delete_prefix"><code>String#delete_prefix</code></a>.</p>

          <div class="method-source-code" id="delete_suffix-source">
            <pre>static VALUE
rb_str_delete_suffix(VALUE str, VALUE suffix)
{
    long suffixlen;

    suffixlen = deleted_suffix_length(str, suffix);
    if (suffixlen &lt;= 0) return str_duplicate(rb_cString, str);

    return rb_str_subseq(str, 0, RSTRING_LEN(str) - suffixlen);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-delete_suffix-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              delete_suffix!(suffix) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-delete_suffix"><code>String#delete_suffix</code></a>, except that <code>self</code> is modified in place. Returns <code>self</code> if the suffix is removed, <code>nil</code> otherwise.</p>

          <div class="method-source-code" id="delete_suffix-21-source">
            <pre>static VALUE
rb_str_delete_suffix_bang(VALUE str, VALUE suffix)
{
    long olen, suffixlen, len;
    str_modifiable(str);

    suffixlen = deleted_suffix_length(str, suffix);
    if (suffixlen &lt;= 0) return Qnil;

    olen = RSTRING_LEN(str);
    str_modify_keep_cr(str);
    len = olen - suffixlen;
    STR_SET_LEN(str, len);
    TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
    if (ENC_CODERANGE(str) != ENC_CODERANGE_7BIT) {
        ENC_CODERANGE_CLEAR(str);
    }
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-downcase" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              downcase(*options) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string containing the downcased characters in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;Hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;Hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">downcase</span>         <span class="ruby-comment"># =&gt; &quot;hello world!&quot;</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-downcase-21"><code>String#downcase!</code></a>, <a href="String.html#method-i-upcase"><code>String#upcase</code></a>, <a href="String.html#method-i-upcase-21"><code>String#upcase!</code></a>.</p>

          <div class="method-source-code" id="downcase-source">
            <pre>static VALUE
rb_str_downcase(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_DOWNCASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        ret = rb_str_new(RSTRING_PTR(str), RSTRING_LEN(str));
        str_enc_copy(ret, str);
        downcase_single(ret);
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }

    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-downcase-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              downcase!(*options) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Downcases the characters in <code>self</code>; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;Hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;Hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">downcase!</span>        <span class="ruby-comment"># =&gt; &quot;hello world!&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;hello world!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">downcase!</span>        <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-downcase"><code>String#downcase</code></a>, <a href="String.html#method-i-upcase"><code>String#upcase</code></a>, <a href="String.html#method-i-upcase-21"><code>String#upcase!</code></a>.</p>

          <div class="method-source-code" id="downcase-21-source">
            <pre>static VALUE
rb_str_downcase_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_DOWNCASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        if (downcase_single(str))
            flags |= ONIGENC_CASE_MODIFIED;
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-dump" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              dump &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a printable version of <code>self</code>, enclosed in double-quotes, with special characters escaped, and with non-printing characters replaced by hexadecimal notation:</p>

<pre class="ruby"><span class="ruby-string">&quot;hello \n &#39;&#39;&quot;</span>.<span class="ruby-identifier">dump</span>    <span class="ruby-comment"># =&gt; &quot;\&quot;hello \\n &#39;&#39;\&quot;&quot;</span>
<span class="ruby-string">&quot;\f\x00\xff\\\&quot;&quot;</span>.<span class="ruby-identifier">dump</span> <span class="ruby-comment"># =&gt; &quot;\&quot;\\f\\x00\\xFF\\\\\\\&quot;\&quot;&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-undump"><code>String#undump</code></a> (inverse of <a href="String.html#method-i-dump"><code>String#dump</code></a>).</p>

          <div class="method-source-code" id="dump-source">
            <pre>VALUE
rb_str_dump(VALUE str)
{
    int encidx = rb_enc_get_index(str);
    rb_encoding *enc = rb_enc_from_index(encidx);
    long len;
    const char *p, *pend;
    char *q, *qend;
    VALUE result;
    int u8 = (encidx == rb_utf8_encindex());
    static const char nonascii_suffix[] = &quot;.dup.force_encoding(\&quot;%s\&quot;)&quot;;

    len = 2;                    /* &quot;&quot; */
    if (!rb_enc_asciicompat(enc)) {
        len += strlen(nonascii_suffix) - rb_strlen_lit(&quot;%s&quot;);
        len += strlen(enc-&gt;name);
    }

    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    while (p &lt; pend) {
        int clen;
        unsigned char c = *p++;

        switch (c) {
          case &#39;&quot;&#39;:  case &#39;\\&#39;:
          case &#39;\n&#39;: case &#39;\r&#39;:
          case &#39;\t&#39;: case &#39;\f&#39;:
          case &#39;\013&#39;: case &#39;\010&#39;: case &#39;\007&#39;: case &#39;\033&#39;:
            clen = 2;
            break;

          case &#39;#&#39;:
            clen = IS_EVSTR(p, pend) ? 2 : 1;
            break;

          default:
            if (ISPRINT(c)) {
                clen = 1;
            }
            else {
                if (u8 &amp;&amp; c &gt; 0x7F) {   /* \u notation */
                    int n = rb_enc_precise_mbclen(p-1, pend, enc);
                    if (MBCLEN_CHARFOUND_P(n)) {
                        unsigned int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
                        if (cc &lt;= 0xFFFF)
                            clen = 6;  /* \uXXXX */
                        else if (cc &lt;= 0xFFFFF)
                            clen = 9;  /* \u{XXXXX} */
                        else
                            clen = 10; /* \u{XXXXXX} */
                        p += MBCLEN_CHARFOUND_LEN(n)-1;
                        break;
                    }
                }
                clen = 4;       /* \xNN */
            }
            break;
        }

        if (clen &gt; LONG_MAX - len) {
            rb_raise(rb_eRuntimeError, &quot;string size too big&quot;);
        }
        len += clen;
    }

    result = rb_str_new(0, len);
    p = RSTRING_PTR(str); pend = p + RSTRING_LEN(str);
    q = RSTRING_PTR(result); qend = q + len + 1;

    *q++ = &#39;&quot;&#39;;
    while (p &lt; pend) {
        unsigned char c = *p++;

        if (c == &#39;&quot;&#39; || c == &#39;\\&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = c;
        }
        else if (c == &#39;#&#39;) {
            if (IS_EVSTR(p, pend)) *q++ = &#39;\\&#39;;
            *q++ = &#39;#&#39;;
        }
        else if (c == &#39;\n&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;n&#39;;
        }
        else if (c == &#39;\r&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;r&#39;;
        }
        else if (c == &#39;\t&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;t&#39;;
        }
        else if (c == &#39;\f&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;f&#39;;
        }
        else if (c == &#39;\013&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;v&#39;;
        }
        else if (c == &#39;\010&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;b&#39;;
        }
        else if (c == &#39;\007&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;a&#39;;
        }
        else if (c == &#39;\033&#39;) {
            *q++ = &#39;\\&#39;;
            *q++ = &#39;e&#39;;
        }
        else if (ISPRINT(c)) {
            *q++ = c;
        }
        else {
            *q++ = &#39;\\&#39;;
            if (u8) {
                int n = rb_enc_precise_mbclen(p-1, pend, enc) - 1;
                if (MBCLEN_CHARFOUND_P(n)) {
                    int cc = rb_enc_mbc_to_codepoint(p-1, pend, enc);
                    p += n;
                    if (cc &lt;= 0xFFFF)
                        snprintf(q, qend-q, &quot;u%04X&quot;, cc);    /* \uXXXX */
                    else
                        snprintf(q, qend-q, &quot;u{%X}&quot;, cc);  /* \u{XXXXX} or \u{XXXXXX} */
                    q += strlen(q);
                    continue;
                }
            }
            snprintf(q, qend-q, &quot;x%02X&quot;, c);
            q += 3;
        }
    }
    *q++ = &#39;&quot;&#39;;
    *q = &#39;\0&#39;;
    if (!rb_enc_asciicompat(enc)) {
        snprintf(q, qend-q, nonascii_suffix, enc-&gt;name);
        encidx = rb_ascii8bit_encindex();
    }
    /* result from dump is ASCII */
    rb_enc_associate_index(result, encidx);
    ENC_CODERANGE_SET(result, ENC_CODERANGE_7BIT);
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each_byte" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              each_byte {|byte| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              each_byte               &rarr; enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Calls the given block with each successive byte from <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">each_byte</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">byte</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">byte</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">each_byte</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">byte</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">byte</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">each_byte</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">byte</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">byte</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
</pre>

<p>Output:</p>

<pre>104 101 108 108 111
209 130 208 181 209 129 209 130
227 129 147 227 130 147 227 129 171 227 129 161 227 129 175</pre>

<p>Returns an enumerator if no block is given.</p>

          <div class="method-source-code" id="each_byte-source">
            <pre>static VALUE
rb_str_each_byte(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_byte_size);
    return rb_str_enumerate_bytes(str, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each_char" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              each_char {|c| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              each_char            &rarr; enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Calls the given block with each successive character from <code>self</code>; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">each_char</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">char</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">char</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">each_char</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">char</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">char</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">each_char</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">char</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">char</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">h</span> <span class="ruby-identifier">e</span> <span class="ruby-identifier">l</span> <span class="ruby-identifier">l</span> <span class="ruby-identifier">o</span>
<span class="ruby-identifier">т</span> <span class="ruby-identifier">е</span> <span class="ruby-identifier">с</span> <span class="ruby-identifier">т</span>
<span class="ruby-identifier">こ</span> <span class="ruby-identifier">ん</span> <span class="ruby-identifier">に</span> <span class="ruby-identifier">ち</span> <span class="ruby-identifier">は</span>
</pre>

<p>Returns an enumerator if no block is given.</p>

          <div class="method-source-code" id="each_char-source">
            <pre>static VALUE
rb_str_each_char(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_char_size);
    return rb_str_enumerate_chars(str, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each_codepoint" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              each_codepoint {|integer| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              each_codepoint                  &rarr; enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Calls the given block with each successive codepoint from <code>self</code>; each codepoint is the integer value for a character; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">each_codepoint</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">codepoint</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">codepoint</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">each_codepoint</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">codepoint</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">codepoint</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">each_codepoint</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">codepoint</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">codepoint</span>, <span class="ruby-string">&#39; &#39;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
</pre>

<p>Output:</p>

<pre>104 101 108 108 111
1090 1077 1089 1090
12371 12435 12395 12385 12399</pre>

<p>Returns an enumerator if no block is given.</p>

          <div class="method-source-code" id="each_codepoint-source">
            <pre>static VALUE
rb_str_each_codepoint(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_char_size);
    return rb_str_enumerate_codepoints(str, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each_grapheme_cluster" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              each_grapheme_cluster {|gc| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              each_grapheme_cluster             &rarr; enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Calls the given block with each successive grapheme cluster from <code>self</code> (see <a href="https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">Unicode Grapheme Cluster Boundaries</a>); returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;\u0061\u0308-pqr-\u0062\u0308-xyz-\u0063\u0308&quot;</span> <span class="ruby-comment"># =&gt; &quot;ä-pqr-b̈-xyz-c̈&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">each_grapheme_cluster</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">gc</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">gc</span>, <span class="ruby-string">&#39; &#39;</span> }
</pre>

<p>Output:</p>

<pre>ä - p q r - b̈ - x y z - c̈</pre>

<p>Returns an enumerator if no block is given.</p>

          <div class="method-source-code" id="each_grapheme_cluster-source">
            <pre>static VALUE
rb_str_each_grapheme_cluster(VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, 0, 0, rb_str_each_grapheme_cluster_size);
    return rb_str_enumerate_grapheme_clusters(str, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-each_line" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              each_line(line_sep = $/, chomp: false) {|substring| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              each_line(line_sep = $/, chomp: false)                    &rarr; enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>With a block given, forms the substrings (“lines”) that are the result of splitting <code>self</code> at each occurrence of the given line separator <code>line_sep</code>; passes each line to the block; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-identifier">&lt;&lt;~EOT</span>
<span class="ruby-value">This is the first line.
This is line two.

This is line four.
This is line five.
</span><span class="ruby-identifier">EOT</span>

<span class="ruby-identifier">s</span>.<span class="ruby-identifier">each_line</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">line</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-string">&quot;This is the first line.\n&quot;</span>
<span class="ruby-string">&quot;This is line two.\n&quot;</span>
<span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-string">&quot;This is line four.\n&quot;</span>
<span class="ruby-string">&quot;This is line five.\n&quot;</span>
</pre>

<p>With a different <code>line_sep</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span>.<span class="ruby-identifier">each_line</span>(<span class="ruby-string">&#39; is &#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">line</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-string">&quot;This is &quot;</span>
<span class="ruby-string">&quot;the first line.\nThis is &quot;</span>
<span class="ruby-string">&quot;line two.\n\nThis is &quot;</span>
<span class="ruby-string">&quot;line four.\nThis is &quot;</span>
<span class="ruby-string">&quot;line five.\n&quot;</span>
</pre>

<p>With <code>chomp</code> as <code>true</code>, removes the trailing <code>line_sep</code> from each line:</p>

<pre class="ruby"><span class="ruby-identifier">s</span>.<span class="ruby-identifier">each_line</span>(<span class="ruby-value">chomp:</span> <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">line</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-string">&quot;This is the first line.&quot;</span>
<span class="ruby-string">&quot;This is line two.&quot;</span>
<span class="ruby-string">&quot;&quot;</span>
<span class="ruby-string">&quot;This is line four.&quot;</span>
<span class="ruby-string">&quot;This is line five.&quot;</span>
</pre>

<p>With an empty string as <code>line_sep</code>, forms and passes “paragraphs” by splitting at each occurrence of two or more newlines:</p>

<pre class="ruby"><span class="ruby-identifier">s</span>.<span class="ruby-identifier">each_line</span>(<span class="ruby-string">&#39;&#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">line</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">line</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-string">&quot;This is the first line.\nThis is line two.\n\n&quot;</span>
<span class="ruby-string">&quot;This is line four.\nThis is line five.\n&quot;</span>
</pre>

<p>With no block given, returns an enumerator.</p>

          <div class="method-source-code" id="each_line-source">
            <pre>static VALUE
rb_str_each_line(int argc, VALUE *argv, VALUE str)
{
    RETURN_SIZED_ENUMERATOR(str, argc, argv, 0);
    return rb_str_enumerate_lines(argc, argv, str, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-empty-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              empty? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if the length of <code>self</code> is zero, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-string">&quot;hello&quot;</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&quot; &quot;</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&quot;&quot;</span>.<span class="ruby-identifier">empty?</span> <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="empty-3F-source">
            <pre>static VALUE
rb_str_empty(VALUE str)
{
    return RBOOL(RSTRING_LEN(str) == 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-encode" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              encode(dst_encoding = Encoding.default_internal, **enc_opts) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              encode(dst_encoding, src_encoding, **enc_opts)   &rarr; string
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> transcoded as determined by <code>dst_encoding</code>. By default, raises an exception if <code>self</code> contains an invalid byte or a character not defined in <code>dst_encoding</code>; that behavior may be modified by encoding options; see below.</p>

<p>With no arguments:</p>
<ul><li>
<p>Uses the same encoding if <code>Encoding.default_internal</code> is <code>nil</code> (the default):</p>

<pre class="ruby"><span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">default_internal</span> <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;Ruby\x99&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&#39;Windows-1252&#39;</span>)
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>                <span class="ruby-comment"># =&gt; #&lt;Encoding:Windows-1252&gt;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">bytes</span>                   <span class="ruby-comment"># =&gt; [82, 117, 98, 121, 153]</span>
<span class="ruby-identifier">t</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">encode</span>              <span class="ruby-comment"># =&gt; &quot;Ruby\x99&quot;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">encoding</span>                <span class="ruby-comment"># =&gt; #&lt;Encoding:Windows-1252&gt;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">bytes</span>                   <span class="ruby-comment"># =&gt; [82, 117, 98, 121, 226, 132, 162]</span>
</pre>
</li><li>
<p>Otherwise, uses the encoding <code>Encoding.default_internal</code>:</p>

<pre class="ruby"><span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">default_internal</span> = <span class="ruby-string">&#39;UTF-8&#39;</span>
<span class="ruby-identifier">t</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">encode</span>              <span class="ruby-comment"># =&gt; &quot;Ruby™&quot;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">encoding</span>                <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
</pre>
</li></ul>

<p>With only argument <code>dst_encoding</code> given, uses that encoding:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;Ruby\x99&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&#39;Windows-1252&#39;</span>)
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>            <span class="ruby-comment"># =&gt; #&lt;Encoding:Windows-1252&gt;</span>
<span class="ruby-identifier">t</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-string">&#39;UTF-8&#39;</span>) <span class="ruby-comment"># =&gt; &quot;Ruby™&quot;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">encoding</span>            <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
</pre>

<p>With arguments <code>dst_encoding</code> and <code>src_encoding</code> given, interprets <code>self</code> using <code>src_encoding</code>, encodes the new string using <code>dst_encoding</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;Ruby\x99&quot;</span>
<span class="ruby-identifier">t</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-string">&#39;UTF-8&#39;</span>, <span class="ruby-string">&#39;Windows-1252&#39;</span>) <span class="ruby-comment"># =&gt; &quot;Ruby™&quot;</span>
<span class="ruby-identifier">t</span>.<span class="ruby-identifier">encoding</span>                            <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
</pre>

<p>Optional keyword arguments <code>enc_opts</code> specify encoding options; see <a href="encodings_rdoc.html#label-Encoding+Options">Encoding Options</a>.</p>

          <div class="method-source-code" id="encode-source">
            <pre><span class="ruby-comment"># File transcode.rdoc, line 48</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">encode</span>(<span class="ruby-identifier">dst_encoding</span> = <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">default_internal</span>, <span class="ruby-operator">**</span><span class="ruby-identifier">enc_opts</span>)
  <span class="ruby-comment"># Pseudo code</span>
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">str_encode</span>(<span class="ruby-operator">...</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-encode-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              encode!(dst_encoding = Encoding.default_internal, **enc_opts) &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              encode!(dst_encoding, src_encoding, **enc_opts)   &rarr; self
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-encode"><code>encode</code></a>, but applies encoding changes to <code>self</code>; returns <code>self</code>.</p>

          <div class="method-source-code" id="encode-21-source">
            <pre>static VALUE
str_encode_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE newstr;
    int encidx;

    rb_check_frozen(str);

    newstr = str;
    encidx = str_transcode(argc, argv, &amp;newstr);

    if (encidx &lt; 0) return str;
    if (newstr == str) {
        rb_enc_associate_index(str, encidx);
        return str;
    }
    rb_str_shared_replace(str, newstr);
    return str_encode_associate(str, encidx);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-encoding" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              encoding   &rarr; encoding
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the <a href="Encoding.html"><code>Encoding</code></a> object that represents the encoding of obj.</p>

          <div class="method-source-code" id="encoding-source">
            <pre>VALUE
rb_obj_encoding(VALUE obj)
{
    int idx = rb_enc_get_index(obj);
    if (idx &lt; 0) {
        rb_raise(rb_eTypeError, &quot;unknown encoding&quot;);
    }
    return rb_enc_from_encoding_index(idx &amp; ENC_INDEX_MASK);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-end_with-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              end_with?(*strings) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns whether <code>self</code> ends with any of the given <code>strings</code>.</p>

<p>Returns <code>true</code> if any given string matches the end, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">&#39;ello&#39;</span>)               <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">&#39;heaven&#39;</span>, <span class="ruby-string">&#39;ello&#39;</span>)     <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">&#39;heaven&#39;</span>, <span class="ruby-string">&#39;paradise&#39;</span>) <span class="ruby-comment">#=&gt; false</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">&#39;т&#39;</span>)                   <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">end_with?</span>(<span class="ruby-string">&#39;は&#39;</span>)              <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Related: <a href="String.html#method-i-start_with-3F"><code>String#start_with?</code></a>.</p>

          <div class="method-source-code" id="end_with-3F-source">
            <pre>static VALUE
rb_str_end_with(int argc, VALUE *argv, VALUE str)
{
    int i;
    char *p, *s, *e;
    rb_encoding *enc;

    for (i=0; i&lt;argc; i++) {
        VALUE tmp = argv[i];
        long slen, tlen;
        StringValue(tmp);
        enc = rb_enc_check(str, tmp);
        if ((tlen = RSTRING_LEN(tmp)) == 0) return Qtrue;
        if ((slen = RSTRING_LEN(str)) &lt; tlen) continue;
        p = RSTRING_PTR(str);
        e = p + slen;
        s = e - tlen;
        if (rb_enc_left_char_head(p, s, e, enc) != s)
            continue;
        if (memcmp(s, RSTRING_PTR(tmp), RSTRING_LEN(tmp)) == 0)
            return Qtrue;
    }
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-eql-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              eql?(object) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>object</code> has the same length and content; as <code>self</code>; <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&#39;foo&#39;</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&#39;food&#39;</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&#39;FOO&#39;</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Returns <code>false</code> if the two strings’ encodings are not compatible:</p>

<pre class="ruby"><span class="ruby-string">&quot;\u{e4 f6 fc}&quot;</span>.<span class="ruby-identifier">encode</span>(<span class="ruby-string">&quot;ISO-8859-1&quot;</span>).<span class="ruby-identifier">eql?</span>(<span class="ruby-string">&quot;\u{c4 d6 dc}&quot;</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="eql-3F-source">
            <pre>MJIT_FUNC_EXPORTED VALUE
rb_str_eql(VALUE str1, VALUE str2)
{
    if (str1 == str2) return Qtrue;
    if (!RB_TYPE_P(str2, T_STRING)) return Qfalse;
    return rb_str_eql_internal(str1, str2);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-force_encoding" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              force_encoding(encoding) &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Changes the encoding of <code>self</code> to <code>encoding</code>, which may be a string encoding name or an <a href="Encoding.html"><code>Encoding</code></a> object; returns self:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;łał&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">bytes</span>                   <span class="ruby-comment"># =&gt; [197, 130, 97, 197, 130]</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>                <span class="ruby-comment"># =&gt; #&lt;Encoding:UTF-8&gt;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&#39;ascii&#39;</span>) <span class="ruby-comment"># =&gt; &quot;\xC5\x82a\xC5\x82&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">encoding</span>                <span class="ruby-comment"># =&gt; #&lt;Encoding:US-ASCII&gt;</span>
</pre>

<p>Does not change the underlying bytes:</p>

<pre class="ruby"><span class="ruby-identifier">s</span>.<span class="ruby-identifier">bytes</span>                   <span class="ruby-comment"># =&gt; [197, 130, 97, 197, 130]</span>
</pre>

<p>Makes the change even if the given <code>encoding</code> is invalid for <code>self</code> (as is the change above):</p>

<pre class="ruby"><span class="ruby-identifier">s</span>.<span class="ruby-identifier">valid_encoding?</span>                 <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-constant">Encoding</span><span class="ruby-operator">::</span><span class="ruby-constant">UTF_8</span>) <span class="ruby-comment"># =&gt; &quot;łał&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">valid_encoding?</span>                 <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="force_encoding-source">
            <pre>static VALUE
rb_str_force_encoding(VALUE str, VALUE enc)
{
    str_modifiable(str);
    rb_enc_associate(str, rb_to_encoding(enc));
    ENC_CODERANGE_CLEAR(str);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-freeze" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">freeze</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          

          <div class="method-source-code" id="freeze-source">
            <pre>VALUE
rb_str_freeze(VALUE str)
{
    if (OBJ_FROZEN(str)) return str;
    rb_str_resize(str, RSTRING_LEN(str));
    return rb_obj_freeze(str);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-getbyte" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              getbyte(index) &rarr; integer or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the byte at zero-based <code>index</code> as an integer, or <code>nil</code> if <code>index</code> is out of range:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;abcde&#39;</span>   <span class="ruby-comment"># =&gt; &quot;abcde&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">getbyte</span>(<span class="ruby-value">0</span>)  <span class="ruby-comment"># =&gt; 97</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">getbyte</span>(<span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; 101</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">getbyte</span>(<span class="ruby-value">5</span>)  <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Related: <a href="String.html#method-i-setbyte"><code>String#setbyte</code></a>.</p>

          <div class="method-source-code" id="getbyte-source">
            <pre>static VALUE
rb_str_getbyte(VALUE str, VALUE index)
{
    long pos = NUM2LONG(index);

    if (pos &lt; 0)
        pos += RSTRING_LEN(str);
    if (pos &lt; 0 ||  RSTRING_LEN(str) &lt;= pos)
        return Qnil;

    return INT2FIX((unsigned char)RSTRING_PTR(str)[pos]);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-grapheme_clusters" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              grapheme_clusters &rarr; array_of_grapheme_clusters
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns an array of the grapheme clusters in <code>self</code> (see <a href="https://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">Unicode Grapheme Cluster Boundaries</a>):</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;\u0061\u0308-pqr-\u0062\u0308-xyz-\u0063\u0308&quot;</span> <span class="ruby-comment"># =&gt; &quot;ä-pqr-b̈-xyz-c̈&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">grapheme_clusters</span>
<span class="ruby-comment"># =&gt; [&quot;ä&quot;, &quot;-&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;, &quot;-&quot;, &quot;b̈&quot;, &quot;-&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;-&quot;, &quot;c̈&quot;]</span>
</pre>

          <div class="method-source-code" id="grapheme_clusters-source">
            <pre>static VALUE
rb_str_grapheme_clusters(VALUE str)
{
    VALUE ary = WANTARRAY(&quot;grapheme_clusters&quot;, rb_str_strlen(str));
    return rb_str_enumerate_grapheme_clusters(str, ary);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-gsub" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              gsub(pattern, replacement)   &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              gsub(pattern) {|match| ... } &rarr; new_string
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              gsub(pattern)                &rarr; enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with all occurrences of the given <code>pattern</code> replaced.</p>

<p>See <a href="String.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p>

<p>Returns an <a href="Enumerator.html"><code>Enumerator</code></a> if no <code>replacement</code> and no block given.</p>

<p>Related: <a href="String.html#method-i-sub"><code>String#sub</code></a>, <a href="String.html#method-i-sub-21"><code>String#sub!</code></a>, <a href="String.html#method-i-gsub-21"><code>String#gsub!</code></a>.</p>

          <div class="method-source-code" id="gsub-source">
            <pre>static VALUE
rb_str_gsub(int argc, VALUE *argv, VALUE str)
{
    return str_gsub(argc, argv, str, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-gsub-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              gsub!(pattern, replacement)   &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              gsub!(pattern) {|match| ... } &rarr; self or nil
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              gsub!(pattern)                &rarr; an_enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Performs the specified substring replacement(s) on <code>self</code>; returns <code>self</code> if any replacement occurred, <code>nil</code> otherwise.</p>

<p>See <a href="String.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p>

<p>Returns an <a href="Enumerator.html"><code>Enumerator</code></a> if no <code>replacement</code> and no block given.</p>

<p>Related: <a href="String.html#method-i-sub"><code>String#sub</code></a>, <a href="String.html#method-i-gsub"><code>String#gsub</code></a>, <a href="String.html#method-i-sub-21"><code>String#sub!</code></a>.</p>

          <div class="method-source-code" id="gsub-21-source">
            <pre>static VALUE
rb_str_gsub_bang(int argc, VALUE *argv, VALUE str)
{
    str_modify_keep_cr(str);
    return str_gsub(argc, argv, str, 1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-hash" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              hash &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the integer hash value for <code>self</code>. The value is based on the length, content and encoding of <code>self</code>.</p>

<p>Related: <a href="Object.html#method-i-hash"><code>Object#hash</code></a>.</p>

          <div class="method-source-code" id="hash-source">
            <pre>static VALUE
rb_str_hash_m(VALUE str)
{
    st_index_t hval = rb_str_hash(str);
    return ST2FIX(hval);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-hex" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              hex &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Interprets the leading substring of <code>self</code> as a string of hexadecimal digits (with an optional sign and an optional <code>0x</code>) and returns the corresponding number; returns zero if there is no such leading substring:</p>

<pre class="ruby"><span class="ruby-string">&#39;0x0a&#39;</span>.<span class="ruby-identifier">hex</span>        <span class="ruby-comment"># =&gt; 10</span>
<span class="ruby-string">&#39;-1234&#39;</span>.<span class="ruby-identifier">hex</span>       <span class="ruby-comment"># =&gt; -4660</span>
<span class="ruby-string">&#39;0&#39;</span>.<span class="ruby-identifier">hex</span>           <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;non-numeric&#39;</span>.<span class="ruby-identifier">hex</span> <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>Related: <a href="String.html#method-i-oct"><code>String#oct</code></a>.</p>

          <div class="method-source-code" id="hex-source">
            <pre>static VALUE
rb_str_hex(VALUE str)
{
    return rb_str_to_inum(str, 16, FALSE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-include-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              include? other_string &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> contains <code>other_string</code>, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&#39;f&#39;</span>)    <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&#39;fo&#39;</span>)   <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">include?</span>(<span class="ruby-string">&#39;food&#39;</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="include-3F-source">
            <pre>VALUE
rb_str_include(VALUE str, VALUE arg)
{
    long i;

    StringValue(arg);
    i = rb_str_index(str, arg, 0);

    return RBOOL(i != -1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-index" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              index(substring, offset = 0) &rarr; integer or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              index(regexp, offset = 0) &rarr; integer or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the integer index of the first match for the given argument, or <code>nil</code> if none found; the search of <code>self</code> is forward, and begins at position <code>offset</code> (in characters).</p>

<p>With string argument <code>substring</code>, returns the index of the first matching substring in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;f&#39;</span>)         <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>)         <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;oo&#39;</span>)        <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;ooo&#39;</span>)       <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;с&#39;</span>)        <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;ち&#39;</span>)   <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>With <a href="Regexp.html"><code>Regexp</code></a> argument <code>regexp</code>, returns the index of the first match in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-regexp">/o./</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-regexp">/.o/</span>) <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>With positive integer <code>offset</code>, begins the search at position <code>offset</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">1</span>)        <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">2</span>)        <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">3</span>)        <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;с&#39;</span>, <span class="ruby-value">1</span>)       <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;ち&#39;</span>, <span class="ruby-value">2</span>)  <span class="ruby-comment"># =&gt; 3</span>
</pre>

<p>With negative integer <code>offset</code>, selects the search position by counting backward from the end of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-1</span>)  <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-2</span>)  <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-3</span>)  <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-4</span>)  <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-regexp">/o./</span>, <span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-regexp">/.o/</span>, <span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Related: <a href="String.html#method-i-rindex"><code>String#rindex</code></a>.</p>

          <div class="method-source-code" id="index-source">
            <pre>static VALUE
rb_str_index_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE initpos;
    long pos;

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;initpos) == 2) {
        pos = NUM2LONG(initpos);
    }
    else {
        pos = 0;
    }
    if (pos &lt; 0) {
        pos += str_strlen(str, NULL);
        if (pos &lt; 0) {
            if (RB_TYPE_P(sub, T_REGEXP)) {
                rb_backref_set(Qnil);
            }
            return Qnil;
        }
    }

    if (RB_TYPE_P(sub, T_REGEXP)) {
        if (pos &gt; str_strlen(str, NULL))
            return Qnil;
        pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
                         rb_enc_check(str, sub), single_byte_optimizable(str));

        if (rb_reg_search(sub, str, pos, 0) &lt; 0) {
            return Qnil;
        }
        else {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = rb_str_sublen(str, BEG(0));
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_str_index(str, sub, pos);
        pos = rb_str_sublen(str, pos);
    }

    if (pos == -1) return Qnil;
    return LONG2NUM(pos);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-initialize_copy" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">initialize_copy</span><span
              class="method-args">(other_string) -&gt; self</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Replaces the contents of <code>self</code> with the contents of <code>other_string</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>        <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

          <div class="method-source-code" id="initialize_copy-source">
            <pre>VALUE
rb_str_replace(VALUE str, VALUE str2)
{
    str_modifiable(str);
    if (str == str2) return str;

    StringValue(str2);
    str_discard(str);
    return str_replace(str, str2);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-replace">replace</a>
        </div>

      </div>

      <div id="method-i-insert" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              insert(index, other_string) &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Inserts the given <code>other_string</code> into <code>self</code>; returns <code>self</code>.</p>

<p>If the Integer <code>index</code> is positive, inserts <code>other_string</code> at offset <code>index</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">1</span>, <span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; &quot;fbaroo&quot;</span>
</pre>

<p>If the Integer <code>index</code> is negative, counts backward from the end of <code>self</code> and inserts <code>other_string</code> at offset <code>index+1</code> (that is, <em>after</em> <code>self[index]</code>):</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">insert</span>(<span class="ruby-value">-2</span>, <span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; &quot;fobaro&quot;</span>
</pre>

          <div class="method-source-code" id="insert-source">
            <pre>static VALUE
rb_str_insert(VALUE str, VALUE idx, VALUE str2)
{
    long pos = NUM2LONG(idx);

    if (pos == -1) {
        return rb_str_append(str, str2);
    }
    else if (pos &lt; 0) {
        pos++;
    }
    rb_str_splice(str, pos, 0, str2);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-inspect" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              inspect &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a printable version of <code>self</code>, enclosed in double-quotes, and with special characters escaped:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;foo\tbar\tbaz\n&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">inspect</span>
<span class="ruby-comment"># =&gt; &quot;\&quot;foo\\tbar\\tbaz\\n\&quot;&quot;</span>
</pre>

          <div class="method-source-code" id="inspect-source">
            <pre>VALUE
rb_str_inspect(VALUE str)
{
    int encidx = ENCODING_GET(str);
    rb_encoding *enc = rb_enc_from_index(encidx);
    const char *p, *pend, *prev;
    char buf[CHAR_ESC_LEN + 1];
    VALUE result = rb_str_buf_new(0);
    rb_encoding *resenc = rb_default_internal_encoding();
    int unicode_p = rb_enc_unicode_p(enc);
    int asciicompat = rb_enc_asciicompat(enc);

    if (resenc == NULL) resenc = rb_default_external_encoding();
    if (!rb_enc_asciicompat(resenc)) resenc = rb_usascii_encoding();
    rb_enc_associate(result, resenc);
    str_buf_cat2(result, &quot;\&quot;&quot;);

    p = RSTRING_PTR(str); pend = RSTRING_END(str);
    prev = p;
    while (p &lt; pend) {
        unsigned int c, cc;
        int n;

        n = rb_enc_precise_mbclen(p, pend, enc);
        if (!MBCLEN_CHARFOUND_P(n)) {
            if (p &gt; prev) str_buf_cat(result, prev, p - prev);
            n = rb_enc_mbminlen(enc);
            if (pend &lt; p + n)
                n = (int)(pend - p);
            while (n--) {
                snprintf(buf, CHAR_ESC_LEN, &quot;\\x%02X&quot;, *p &amp; 0377);
                str_buf_cat(result, buf, strlen(buf));
                prev = ++p;
            }
            continue;
        }
        n = MBCLEN_CHARFOUND_LEN(n);
        c = rb_enc_mbc_to_codepoint(p, pend, enc);
        p += n;
        if ((asciicompat || unicode_p) &amp;&amp;
          (c == &#39;&quot;&#39;|| c == &#39;\\&#39; ||
            (c == &#39;#&#39; &amp;&amp;
             p &lt; pend &amp;&amp;
             MBCLEN_CHARFOUND_P(rb_enc_precise_mbclen(p,pend,enc)) &amp;&amp;
             (cc = rb_enc_codepoint(p,pend,enc),
              (cc == &#39;$&#39; || cc == &#39;@&#39; || cc == &#39;{&#39;))))) {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            str_buf_cat2(result, &quot;\\&quot;);
            if (asciicompat || enc == resenc) {
                prev = p - n;
                continue;
            }
        }
        switch (c) {
          case &#39;\n&#39;: cc = &#39;n&#39;; break;
          case &#39;\r&#39;: cc = &#39;r&#39;; break;
          case &#39;\t&#39;: cc = &#39;t&#39;; break;
          case &#39;\f&#39;: cc = &#39;f&#39;; break;
          case &#39;\013&#39;: cc = &#39;v&#39;; break;
          case &#39;\010&#39;: cc = &#39;b&#39;; break;
          case &#39;\007&#39;: cc = &#39;a&#39;; break;
          case 033: cc = &#39;e&#39;; break;
          default: cc = 0; break;
        }
        if (cc) {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            buf[0] = &#39;\\&#39;;
            buf[1] = (char)cc;
            str_buf_cat(result, buf, 2);
            prev = p;
            continue;
        }
        /* The special casing of 0x85 (NEXT_LINE) here is because
         * Oniguruma historically treats it as printable, but it
         * doesn&#39;t match the print POSIX bracket class or character
         * property in regexps.
         *
         * See Ruby Bug #16842 for details:
         * https://bugs.ruby-lang.org/issues/16842
         */
        if ((enc == resenc &amp;&amp; rb_enc_isprint(c, enc) &amp;&amp; c != 0x85) ||
            (asciicompat &amp;&amp; rb_enc_isascii(c, enc) &amp;&amp; ISPRINT(c))) {
            continue;
        }
        else {
            if (p - n &gt; prev) str_buf_cat(result, prev, p - n - prev);
            rb_str_buf_cat_escaped_char(result, c, unicode_p);
            prev = p;
            continue;
        }
    }
    if (p &gt; prev) str_buf_cat(result, prev, p - prev);
    str_buf_cat2(result, &quot;\&quot;&quot;);

    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-intern" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              intern   &rarr; symbol
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the <a href="Symbol.html"><code>Symbol</code></a> corresponding to <em>str</em>, creating the symbol if it did not previously exist. See <a href="Symbol.html#method-i-id2name"><code>Symbol#id2name</code></a>.</p>

<pre class="ruby"><span class="ruby-string">&quot;Koala&quot;</span>.<span class="ruby-identifier">intern</span>         <span class="ruby-comment">#=&gt; :Koala</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;cat&#39;</span>.<span class="ruby-identifier">to_sym</span>       <span class="ruby-comment">#=&gt; :cat</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-value">:cat</span>              <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;@cat&#39;</span>.<span class="ruby-identifier">to_sym</span>      <span class="ruby-comment">#=&gt; :@cat</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-value">:@cat</span>             <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>This can also be used to create symbols that cannot be represented using the <code>:xxx</code> notation.</p>

<pre class="ruby"><span class="ruby-string">&#39;cat and dog&#39;</span>.<span class="ruby-identifier">to_sym</span>   <span class="ruby-comment">#=&gt; :&quot;cat and dog&quot;</span>
</pre>

          <div class="method-source-code" id="intern-source">
            <pre>VALUE
rb_str_intern(VALUE str)
{
    VALUE sym;
#if USE_SYMBOL_GC
    rb_encoding *enc, *ascii;
    int type;
#else
    ID id;
#endif
    GLOBAL_SYMBOLS_ENTER(symbols);
    {
        sym = lookup_str_sym_with_lock(symbols, str);

        if (sym) {
            // ok
        }
        else {
#if USE_SYMBOL_GC
            enc = rb_enc_get(str);
            ascii = rb_usascii_encoding();
            if (enc != ascii &amp;&amp; sym_check_asciionly(str)) {
                str = rb_str_dup(str);
                rb_enc_associate(str, ascii);
                OBJ_FREEZE(str);
                enc = ascii;
            }
            else {
                str = rb_str_dup(str);
                OBJ_FREEZE(str);
            }
            str = rb_fstring(str);
            type = rb_str_symname_type(str, IDSET_ATTRSET_FOR_INTERN);
            if (type &lt; 0) type = ID_JUNK;
            sym = dsymbol_alloc(symbols, rb_cSymbol, str, enc, type);
#else
            id = intern_str(str, 0);
            sym = ID2SYM(id);
#endif
        }
    }
    GLOBAL_SYMBOLS_LEAVE();
    return sym;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-to_sym">to_sym</a>
        </div>

      </div>

      <div id="method-i-iseuc" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#iseuc   &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns whether <code>self</code>‘s encoding is EUC-JP or not.</p>

          <div class="method-source-code" id="iseuc-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 264</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">iseuc</span>;    <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">iseuc</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-isjis" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#isjis   &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns whether <code>self</code>‘s encoding is ISO-2022-JP or not.</p>

          <div class="method-source-code" id="isjis-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 276</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">isjis</span>;    <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">isjis</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-issjis" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#issjis   &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns whether <code>self</code>‘s encoding is Shift_JIS or not.</p>

          <div class="method-source-code" id="issjis-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 270</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">issjis</span>;   <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">issjis</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-isutf8" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#isutf8   &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns whether <code>self</code>‘s encoding is UTF-8 or not.</p>

          <div class="method-source-code" id="isutf8-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 282</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">isutf8</span>;   <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">isutf8</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-kconv" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#kconv(to_enc, from_enc)
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to <code>to_enc</code>. <code>to_enc</code> and <code>from_enc</code> are given as constants of <a href="Kconv.html"><code>Kconv</code></a> or <a href="Encoding.html"><code>Encoding</code></a> objects.</p>

          <div class="method-source-code" id="kconv-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 205</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">kconv</span>(<span class="ruby-identifier">to_enc</span>, <span class="ruby-identifier">from_enc</span>=<span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">from_enc</span> = <span class="ruby-keyword">self</span>.<span class="ruby-identifier">encoding</span> <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span><span class="ruby-identifier">from_enc</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">encoding</span> <span class="ruby-operator">!=</span> <span class="ruby-constant">Encoding</span>.<span class="ruby-identifier">list</span>[<span class="ruby-value">0</span>]
  <span class="ruby-constant">Kconv</span><span class="ruby-operator">::</span><span class="ruby-identifier">kconv</span>(<span class="ruby-keyword">self</span>, <span class="ruby-identifier">to_enc</span>, <span class="ruby-identifier">from_enc</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-length" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              length &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the count of characters (not bytes) in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">length</span>        <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">length</span>       <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">length</span>   <span class="ruby-comment"># =&gt; 5</span>
</pre>

<p>Contrast with <a href="String.html#method-i-bytesize"><code>String#bytesize</code></a>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">bytesize</span>        <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">bytesize</span>       <span class="ruby-comment"># =&gt; 8</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">bytesize</span>   <span class="ruby-comment"># =&gt; 15</span>
</pre>

<p><a href="String.html#method-i-size"><code>String#size</code></a> is an alias for <a href="String.html#method-i-length"><code>String#length</code></a>.</p>

          <div class="method-source-code" id="length-source">
            <pre>VALUE
rb_str_length(VALUE str)
{
    return LONG2NUM(str_strlen(str, NULL));
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-size">size</a>
        </div>

      </div>

      <div id="method-i-lines" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              lines(Line_sep = $/, chomp: false) &rarr; array_of_strings
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Forms substrings (“lines”) of <code>self</code> according to the given arguments (see <a href="String.html#method-i-each_line"><code>String#each_line</code></a> for details); returns the lines in an array.</p>

          <div class="method-source-code" id="lines-source">
            <pre>static VALUE
rb_str_lines(int argc, VALUE *argv, VALUE str)
{
    VALUE ary = WANTARRAY(&quot;lines&quot;, 0);
    return rb_str_enumerate_lines(argc, argv, str, ary);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-ljust" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              ljust(size, pad_string = &#39; &#39;) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a left-justified copy of <code>self</code>.</p>

<p>If integer argument <code>size</code> is greater than the size (in characters) of <code>self</code>, returns a new string of length <code>size</code> that is a copy of <code>self</code>, left justified and padded on the right with <code>pad_string</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">10</span>)       <span class="ruby-comment"># =&gt; &quot;hello     &quot;</span>
<span class="ruby-string">&#39;  hello&#39;</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">10</span>)     <span class="ruby-comment"># =&gt; &quot;  hello   &quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">10</span>, <span class="ruby-string">&#39;ab&#39;</span>) <span class="ruby-comment"># =&gt; &quot;helloababa&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">10</span>)        <span class="ruby-comment"># =&gt; &quot;тест      &quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">10</span>)    <span class="ruby-comment"># =&gt; &quot;こんにちは     &quot;</span>
</pre>

<p>If <code>size</code> is not greater than the size of <code>self</code>, returns a copy of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">5</span>)  <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">ljust</span>(<span class="ruby-value">1</span>)  <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-rjust"><code>String#rjust</code></a>, <a href="String.html#method-i-center"><code>String#center</code></a>.</p>

          <div class="method-source-code" id="ljust-source">
            <pre>static VALUE
rb_str_ljust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, &#39;l&#39;);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-lstrip" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              lstrip &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with leading whitespace removed; see <a href="String.html#class-String-label-Whitespace+in+Strings">Whitespace in Strings</a>:</p>

<pre class="ruby"><span class="ruby-identifier">whitespace</span> = <span class="ruby-string">&quot;\x00\t\n\v\f\r &quot;</span>
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">whitespace</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;abc&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">whitespace</span>
<span class="ruby-identifier">s</span>        <span class="ruby-comment"># =&gt; &quot;\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r &quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">lstrip</span> <span class="ruby-comment"># =&gt; &quot;abc\u0000\t\n\v\f\r &quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-rstrip"><code>String#rstrip</code></a>, <a href="String.html#method-i-strip"><code>String#strip</code></a>.</p>

          <div class="method-source-code" id="lstrip-source">
            <pre>static VALUE
rb_str_lstrip(VALUE str)
{
    char *start;
    long len, loffset;
    RSTRING_GETMEM(str, start, len);
    loffset = lstrip_offset(str, start, start+len, STR_ENC_GET(str));
    if (loffset &lt;= 0) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, loffset, len - loffset);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-lstrip-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              lstrip! &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-lstrip"><code>String#lstrip</code></a>, except that any modifications are made in <code>self</code>; returns <code>self</code> if any modification are made, <code>nil</code> otherwise.</p>

<p>Related: <a href="String.html#method-i-rstrip-21"><code>String#rstrip!</code></a>, <a href="String.html#method-i-strip-21"><code>String#strip!</code></a>.</p>

          <div class="method-source-code" id="lstrip-21-source">
            <pre>static VALUE
rb_str_lstrip_bang(VALUE str)
{
    rb_encoding *enc;
    char *start, *s;
    long olen, loffset;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    loffset = lstrip_offset(str, start, start+olen, enc);
    if (loffset &gt; 0) {
        long len = olen-loffset;
        s = start + loffset;
        memmove(start, s, len);
        STR_SET_LEN(str, len);
        TERM_FILL(start+len, rb_enc_mbminlen(enc));
        return str;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-match" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              match(pattern, offset = 0) &rarr; matchdata or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              match(pattern, offset = 0) {|matchdata| ... } &rarr; object
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a MatchData object (or <code>nil</code>) based on <code>self</code> and the given <code>pattern</code>.</p>

<p>Note: also updates <a href="Regexp.html#class-Regexp-label-Special+global+variables">Special global variables at <code>Regexp</code></a>.</p>
<ul><li>
<p>Computes <code>regexp</code> by converting <code>pattern</code> (if not already a Regexp).</p>

<pre class="ruby"><span class="ruby-identifier">regexp</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">pattern</span>)
</pre>
</li><li>
<p>Computes <code>matchdata</code>, which will be either a MatchData object or <code>nil</code> (see <a href="Regexp.html#method-i-match"><code>Regexp#match</code></a>):</p>

<pre>matchdata = &lt;tt&gt;regexp.match(self)</pre>
</li></ul>

<p>With no block given, returns the computed <code>matchdata</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&#39;f&#39;</span>) <span class="ruby-comment"># =&gt; #&lt;MatchData &quot;f&quot;&gt;</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&#39;o&#39;</span>) <span class="ruby-comment"># =&gt; #&lt;MatchData &quot;o&quot;&gt;</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&#39;x&#39;</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>If Integer argument <code>offset</code> is given, the search begins at index <code>offset</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&#39;f&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; #&lt;MatchData &quot;o&quot;&gt;</span>
</pre>

<p>With a block given, calls the block with the computed <code>matchdata</code> and returns the block’s return value:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/o/</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">matchdata</span><span class="ruby-operator">|</span> <span class="ruby-identifier">matchdata</span> } <span class="ruby-comment"># =&gt; #&lt;MatchData &quot;o&quot;&gt;</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/x/</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">matchdata</span><span class="ruby-operator">|</span> <span class="ruby-identifier">matchdata</span> } <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match</span>(<span class="ruby-regexp">/f/</span>, <span class="ruby-value">1</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">matchdata</span><span class="ruby-operator">|</span> <span class="ruby-identifier">matchdata</span> } <span class="ruby-comment"># =&gt; nil</span>
</pre>

          <div class="method-source-code" id="match-source">
            <pre>static VALUE
rb_str_match_m(int argc, VALUE *argv, VALUE str)
{
    VALUE re, result;
    if (argc &lt; 1)
        rb_check_arity(argc, 1, 2);
    re = argv[0];
    argv[0] = str;
    result = rb_funcallv(get_pat(re), rb_intern(&quot;match&quot;), argc, argv);
    if (!NIL_P(result) &amp;&amp; rb_block_given_p()) {
        return rb_yield(result);
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-match-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              match?(pattern, offset = 0) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> or <code>false</code> based on whether a match is found for <code>self</code> and <code>pattern</code>.</p>

<p>Note: does not update <a href="Regexp.html#class-Regexp-label-Special+global+variables">Special global variables at <code>Regexp</code></a>.</p>

<p>Computes <code>regexp</code> by converting <code>pattern</code> (if not already a Regexp).</p>

<pre class="ruby"><span class="ruby-identifier">regexp</span> = <span class="ruby-constant">Regexp</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">pattern</span>)
</pre>

<p>Returns <code>true</code> if <code>self+.match(regexp)</code> returns a MatchData object, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match?</span>(<span class="ruby-regexp">/o/</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match?</span>(<span class="ruby-string">&#39;o&#39;</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match?</span>(<span class="ruby-regexp">/x/</span>) <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>If Integer argument <code>offset</code> is given, the search begins at index <code>offset</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match?</span>(<span class="ruby-string">&#39;f&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">match?</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; true</span>
</pre>

          <div class="method-source-code" id="match-3F-source">
            <pre>static VALUE
rb_str_match_m_p(int argc, VALUE *argv, VALUE str)
{
    VALUE re;
    rb_check_arity(argc, 1, 2);
    re = get_pat(argv[0]);
    return rb_reg_match_p(re, str, argc &gt; 1 ? NUM2LONG(argv[1]) : 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-next" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">next</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the successor to <code>self</code>. The successor is calculated by incrementing characters.</p>

<p>The first character to be incremented is the rightmost alphanumeric: or, if no alphanumerics, the rightmost character:</p>

<pre class="ruby"><span class="ruby-string">&#39;THX1138&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;THX1139&quot;</span>
<span class="ruby-string">&#39;&lt;&lt;koala&gt;&gt;&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;</span>
<span class="ruby-string">&#39;***&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &#39;**+&#39;</span>
</pre>

<p>The successor to a digit is another digit, “carrying” to the next-left character for a “rollover” from 9 to 0, and prepending another digit if necessary:</p>

<pre class="ruby"><span class="ruby-string">&#39;00&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;01&quot;</span>
<span class="ruby-string">&#39;09&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;10&quot;</span>
<span class="ruby-string">&#39;99&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;100&quot;</span>
</pre>

<p>The successor to a letter is another letter of the same case, carrying to the next-left character for a rollover, and prepending another same-case letter if necessary:</p>

<pre class="ruby"><span class="ruby-string">&#39;aa&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;ab&quot;</span>
<span class="ruby-string">&#39;az&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;ba&quot;</span>
<span class="ruby-string">&#39;zz&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;aaa&quot;</span>
<span class="ruby-string">&#39;AA&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;AB&quot;</span>
<span class="ruby-string">&#39;AZ&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;BA&quot;</span>
<span class="ruby-string">&#39;ZZ&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;AAA&quot;</span>
</pre>

<p>The successor to a non-alphanumeric character is the next character in the underlying character set’s collating sequence, carrying to the next-left character for a rollover, and prepending another character if necessary:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-value">0</span>.<span class="ruby-identifier">chr</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span>
<span class="ruby-identifier">s</span> <span class="ruby-comment"># =&gt; &quot;\x00\x00\x00&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;\x00\x00\x01&quot;</span>
<span class="ruby-identifier">s</span> = <span class="ruby-value">255</span>.<span class="ruby-identifier">chr</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span>
<span class="ruby-identifier">s</span> <span class="ruby-comment"># =&gt; &quot;\xFF\xFF\xFF&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;\x01\x00\x00\x00&quot;</span>
</pre>

<p>Carrying can occur between and among mixtures of alphanumeric characters:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;zz99zz99&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;aaa00aa00&quot;</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;99zz99zz&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;100aa00aa&quot;</span>
</pre>

<p>The successor to an empty String is a new empty String:</p>

<pre class="ruby"><span class="ruby-string">&#39;&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;&quot;</span>
</pre>

<p><a href="String.html#method-i-next"><code>String#next</code></a> is an alias for <a href="String.html#method-i-succ"><code>String#succ</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-succ">succ</a>
        </div>
      </div>

      <div id="method-i-next-21" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">next!</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="String.html#method-i-succ"><code>String#succ</code></a>, but modifies <code>self</code> in place; returns <code>self</code>.</p>

<p><a href="String.html#method-i-next-21"><code>String#next!</code></a> is an alias for <a href="String.html#method-i-succ-21"><code>String#succ!</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-succ-21">succ!</a>
        </div>
      </div>

      <div id="method-i-oct" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              oct &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Interprets the leading substring of <code>self</code> as a string of octal digits (with an optional sign) and returns the corresponding number; returns zero if there is no such leading substring:</p>

<pre class="ruby"><span class="ruby-string">&#39;123&#39;</span>.<span class="ruby-identifier">oct</span>             <span class="ruby-comment"># =&gt; 83</span>
<span class="ruby-string">&#39;-377&#39;</span>.<span class="ruby-identifier">oct</span>            <span class="ruby-comment"># =&gt; -255</span>
<span class="ruby-string">&#39;0377non-numeric&#39;</span>.<span class="ruby-identifier">oct</span> <span class="ruby-comment"># =&gt; 255</span>
<span class="ruby-string">&#39;non-numeric&#39;</span>.<span class="ruby-identifier">oct</span>     <span class="ruby-comment"># =&gt; 0</span>
</pre>

<p>If <code>self</code> starts with <code>0</code>, radix indicators are honored; see <a href="Kernel.html#method-i-Integer"><code>Kernel#Integer</code></a>.</p>

<p>Related: <a href="String.html#method-i-hex"><code>String#hex</code></a>.</p>

          <div class="method-source-code" id="oct-source">
            <pre>static VALUE
rb_str_oct(VALUE str)
{
    return rb_str_to_inum(str, -8, FALSE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-ord" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              ord &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the integer ordinal of the first character of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;h&#39;</span>.<span class="ruby-identifier">ord</span>         <span class="ruby-comment"># =&gt; 104</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">ord</span>     <span class="ruby-comment"># =&gt; 104</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">ord</span>      <span class="ruby-comment"># =&gt; 1090</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">ord</span>  <span class="ruby-comment"># =&gt; 12371</span>
</pre>

          <div class="method-source-code" id="ord-source">
            <pre>static VALUE
rb_str_ord(VALUE s)
{
    unsigned int c;

    c = rb_enc_codepoint(RSTRING_PTR(s), RSTRING_END(s), STR_ENC_GET(s));
    return UINT2NUM(c);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-partition" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              partition(string_or_regexp) &rarr; [head, match, tail]
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a 3-element array of substrings of <code>self</code>.</p>

<p>Matches a pattern against <code>self</code>, scanning from the beginning. The pattern is:</p>
<ul><li>
<p><code>string_or_regexp</code> itself, if it is a <a href="Regexp.html"><code>Regexp</code></a>.</p>
</li><li>
<p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p>
</li></ul>

<p>If the pattern is matched, returns pre-match, first-match, post-match:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;l&#39;</span>)      <span class="ruby-comment"># =&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;ll&#39;</span>)     <span class="ruby-comment"># =&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;h&#39;</span>)      <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;h&quot;, &quot;ello&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;o&#39;</span>)      <span class="ruby-comment"># =&gt; [&quot;hell&quot;, &quot;o&quot;, &quot;&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-regexp">/l+/</span>)     <span class="ruby-comment">#=&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;&#39;</span>)       <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;т&#39;</span>)       <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;т&quot;, &quot;ест&quot;]</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;に&#39;</span>)  <span class="ruby-comment"># =&gt; [&quot;こん&quot;, &quot;に&quot;, &quot;ちは&quot;]</span>
</pre>

<p>If the pattern is not matched, returns a copy of <code>self</code> and two empty strings:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">partition</span>(<span class="ruby-string">&#39;x&#39;</span>) <span class="ruby-comment"># =&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]</span>
</pre>

<p>Related: <a href="String.html#method-i-rpartition"><code>String#rpartition</code></a>, <a href="String.html#method-i-split"><code>String#split</code></a>.</p>

          <div class="method-source-code" id="partition-source">
            <pre>static VALUE
rb_str_partition(VALUE str, VALUE sep)
{
    long pos;

    sep = get_pat_quoted(sep, 0);
    if (RB_TYPE_P(sep, T_REGEXP)) {
        if (rb_reg_search(sep, str, 0, 0) &lt; 0) {
            goto failed;
        }
        VALUE match = rb_backref_get();
        struct re_registers *regs = RMATCH_REGS(match);

        pos = BEG(0);
        sep = rb_str_subseq(str, pos, END(0) - pos);
    }
    else {
        pos = rb_str_index(str, sep, 0);
        if (pos &lt; 0) goto failed;
    }
    return rb_ary_new3(3, rb_str_subseq(str, 0, pos),
                          sep,
                          rb_str_subseq(str, pos+RSTRING_LEN(sep),
                                             RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));

  failed:
    return rb_ary_new3(3, str_duplicate(rb_cString, str), str_new_empty_String(str), str_new_empty_String(str));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-prepend" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              prepend(*other_strings)  &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Prepends each string in <code>other_strings</code> to <code>self</code> and returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">prepend</span>(<span class="ruby-string">&#39;bar&#39;</span>, <span class="ruby-string">&#39;baz&#39;</span>) <span class="ruby-comment"># =&gt; &quot;barbazfoo&quot;</span>
<span class="ruby-identifier">s</span>                       <span class="ruby-comment"># =&gt; &quot;barbazfoo&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-concat"><code>String#concat</code></a>.</p>

          <div class="method-source-code" id="prepend-source">
            <pre>static VALUE
rb_str_prepend_multi(int argc, VALUE *argv, VALUE str)
{
    str_modifiable(str);

    if (argc == 1) {
        rb_str_update(str, 0L, 0L, argv[0]);
    }
    else if (argc &gt; 1) {
        int i;
        VALUE arg_str = rb_str_tmp_new(0);
        rb_enc_copy(arg_str, str);
        for (i = 0; i &lt; argc; i++) {
            rb_str_append(arg_str, argv[i]);
        }
        rb_str_update(str, 0L, 0L, arg_str);
    }

    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-replace" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              replace(other_string) &rarr; self
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Replaces the contents of <code>self</code> with the contents of <code>other_string</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;foo&#39;</span>        <span class="ruby-comment"># =&gt; &quot;foo&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-string">&#39;bar&#39;</span>) <span class="ruby-comment"># =&gt; &quot;bar&quot;</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-initialize_copy">initialize_copy</a>
        </div>
      </div>

      <div id="method-i-reverse" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              reverse &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new string with the characters from <code>self</code> in reverse order.</p>

<pre class="ruby"><span class="ruby-string">&#39;stressed&#39;</span>.<span class="ruby-identifier">reverse</span> <span class="ruby-comment"># =&gt; &quot;desserts&quot;</span>
</pre>

          <div class="method-source-code" id="reverse-source">
            <pre>static VALUE
rb_str_reverse(VALUE str)
{
    rb_encoding *enc;
    VALUE rev;
    char *s, *e, *p;
    int cr;

    if (RSTRING_LEN(str) &lt;= 1) return str_duplicate(rb_cString, str);
    enc = STR_ENC_GET(str);
    rev = rb_str_new(0, RSTRING_LEN(str));
    s = RSTRING_PTR(str); e = RSTRING_END(str);
    p = RSTRING_END(rev);
    cr = ENC_CODERANGE(str);

    if (RSTRING_LEN(str) &gt; 1) {
        if (single_byte_optimizable(str)) {
            while (s &lt; e) {
                *--p = *s++;
            }
        }
        else if (cr == ENC_CODERANGE_VALID) {
            while (s &lt; e) {
                int clen = rb_enc_fast_mbclen(s, e, enc);

                p -= clen;
                memcpy(p, s, clen);
                s += clen;
            }
        }
        else {
            cr = rb_enc_asciicompat(enc) ?
                ENC_CODERANGE_7BIT : ENC_CODERANGE_VALID;
            while (s &lt; e) {
                int clen = rb_enc_mbclen(s, e, enc);

                if (clen &gt; 1 || (*s &amp; 0x80)) cr = ENC_CODERANGE_UNKNOWN;
                p -= clen;
                memcpy(p, s, clen);
                s += clen;
            }
        }
    }
    STR_SET_LEN(rev, RSTRING_LEN(str));
    str_enc_copy(rev, str);
    ENC_CODERANGE_SET(rev, cr);

    return rev;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-reverse-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              reverse! &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code> with its characters reversed:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;stressed&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">reverse!</span> <span class="ruby-comment"># =&gt; &quot;desserts&quot;</span>
<span class="ruby-identifier">s</span>          <span class="ruby-comment"># =&gt; &quot;desserts&quot;</span>
</pre>

          <div class="method-source-code" id="reverse-21-source">
            <pre>static VALUE
rb_str_reverse_bang(VALUE str)
{
    if (RSTRING_LEN(str) &gt; 1) {
        if (single_byte_optimizable(str)) {
            char *s, *e, c;

            str_modify_keep_cr(str);
            s = RSTRING_PTR(str);
            e = RSTRING_END(str) - 1;
            while (s &lt; e) {
                c = *s;
                *s++ = *e;
                *e-- = c;
            }
        }
        else {
            str_shared_replace(str, rb_str_reverse(str));
        }
    }
    else {
        str_modify_keep_cr(str);
    }
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rindex" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rindex(substring, offset = self.length) &rarr; integer or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              rindex(regexp, offset = self.length) &rarr; integer or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the Integer index of the <em>last</em> occurrence of the given <code>substring</code>, or <code>nil</code> if none found:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;f&#39;</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;oo&#39;</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;ooo&#39;</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Returns the Integer index of the <em>last</em> match for the given Regexp <code>regexp</code>, or <code>nil</code> if none found:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-regexp">/f/</span>) <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-regexp">/o/</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-regexp">/oo/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-regexp">/ooo/</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>The <em>last</em> match means starting at the possible last position, not the last of longest matches.</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-regexp">/o+/</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-identifier">$~</span> <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;o&quot;&gt;</span>
</pre>

<p>To get the last longest match, needs to combine with negative lookbehind.</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-regexp">/(?&lt;!o)o+/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">$~</span> <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;oo&quot;&gt;</span>
</pre>

<p>Or <a href="String.html#method-i-index"><code>String#index</code></a> with negative lookforward.</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">index</span>(<span class="ruby-regexp">/o+(?!.*o)/</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-identifier">$~</span> <span class="ruby-comment">#=&gt; #&lt;MatchData &quot;oo&quot;&gt;</span>
</pre>

<p>Integer argument <code>offset</code>, if given and non-negative, specifies the maximum starting position in the</p>

<pre class="ruby"><span class="ruby-identifier">string</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">_end_</span> <span class="ruby-identifier">the</span> <span class="ruby-value">search:</span>

 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; nil</span>
 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; 1</span>
 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; 2</span>
 <span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">3</span>) <span class="ruby-comment"># =&gt; 2</span>
</pre>

<p>If <code>offset</code> is a negative Integer, the maximum starting position in the string to <em>end</em> the search is the sum of the string’s length and <code>offset</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; 2</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-2</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-3</span>) <span class="ruby-comment"># =&gt; nil</span>
<span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">rindex</span>(<span class="ruby-string">&#39;o&#39;</span>, <span class="ruby-value">-4</span>) <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>Related: <a href="String.html#method-i-index"><code>String#index</code></a>.</p>

          <div class="method-source-code" id="rindex-source">
            <pre>static VALUE
rb_str_rindex_m(int argc, VALUE *argv, VALUE str)
{
    VALUE sub;
    VALUE vpos;
    rb_encoding *enc = STR_ENC_GET(str);
    long pos, len = str_strlen(str, enc); /* str&#39;s enc */

    if (rb_scan_args(argc, argv, &quot;11&quot;, &amp;sub, &amp;vpos) == 2) {
        pos = NUM2LONG(vpos);
        if (pos &lt; 0) {
            pos += len;
            if (pos &lt; 0) {
                if (RB_TYPE_P(sub, T_REGEXP)) {
                    rb_backref_set(Qnil);
                }
                return Qnil;
            }
        }
        if (pos &gt; len) pos = len;
    }
    else {
        pos = len;
    }

    if (RB_TYPE_P(sub, T_REGEXP)) {
        /* enc = rb_get_check(str, sub); */
        pos = str_offset(RSTRING_PTR(str), RSTRING_END(str), pos,
                         enc, single_byte_optimizable(str));

        if (rb_reg_search(sub, str, pos, 1) &gt;= 0) {
            VALUE match = rb_backref_get();
            struct re_registers *regs = RMATCH_REGS(match);
            pos = rb_str_sublen(str, BEG(0));
            return LONG2NUM(pos);
        }
    }
    else {
        StringValue(sub);
        pos = rb_str_rindex(str, sub, pos);
        if (pos &gt;= 0) return LONG2NUM(pos);
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rjust" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rjust(size, pad_string = &#39; &#39;) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a right-justified copy of <code>self</code>.</p>

<p>If integer argument <code>size</code> is greater than the size (in characters) of <code>self</code>, returns a new string of length <code>size</code> that is a copy of <code>self</code>, right justified and padded on the left with <code>pad_string</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">10</span>)       <span class="ruby-comment"># =&gt; &quot;     hello&quot;</span>
<span class="ruby-string">&#39;hello  &#39;</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">10</span>)     <span class="ruby-comment"># =&gt; &quot;   hello  &quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">10</span>, <span class="ruby-string">&#39;ab&#39;</span>) <span class="ruby-comment"># =&gt; &quot;ababahello&quot;</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">10</span>)        <span class="ruby-comment"># =&gt; &quot;      тест&quot;</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">10</span>)    <span class="ruby-comment"># =&gt; &quot;     こんにちは&quot;</span>
</pre>

<p>If <code>size</code> is not greater than the size of <code>self</code>, returns a copy of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">5</span>, <span class="ruby-string">&#39;ab&#39;</span>)  <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rjust</span>(<span class="ruby-value">1</span>, <span class="ruby-string">&#39;ab&#39;</span>)  <span class="ruby-comment"># =&gt; &quot;hello&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-ljust"><code>String#ljust</code></a>, <a href="String.html#method-i-center"><code>String#center</code></a>.</p>

          <div class="method-source-code" id="rjust-source">
            <pre>static VALUE
rb_str_rjust(int argc, VALUE *argv, VALUE str)
{
    return rb_str_justify(argc, argv, str, &#39;r&#39;);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rpartition" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rpartition(sep) &rarr; [head, match, tail]
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a 3-element array of substrings of <code>self</code>.</p>

<p>Matches a pattern against <code>self</code>, scanning backwards from the end. The pattern is:</p>
<ul><li>
<p><code>string_or_regexp</code> itself, if it is a <a href="Regexp.html"><code>Regexp</code></a>.</p>
</li><li>
<p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p>
</li></ul>

<p>If the pattern is matched, returns pre-match, last-match, post-match:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;l&#39;</span>)      <span class="ruby-comment"># =&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;ll&#39;</span>)     <span class="ruby-comment"># =&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;h&#39;</span>)      <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;h&quot;, &quot;ello&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;o&#39;</span>)      <span class="ruby-comment"># =&gt; [&quot;hell&quot;, &quot;o&quot;, &quot;&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-regexp">/l+/</span>)     <span class="ruby-comment"># =&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;&#39;</span>)       <span class="ruby-comment"># =&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;т&#39;</span>)       <span class="ruby-comment"># =&gt; [&quot;тес&quot;, &quot;т&quot;, &quot;&quot;]</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;に&#39;</span>)  <span class="ruby-comment"># =&gt; [&quot;こん&quot;, &quot;に&quot;, &quot;ちは&quot;]</span>
</pre>

<p>If the pattern is not matched, returns two empty strings and a copy of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">rpartition</span>(<span class="ruby-string">&#39;x&#39;</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]</span>
</pre>

<p>Related: <a href="String.html#method-i-partition"><code>String#partition</code></a>, <a href="String.html#method-i-split"><code>String#split</code></a>.</p>

          <div class="method-source-code" id="rpartition-source">
            <pre>static VALUE
rb_str_rpartition(VALUE str, VALUE sep)
{
    long pos = RSTRING_LEN(str);

    sep = get_pat_quoted(sep, 0);
    if (RB_TYPE_P(sep, T_REGEXP)) {
        if (rb_reg_search(sep, str, pos, 1) &lt; 0) {
            goto failed;
        }
        VALUE match = rb_backref_get();
        struct re_registers *regs = RMATCH_REGS(match);

        pos = BEG(0);
        sep = rb_str_subseq(str, pos, END(0) - pos);
    }
    else {
        pos = rb_str_sublen(str, pos);
        pos = rb_str_rindex(str, sep, pos);
        if (pos &lt; 0) {
            goto failed;
        }
        pos = rb_str_offset(str, pos);
    }

    return rb_ary_new3(3, rb_str_subseq(str, 0, pos),
                          sep,
                          rb_str_subseq(str, pos+RSTRING_LEN(sep),
                                        RSTRING_LEN(str)-pos-RSTRING_LEN(sep)));
  failed:
    return rb_ary_new3(3, str_new_empty_String(str), str_new_empty_String(str), str_duplicate(rb_cString, str));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rstrip" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rstrip &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of the receiver with trailing whitespace removed; see <a href="String.html#class-String-label-Whitespace+in+Strings">Whitespace in Strings</a>:</p>

<pre class="ruby"><span class="ruby-identifier">whitespace</span> = <span class="ruby-string">&quot;\x00\t\n\v\f\r &quot;</span>
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">whitespace</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;abc&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">whitespace</span>
<span class="ruby-identifier">s</span>        <span class="ruby-comment"># =&gt; &quot;\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r &quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">rstrip</span> <span class="ruby-comment"># =&gt; &quot;\u0000\t\n\v\f\r abc&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-lstrip"><code>String#lstrip</code></a>, <a href="String.html#method-i-strip"><code>String#strip</code></a>.</p>

          <div class="method-source-code" id="rstrip-source">
            <pre>static VALUE
rb_str_rstrip(VALUE str)
{
    rb_encoding *enc;
    char *start;
    long olen, roffset;

    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    roffset = rstrip_offset(str, start, start+olen, enc);

    if (roffset &lt;= 0) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, 0, olen-roffset);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-rstrip-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              rstrip! &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-rstrip"><code>String#rstrip</code></a>, except that any modifications are made in <code>self</code>; returns <code>self</code> if any modification are made, <code>nil</code> otherwise.</p>

<p>Related: <a href="String.html#method-i-lstrip-21"><code>String#lstrip!</code></a>, <a href="String.html#method-i-strip-21"><code>String#strip!</code></a>.</p>

          <div class="method-source-code" id="rstrip-21-source">
            <pre>static VALUE
rb_str_rstrip_bang(VALUE str)
{
    rb_encoding *enc;
    char *start;
    long olen, roffset;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    roffset = rstrip_offset(str, start, start+olen, enc);
    if (roffset &gt; 0) {
        long len = olen - roffset;

        STR_SET_LEN(str, len);
        TERM_FILL(start+len, rb_enc_mbminlen(enc));
        return str;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-scan" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              scan(string_or_regexp) &rarr; array
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              scan(string_or_regexp) {|matches| ... } &rarr; self
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Matches a pattern against <code>self</code>; the pattern is:</p>
<ul><li>
<p><code>string_or_regexp</code> itself, if it is a <a href="Regexp.html"><code>Regexp</code></a>.</p>
</li><li>
<p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p>
</li></ul>

<p>Iterates through <code>self</code>, generating a collection of matching results:</p>
<ul><li>
<p>If the pattern contains no groups, each result is the matched string, <code>$&amp;</code>.</p>
</li><li>
<p>If the pattern contains groups, each result is an array containing one entry per group.</p>
</li></ul>

<p>With no block given, returns an array of the results:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;cruel world&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\w+/</span>)      <span class="ruby-comment"># =&gt; [&quot;cruel&quot;, &quot;world&quot;]</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/.../</span>)      <span class="ruby-comment"># =&gt; [&quot;cru&quot;, &quot;el &quot;, &quot;wor&quot;]</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/(...)/</span>)    <span class="ruby-comment"># =&gt; [[&quot;cru&quot;], [&quot;el &quot;], [&quot;wor&quot;]]</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/(..)(..)/</span>) <span class="ruby-comment"># =&gt; [[&quot;cr&quot;, &quot;ue&quot;], [&quot;l &quot;, &quot;wo&quot;]]</span>
</pre>

<p>With a block given, calls the block with each result; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/\w+/</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">w</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;&lt;&lt;#{w}&gt;&gt; &quot;</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">scan</span>(<span class="ruby-regexp">/(.)(.)/</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">x</span>,<span class="ruby-identifier">y</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">y</span>, <span class="ruby-identifier">x</span> }
<span class="ruby-identifier">print</span> <span class="ruby-string">&quot;\n&quot;</span>
</pre>

<p>Output:</p>

<pre>&lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;
rceu lowlr</pre>

          <div class="method-source-code" id="scan-source">
            <pre>static VALUE
rb_str_scan(VALUE str, VALUE pat)
{
    VALUE result;
    long start = 0;
    long last = -1, prev = 0;
    char *p = RSTRING_PTR(str); long len = RSTRING_LEN(str);

    pat = get_pat_quoted(pat, 1);
    mustnot_broken(str);
    if (!rb_block_given_p()) {
        VALUE ary = rb_ary_new();

        while (!NIL_P(result = scan_once(str, pat, &amp;start, 0))) {
            last = prev;
            prev = start;
            rb_ary_push(ary, result);
        }
        if (last &gt;= 0) rb_pat_search(pat, str, last, 1);
        else rb_backref_set(Qnil);
        return ary;
    }

    while (!NIL_P(result = scan_once(str, pat, &amp;start, 1))) {
        last = prev;
        prev = start;
        rb_yield(result);
        str_mod_check(str, p, len);
    }
    if (last &gt;= 0) rb_pat_search(pat, str, last, 1);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-scrub" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              scrub(replacement_string = default_replacement) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              scrub{|bytes| ... } &rarr; new_string
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with each invalid byte sequence replaced by the given <code>replacement_string</code>.</p>

<p>With no block given and no argument, replaces each invalid sequence with the default replacement string (<code>&quot;�&quot;</code> for a Unicode encoding, <code>&#39;?&#39;</code> otherwise):</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;foo\x81\x81bar&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">scrub</span> <span class="ruby-comment"># =&gt; &quot;foo��bar&quot;</span>
</pre>

<p>With no block given and argument <code>replacement_string</code> given, replaces each invalid sequence with that string:</p>

<pre class="ruby"><span class="ruby-string">&quot;foo\x81\x81bar&quot;</span>.<span class="ruby-identifier">scrub</span>(<span class="ruby-string">&#39;xyzzy&#39;</span>) <span class="ruby-comment"># =&gt; &quot;fooxyzzyxyzzybar&quot;</span>
</pre>

<p>With a block given, replaces each invalid sequence with the value of the block:</p>

<pre class="ruby"><span class="ruby-string">&quot;foo\x81\x81bar&quot;</span>.<span class="ruby-identifier">scrub</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">bytes</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">bytes</span>; <span class="ruby-string">&#39;XYZZY&#39;</span> }
<span class="ruby-comment"># =&gt; &quot;fooXYZZYXYZZYbar&quot;</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-string">&quot;\x81&quot;</span>
<span class="ruby-string">&quot;\x81&quot;</span>
</pre>

          <div class="method-source-code" id="scrub-source">
            <pre>static VALUE
str_scrub(int argc, VALUE *argv, VALUE str)
{
    VALUE repl = argc ? (rb_check_arity(argc, 0, 1), argv[0]) : Qnil;
    VALUE new = rb_str_scrub(str, repl);
    return NIL_P(new) ? str_duplicate(rb_cString, str): new;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-scrub-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              scrub! &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              scrub!(replacement_string = default_replacement) &rarr; self
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              scrub!{|bytes| ... } &rarr; self
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-scrub"><code>String#scrub</code></a>, except that any replacements are made in <code>self</code>.</p>

          <div class="method-source-code" id="scrub-21-source">
            <pre>static VALUE
str_scrub_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE repl = argc ? (rb_check_arity(argc, 0, 1), argv[0]) : Qnil;
    VALUE new = rb_str_scrub(str, repl);
    if (!NIL_P(new)) rb_str_replace(str, new);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-setbyte" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              setbyte(index, integer) &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Sets the byte at zero-based <code>index</code> to <code>integer</code>; returns <code>integer</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;abcde&#39;</span>      <span class="ruby-comment"># =&gt; &quot;abcde&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">setbyte</span>(<span class="ruby-value">0</span>, <span class="ruby-value">98</span>) <span class="ruby-comment"># =&gt; 98</span>
<span class="ruby-identifier">s</span>                <span class="ruby-comment"># =&gt; &quot;bbcde&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-getbyte"><code>String#getbyte</code></a>.</p>

          <div class="method-source-code" id="setbyte-source">
            <pre>static VALUE
rb_str_setbyte(VALUE str, VALUE index, VALUE value)
{
    long pos = NUM2LONG(index);
    long len = RSTRING_LEN(str);
    char *ptr, *head, *left = 0;
    rb_encoding *enc;
    int cr = ENC_CODERANGE_UNKNOWN, width, nlen;

    if (pos &lt; -len || len &lt;= pos)
        rb_raise(rb_eIndexError, &quot;index %ld out of string&quot;, pos);
    if (pos &lt; 0)
        pos += len;

    VALUE v = rb_to_int(value);
    VALUE w = rb_int_and(v, INT2FIX(0xff));
    char byte = (char)(NUM2INT(w) &amp; 0xFF);

    if (!str_independent(str))
        str_make_independent(str);
    enc = STR_ENC_GET(str);
    head = RSTRING_PTR(str);
    ptr = &amp;head[pos];
    if (!STR_EMBED_P(str)) {
        cr = ENC_CODERANGE(str);
        switch (cr) {
          case ENC_CODERANGE_7BIT:
            left = ptr;
            *ptr = byte;
            if (ISASCII(byte)) goto end;
            nlen = rb_enc_precise_mbclen(left, head+len, enc);
            if (!MBCLEN_CHARFOUND_P(nlen))
                ENC_CODERANGE_SET(str, ENC_CODERANGE_BROKEN);
            else
                ENC_CODERANGE_SET(str, ENC_CODERANGE_VALID);
            goto end;
          case ENC_CODERANGE_VALID:
            left = rb_enc_left_char_head(head, ptr, head+len, enc);
            width = rb_enc_precise_mbclen(left, head+len, enc);
            *ptr = byte;
            nlen = rb_enc_precise_mbclen(left, head+len, enc);
            if (!MBCLEN_CHARFOUND_P(nlen))
                ENC_CODERANGE_SET(str, ENC_CODERANGE_BROKEN);
            else if (MBCLEN_CHARFOUND_LEN(nlen) != width || ISASCII(byte))
                ENC_CODERANGE_CLEAR(str);
            goto end;
        }
    }
    ENC_CODERANGE_CLEAR(str);
    *ptr = byte;

  end:
    return value;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-shellescape" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              shellescape &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Escapes <code>str</code> so that it can be safely used in a Bourne shell command line.</p>

<p>See <a href="Shellwords.html#method-c-shellescape"><code>Shellwords.shellescape</code></a> for details.</p>

          <div class="method-source-code" id="shellescape-source">
            <pre><span class="ruby-comment"># File lib/shellwords.rb, line 224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shellescape</span>
  <span class="ruby-constant">Shellwords</span>.<span class="ruby-identifier">escape</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-shellsplit" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              shellsplit &rarr; array
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Splits <code>str</code> into an array of tokens in the same way the UNIX Bourne shell does.</p>

<p>See <a href="Shellwords.html#method-c-shellsplit"><code>Shellwords.shellsplit</code></a> for details.</p>

          <div class="method-source-code" id="shellsplit-source">
            <pre><span class="ruby-comment"># File lib/shellwords.rb, line 213</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">shellsplit</span>
  <span class="ruby-constant">Shellwords</span>.<span class="ruby-identifier">split</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-size" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">size</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the count of characters (not bytes) in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">length</span>        <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">length</span>       <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">length</span>   <span class="ruby-comment"># =&gt; 5</span>
</pre>

<p>Contrast with <a href="String.html#method-i-bytesize"><code>String#bytesize</code></a>:</p>

<pre class="ruby"><span class="ruby-string">&#39;foo&#39;</span>.<span class="ruby-identifier">bytesize</span>        <span class="ruby-comment"># =&gt; 3</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">bytesize</span>       <span class="ruby-comment"># =&gt; 8</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">bytesize</span>   <span class="ruby-comment"># =&gt; 15</span>
</pre>

<p><a href="String.html#method-i-size"><code>String#size</code></a> is an alias for <a href="String.html#method-i-length"><code>String#length</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-length">length</a>
        </div>
      </div>

      <div id="method-i-slice" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">slice</span><span
              class="method-args">(*args)</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the substring of <code>self</code> specified by the arguments. See examples at <a href="String.html#class-String-label-String+Slices">String Slices</a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-5B-5D">[]</a>
        </div>
      </div>

      <div id="method-i-slice-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              slice!(index)               &rarr; new_string or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              slice!(start, length)       &rarr; new_string or nil
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              slice!(range)               &rarr; new_string or nil
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              slice!(regexp, capture = 0) &rarr; new_string or nil
            </span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              slice!(substring)           &rarr; new_string or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Removes and returns the substring of <code>self</code> specified by the arguments. See <a href="String.html#class-String-label-String+Slices">String Slices</a>.</p>

<p>A few examples:</p>

<pre class="ruby"><span class="ruby-identifier">string</span> = <span class="ruby-string">&quot;This is a string&quot;</span>
<span class="ruby-identifier">string</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">2</span>)        <span class="ruby-comment">#=&gt; &quot;i&quot;</span>
<span class="ruby-identifier">string</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-value">3</span><span class="ruby-operator">..</span><span class="ruby-value">6</span>)     <span class="ruby-comment">#=&gt; &quot; is &quot;</span>
<span class="ruby-identifier">string</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-regexp">/s.*t/</span>)   <span class="ruby-comment">#=&gt; &quot;sa st&quot;</span>
<span class="ruby-identifier">string</span>.<span class="ruby-identifier">slice!</span>(<span class="ruby-string">&quot;r&quot;</span>)      <span class="ruby-comment">#=&gt; &quot;r&quot;</span>
<span class="ruby-identifier">string</span>                  <span class="ruby-comment">#=&gt; &quot;Thing&quot;</span>
</pre>

          <div class="method-source-code" id="slice-21-source">
            <pre>static VALUE
rb_str_slice_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE result = Qnil;
    VALUE indx;
    long beg, len = 1;
    char *p;

    rb_check_arity(argc, 1, 2);
    str_modify_keep_cr(str);
    indx = argv[0];
    if (RB_TYPE_P(indx, T_REGEXP)) {
        if (rb_reg_search(indx, str, 0, 0) &lt; 0) return Qnil;
        VALUE match = rb_backref_get();
        struct re_registers *regs = RMATCH_REGS(match);
        int nth = 0;
        if (argc &gt; 1 &amp;&amp; (nth = rb_reg_backref_number(match, argv[1])) &lt; 0) {
            if ((nth += regs-&gt;num_regs) &lt;= 0) return Qnil;
        }
        else if (nth &gt;= regs-&gt;num_regs) return Qnil;
        beg = BEG(nth);
        len = END(nth) - beg;
        goto subseq;
    }
    else if (argc == 2) {
        beg = NUM2LONG(indx);
        len = NUM2LONG(argv[1]);
        goto num_index;
    }
    else if (FIXNUM_P(indx)) {
        beg = FIX2LONG(indx);
        if (!(p = rb_str_subpos(str, beg, &amp;len))) return Qnil;
        if (!len) return Qnil;
        beg = p - RSTRING_PTR(str);
        goto subseq;
    }
    else if (RB_TYPE_P(indx, T_STRING)) {
        beg = rb_str_index(str, indx, 0);
        if (beg == -1) return Qnil;
        len = RSTRING_LEN(indx);
        result = str_duplicate(rb_cString, indx);
        goto squash;
    }
    else {
        switch (rb_range_beg_len(indx, &amp;beg, &amp;len, str_strlen(str, NULL), 0)) {
          case Qnil:
            return Qnil;
          case Qfalse:
            beg = NUM2LONG(indx);
            if (!(p = rb_str_subpos(str, beg, &amp;len))) return Qnil;
            if (!len) return Qnil;
            beg = p - RSTRING_PTR(str);
            goto subseq;
          default:
            goto num_index;
        }
    }

  num_index:
    if (!(p = rb_str_subpos(str, beg, &amp;len))) return Qnil;
    beg = p - RSTRING_PTR(str);

  subseq:
    result = rb_str_new(RSTRING_PTR(str)+beg, len);
    rb_enc_cr_str_copy_for_substr(result, str);

  squash:
    if (len &gt; 0) {
        if (beg == 0) {
            rb_str_drop_bytes(str, len);
        }
        else {
            char *sptr = RSTRING_PTR(str);
            long slen = RSTRING_LEN(str);
            if (beg + len &gt; slen) /* pathological check */
                len = slen - beg;
            memmove(sptr + beg,
                    sptr + beg + len,
                    slen - (beg + len));
            slen -= len;
            STR_SET_LEN(str, slen);
            TERM_FILL(&amp;sptr[slen], TERM_LEN(str));
        }
    }
    return result;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-split" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              split(field_sep = $;, limit = nil) &rarr; array
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              split(field_sep = $;, limit = nil) {|substring| ... } &rarr; self
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns an array of substrings of <code>self</code> that are the result of splitting <code>self</code> at each occurrence of the given field separator <code>field_sep</code>.</p>

<p>When <code>field_sep</code> is <code>$;</code>:</p>
<ul><li>
<p>If <code>$;</code> is <code>nil</code> (its default value), the split occurs just as if <code>field_sep</code> were given as a space character (see below).</p>
</li><li>
<p>If <code>$;</code> is a string, the split ocurs just as if <code>field_sep</code> were given as that string (see below).</p>
</li></ul>

<p>When <code>field_sep</code> is <code>&#39; &#39;</code> and <code>limit</code> is <code>nil</code>, the split occurs at each sequence of whitespace:</p>

<pre class="ruby"><span class="ruby-string">&#39;abc def ghi&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39; &#39;</span>)         <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;abc&quot;</span>, <span class="ruby-string">&quot;def&quot;</span>, <span class="ruby-string">&quot;ghi&quot;</span>]
<span class="ruby-string">&quot;abc \n\tdef\t\n  ghi&quot;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39; &#39;</span>) <span class="ruby-comment"># =&gt; [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]</span>
<span class="ruby-string">&#39;abc  def   ghi&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39; &#39;</span>)      <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;abc&quot;</span>, <span class="ruby-string">&quot;def&quot;</span>, <span class="ruby-string">&quot;ghi&quot;</span>]
<span class="ruby-string">&#39;&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39; &#39;</span>)                    <span class="ruby-operator">=&gt;</span> []
</pre>

<p>When <code>field_sep</code> is a string different from <code>&#39; &#39;</code> and <code>limit</code> is <code>nil</code>, the split occurs at each occurrence of <code>field_sep</code>; trailing empty substrings are not returned:</p>

<pre class="ruby"><span class="ruby-string">&#39;abracadabra&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;ab&#39;</span>)  <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;racad&quot;</span>, <span class="ruby-string">&quot;ra&quot;</span>]
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>)     <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;bcd&quot;</span>]
<span class="ruby-string">&#39;&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>)              <span class="ruby-operator">=&gt;</span> []
<span class="ruby-string">&#39;3.14159&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;1&#39;</span>)       <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;3.&quot;</span>, <span class="ruby-string">&quot;4&quot;</span>, <span class="ruby-string">&quot;59&quot;</span>]
<span class="ruby-string">&#39;!@#$%^$&amp;*($)_+&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;$&#39;</span>) <span class="ruby-comment"># =&gt; [&quot;!@#&quot;, &quot;%^&quot;, &quot;&amp;*(&quot;, &quot;)_+&quot;]</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;т&#39;</span>)          <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;ес&quot;</span>]
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;に&#39;</span>)     <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;こん&quot;</span>, <span class="ruby-string">&quot;ちは&quot;</span>]
</pre>

<p>When <code>field_sep</code> is a <a href="Regexp.html"><code>Regexp</code></a> and <code>limit</code> is <code>nil</code>, the split occurs at each occurrence of a match; trailing empty substrings are not returned:</p>

<pre class="ruby"><span class="ruby-string">&#39;abracadabra&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/ab/</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;racad&quot;, &quot;ra&quot;]</span>
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/a/</span>)   <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;bcd&quot;</span>]
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">//</span>)    <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;b&quot;</span>, <span class="ruby-string">&quot;c&quot;</span>, <span class="ruby-string">&quot;d&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>, <span class="ruby-string">&quot;a&quot;</span>]
<span class="ruby-string">&#39;1 + 1 == 2&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/\W+/</span>) <span class="ruby-comment"># =&gt; [&quot;1&quot;, &quot;1&quot;, &quot;2&quot;]</span>
</pre>

<p>If the Regexp contains groups, their matches are also included in the returned array:</p>

<pre class="ruby"><span class="ruby-string">&#39;1:2:3&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-regexp">/(:)()()/</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;1&quot;, &quot;:&quot;, &quot;&quot;, &quot;&quot;, &quot;2:3&quot;]</span>
</pre>

<p>As seen above, if <code>limit</code> is <code>nil</code>, trailing empty substrings are not returned; the same is true if <code>limit</code> is zero:</p>

<pre class="ruby"><span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>)   <span class="ruby-operator">=&gt;</span> [<span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;&quot;</span>, <span class="ruby-string">&quot;bcd&quot;</span>]
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;bcd&quot;]</span>
</pre>

<p>If <code>limit</code> is positive integer <code>n</code>, no more than <code>n - 1-</code> splits occur, so that at most <code>n</code> substrings are returned, and trailing empty substrings are included:</p>

<pre class="ruby"><span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">1</span>) <span class="ruby-comment"># =&gt; [&quot;aaabcdaaa&quot;]</span>
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;aabcdaaa&quot;]</span>
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">5</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;bcd&quot;, &quot;aa&quot;]</span>
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">7</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;bcd&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]</span>
<span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">8</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;bcd&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]</span>
</pre>

<p>Note that if <code>field_sep</code> is a Regexp containing groups, their matches are in the returned array, but do not count toward the limit.</p>

<p>If <code>limit</code> is negative, it behaves the same as if <code>limit</code> was <code>nil</code>, meaning that there is no limit, and trailing empty substrings are included:</p>

<pre class="ruby"><span class="ruby-string">&#39;aaabcdaaa&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39;a&#39;</span>, <span class="ruby-value">-1</span>) <span class="ruby-comment"># =&gt; [&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;bcd&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;]</span>
</pre>

<p>If a block is given, it is called with each substring:</p>

<pre class="ruby"><span class="ruby-string">&#39;abc def ghi&#39;</span>.<span class="ruby-identifier">split</span>(<span class="ruby-string">&#39; &#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">substring</span><span class="ruby-operator">|</span> <span class="ruby-identifier">p</span> <span class="ruby-identifier">substring</span> }
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-string">&quot;abc&quot;</span>
<span class="ruby-string">&quot;def&quot;</span>
<span class="ruby-string">&quot;ghi&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-partition"><code>String#partition</code></a>, <a href="String.html#method-i-rpartition"><code>String#rpartition</code></a>.</p>

          <div class="method-source-code" id="split-source">
            <pre>static VALUE
rb_str_split_m(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    VALUE spat;
    VALUE limit;
    split_type_t split_type;
    long beg, end, i = 0, empty_count = -1;
    int lim = 0;
    VALUE result, tmp;

    result = rb_block_given_p() ? Qfalse : Qnil;
    if (rb_scan_args(argc, argv, &quot;02&quot;, &amp;spat, &amp;limit) == 2) {
        lim = NUM2INT(limit);
        if (lim &lt;= 0) limit = Qnil;
        else if (lim == 1) {
            if (RSTRING_LEN(str) == 0)
                return result ? rb_ary_new2(0) : str;
            tmp = str_duplicate(rb_cString, str);
            if (!result) {
                rb_yield(tmp);
                return str;
            }
            return rb_ary_new3(1, tmp);
        }
        i = 1;
    }
    if (NIL_P(limit) &amp;&amp; !lim) empty_count = 0;

    enc = STR_ENC_GET(str);
    split_type = SPLIT_TYPE_REGEXP;
    if (!NIL_P(spat)) {
        spat = get_pat_quoted(spat, 0);
    }
    else if (NIL_P(spat = rb_fs)) {
        split_type = SPLIT_TYPE_AWK;
    }
    else if (!(spat = rb_fs_check(spat))) {
        rb_raise(rb_eTypeError, &quot;value of $; must be String or Regexp&quot;);
    }
    else {
        rb_category_warn(RB_WARN_CATEGORY_DEPRECATED, &quot;$; is set to non-nil value&quot;);
    }
    if (split_type != SPLIT_TYPE_AWK) {
        switch (BUILTIN_TYPE(spat)) {
          case T_REGEXP:
            rb_reg_options(spat); /* check if uninitialized */
            tmp = RREGEXP_SRC(spat);
            split_type = literal_split_pattern(tmp, SPLIT_TYPE_REGEXP);
            if (split_type == SPLIT_TYPE_AWK) {
                spat = tmp;
                split_type = SPLIT_TYPE_STRING;
            }
            break;

          case T_STRING:
            mustnot_broken(spat);
            split_type = literal_split_pattern(spat, SPLIT_TYPE_STRING);
            break;

          default:
            UNREACHABLE_RETURN(Qnil);
        }
    }

#define SPLIT_STR(beg, len) (empty_count = split_string(result, str, beg, len, empty_count))

    if (result) result = rb_ary_new();
    beg = 0;
    char *ptr = RSTRING_PTR(str);
    char *eptr = RSTRING_END(str);
    if (split_type == SPLIT_TYPE_AWK) {
        char *bptr = ptr;
        int skip = 1;
        unsigned int c;

        end = beg;
        if (is_ascii_string(str)) {
            while (ptr &lt; eptr) {
                c = (unsigned char)*ptr++;
                if (skip) {
                    if (ascii_isspace(c)) {
                        beg = ptr - bptr;
                    }
                    else {
                        end = ptr - bptr;
                        skip = 0;
                        if (!NIL_P(limit) &amp;&amp; lim &lt;= i) break;
                    }
                }
                else if (ascii_isspace(c)) {
                    SPLIT_STR(beg, end-beg);
                    skip = 1;
                    beg = ptr - bptr;
                    if (!NIL_P(limit)) ++i;
                }
                else {
                    end = ptr - bptr;
                }
            }
        }
        else {
            while (ptr &lt; eptr) {
                int n;

                c = rb_enc_codepoint_len(ptr, eptr, &amp;n, enc);
                ptr += n;
                if (skip) {
                    if (rb_isspace(c)) {
                        beg = ptr - bptr;
                    }
                    else {
                        end = ptr - bptr;
                        skip = 0;
                        if (!NIL_P(limit) &amp;&amp; lim &lt;= i) break;
                    }
                }
                else if (rb_isspace(c)) {
                    SPLIT_STR(beg, end-beg);
                    skip = 1;
                    beg = ptr - bptr;
                    if (!NIL_P(limit)) ++i;
                }
                else {
                    end = ptr - bptr;
                }
            }
        }
    }
    else if (split_type == SPLIT_TYPE_STRING) {
        char *str_start = ptr;
        char *substr_start = ptr;
        char *sptr = RSTRING_PTR(spat);
        long slen = RSTRING_LEN(spat);

        mustnot_broken(str);
        enc = rb_enc_check(str, spat);
        while (ptr &lt; eptr &amp;&amp;
               (end = rb_memsearch(sptr, slen, ptr, eptr - ptr, enc)) &gt;= 0) {
            /* Check we are at the start of a char */
            char *t = rb_enc_right_char_head(ptr, ptr + end, eptr, enc);
            if (t != ptr + end) {
                ptr = t;
                continue;
            }
            SPLIT_STR(substr_start - str_start, (ptr+end) - substr_start);
            ptr += end + slen;
            substr_start = ptr;
            if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
        }
        beg = ptr - str_start;
    }
    else if (split_type == SPLIT_TYPE_CHARS) {
        char *str_start = ptr;
        int n;

        mustnot_broken(str);
        enc = rb_enc_get(str);
        while (ptr &lt; eptr &amp;&amp;
               (n = rb_enc_precise_mbclen(ptr, eptr, enc)) &gt; 0) {
            SPLIT_STR(ptr - str_start, n);
            ptr += n;
            if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
        }
        beg = ptr - str_start;
    }
    else {
        long len = RSTRING_LEN(str);
        long start = beg;
        long idx;
        int last_null = 0;
        struct re_registers *regs;
        VALUE match = 0;

        for (; rb_reg_search(spat, str, start, 0) &gt;= 0;
             (match ? (rb_match_unbusy(match), rb_backref_set(match)) : (void)0)) {
            match = rb_backref_get();
            if (!result) rb_match_busy(match);
            regs = RMATCH_REGS(match);
            end = BEG(0);
            if (start == end &amp;&amp; BEG(0) == END(0)) {
                if (!ptr) {
                    SPLIT_STR(0, 0);
                    break;
                }
                else if (last_null == 1) {
                    SPLIT_STR(beg, rb_enc_fast_mbclen(ptr+beg, eptr, enc));
                    beg = start;
                }
                else {
                    if (start == len)
                        start++;
                    else
                        start += rb_enc_fast_mbclen(ptr+start,eptr,enc);
                    last_null = 1;
                    continue;
                }
            }
            else {
                SPLIT_STR(beg, end-beg);
                beg = start = END(0);
            }
            last_null = 0;

            for (idx=1; idx &lt; regs-&gt;num_regs; idx++) {
                if (BEG(idx) == -1) continue;
                SPLIT_STR(BEG(idx), END(idx)-BEG(idx));
            }
            if (!NIL_P(limit) &amp;&amp; lim &lt;= ++i) break;
        }
        if (match) rb_match_unbusy(match);
    }
    if (RSTRING_LEN(str) &gt; 0 &amp;&amp; (!NIL_P(limit) || RSTRING_LEN(str) &gt; beg || lim &lt; 0)) {
        SPLIT_STR(beg, RSTRING_LEN(str)-beg);
    }

    return result ? result : str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-squeeze" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              squeeze(*selectors) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with characters specified by <code>selectors</code> “squeezed” (see <a href="character_selectors_rdoc.html#label-Multiple+Character+Selectors">Multiple Character Selectors</a>):</p>

<p>“Squeezed” means that each multiple-character run of a selected character is squeezed down to a single character; with no arguments given, squeezes all characters:</p>

<pre class="ruby"><span class="ruby-string">&quot;yellow moon&quot;</span>.<span class="ruby-identifier">squeeze</span>                  <span class="ruby-comment">#=&gt; &quot;yelow mon&quot;</span>
<span class="ruby-string">&quot;  now   is  the&quot;</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-string">&quot; &quot;</span>)         <span class="ruby-comment">#=&gt; &quot; now is the&quot;</span>
<span class="ruby-string">&quot;putters shoot balls&quot;</span>.<span class="ruby-identifier">squeeze</span>(<span class="ruby-string">&quot;m-z&quot;</span>)   <span class="ruby-comment">#=&gt; &quot;puters shot balls&quot;</span>
</pre>

          <div class="method-source-code" id="squeeze-source">
            <pre>static VALUE
rb_str_squeeze(int argc, VALUE *argv, VALUE str)
{
    str = str_duplicate(rb_cString, str);
    rb_str_squeeze_bang(argc, argv, str);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-squeeze-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              squeeze!(*selectors) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-squeeze"><code>String#squeeze</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p>

          <div class="method-source-code" id="squeeze-21-source">
            <pre>static VALUE
rb_str_squeeze_bang(int argc, VALUE *argv, VALUE str)
{
    char squeez[TR_TABLE_SIZE];
    rb_encoding *enc = 0;
    VALUE del = 0, nodel = 0;
    unsigned char *s, *send, *t;
    int i, modify = 0;
    int ascompat, singlebyte = single_byte_optimizable(str);
    unsigned int save;

    if (argc == 0) {
        enc = STR_ENC_GET(str);
    }
    else {
        for (i=0; i&lt;argc; i++) {
            VALUE s = argv[i];

            StringValue(s);
            enc = rb_enc_check(str, s);
            if (singlebyte &amp;&amp; !single_byte_optimizable(s))
                singlebyte = 0;
            tr_setup_table(s, squeez, i==0, &amp;del, &amp;nodel, enc);
        }
    }

    str_modify_keep_cr(str);
    s = t = (unsigned char *)RSTRING_PTR(str);
    if (!s || RSTRING_LEN(str) == 0) return Qnil;
    send = (unsigned char *)RSTRING_END(str);
    save = -1;
    ascompat = rb_enc_asciicompat(enc);

    if (singlebyte) {
        while (s &lt; send) {
            unsigned int c = *s++;
            if (c != save || (argc &gt; 0 &amp;&amp; !squeez[c])) {
                *t++ = save = c;
            }
        }
    }
    else {
        while (s &lt; send) {
            unsigned int c;
            int clen;

            if (ascompat &amp;&amp; (c = *s) &lt; 0x80) {
                if (c != save || (argc &gt; 0 &amp;&amp; !squeez[c])) {
                    *t++ = save = c;
                }
                s++;
            }
            else {
                c = rb_enc_codepoint_len((char *)s, (char *)send, &amp;clen, enc);

                if (c != save || (argc &gt; 0 &amp;&amp; !tr_find(c, squeez, del, nodel))) {
                    if (t != s) rb_enc_mbcput(c, t, enc);
                    save = c;
                    t += clen;
                }
                s += clen;
            }
        }
    }

    TERM_FILL((char *)t, TERM_LEN(str));
    if ((char *)t - RSTRING_PTR(str) != RSTRING_LEN(str)) {
        STR_SET_LEN(str, (char *)t - RSTRING_PTR(str));
        modify = 1;
    }

    if (modify) return str;
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-start_with-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              start_with?(*string_or_regexp) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns whether <code>self</code> starts with any of the given <code>string_or_regexp</code>.</p>

<p>Matches patterns against the beginning of <code>self</code>. For each given <code>string_or_regexp</code>, the pattern is:</p>
<ul><li>
<p><code>string_or_regexp</code> itself, if it is a <a href="Regexp.html"><code>Regexp</code></a>.</p>
</li><li>
<p><code>Regexp.quote(string_or_regexp)</code>, if <code>string_or_regexp</code> is a string.</p>
</li></ul>

<p>Returns <code>true</code> if any pattern matches the beginning, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;hell&#39;</span>)               <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-regexp">/H/i</span>)                 <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;heaven&#39;</span>, <span class="ruby-string">&#39;hell&#39;</span>)     <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;heaven&#39;</span>, <span class="ruby-string">&#39;paradise&#39;</span>) <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;т&#39;</span>)                   <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">start_with?</span>(<span class="ruby-string">&#39;こ&#39;</span>)              <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Related: <a href="String.html#method-i-end_with-3F"><code>String#end_with?</code></a>.</p>

          <div class="method-source-code" id="start_with-3F-source">
            <pre>static VALUE
rb_str_start_with(int argc, VALUE *argv, VALUE str)
{
    int i;

    for (i=0; i&lt;argc; i++) {
        VALUE tmp = argv[i];
        if (RB_TYPE_P(tmp, T_REGEXP)) {
            if (rb_reg_start_with_p(tmp, str))
                return Qtrue;
        }
        else {
            StringValue(tmp);
            rb_enc_check(str, tmp);
            if (RSTRING_LEN(str) &lt; RSTRING_LEN(tmp)) continue;
            if (memcmp(RSTRING_PTR(str), RSTRING_PTR(tmp), RSTRING_LEN(tmp)) == 0)
                return Qtrue;
        }
    }
    return Qfalse;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-strip" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              strip &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of the receiver with leading and trailing whitespace removed; see <a href="String.html#class-String-label-Whitespace+in+Strings">Whitespace in Strings</a>:</p>

<pre class="ruby"><span class="ruby-identifier">whitespace</span> = <span class="ruby-string">&quot;\x00\t\n\v\f\r &quot;</span>
<span class="ruby-identifier">s</span> = <span class="ruby-identifier">whitespace</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;abc&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">whitespace</span>
<span class="ruby-identifier">s</span>       <span class="ruby-comment"># =&gt; &quot;\u0000\t\n\v\f\r abc\u0000\t\n\v\f\r &quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">strip</span> <span class="ruby-comment"># =&gt; &quot;abc&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-lstrip"><code>String#lstrip</code></a>, <a href="String.html#method-i-rstrip"><code>String#rstrip</code></a>.</p>

          <div class="method-source-code" id="strip-source">
            <pre>static VALUE
rb_str_strip(VALUE str)
{
    char *start;
    long olen, loffset, roffset;
    rb_encoding *enc = STR_ENC_GET(str);

    RSTRING_GETMEM(str, start, olen);
    loffset = lstrip_offset(str, start, start+olen, enc);
    roffset = rstrip_offset(str, start+loffset, start+olen, enc);

    if (loffset &lt;= 0 &amp;&amp; roffset &lt;= 0) return str_duplicate(rb_cString, str);
    return rb_str_subseq(str, loffset, olen-loffset-roffset);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-strip-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              strip! &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-strip"><code>String#strip</code></a>, except that any modifications are made in <code>self</code>; returns <code>self</code> if any modification are made, <code>nil</code> otherwise.</p>

<p>Related: <a href="String.html#method-i-lstrip-21"><code>String#lstrip!</code></a>, <a href="String.html#method-i-strip-21"><code>String#strip!</code></a>.</p>

          <div class="method-source-code" id="strip-21-source">
            <pre>static VALUE
rb_str_strip_bang(VALUE str)
{
    char *start;
    long olen, loffset, roffset;
    rb_encoding *enc;

    str_modify_keep_cr(str);
    enc = STR_ENC_GET(str);
    RSTRING_GETMEM(str, start, olen);
    loffset = lstrip_offset(str, start, start+olen, enc);
    roffset = rstrip_offset(str, start+loffset, start+olen, enc);

    if (loffset &gt; 0 || roffset &gt; 0) {
        long len = olen-roffset;
        if (loffset &gt; 0) {
            len -= loffset;
            memmove(start, start + loffset, len);
        }
        STR_SET_LEN(str, len);
        TERM_FILL(start+len, rb_enc_mbminlen(enc));
        return str;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-sub" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              sub(pattern, replacement)   &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              sub(pattern) {|match| ... } &rarr; new_string
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with only the first occurrence (not all occurrences) of the given <code>pattern</code> replaced.</p>

<p>See <a href="String.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p>

<p>Related: <a href="String.html#method-i-sub-21"><code>String#sub!</code></a>, <a href="String.html#method-i-gsub"><code>String#gsub</code></a>, <a href="String.html#method-i-gsub-21"><code>String#gsub!</code></a>.</p>

          <div class="method-source-code" id="sub-source">
            <pre>static VALUE
rb_str_sub(int argc, VALUE *argv, VALUE str)
{
    str = str_duplicate(rb_cString, str);
    rb_str_sub_bang(argc, argv, str);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-sub-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              sub!(pattern, replacement)   &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              sub!(pattern) {|match| ... } &rarr; self or nil
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code> with only the first occurrence (not all occurrences) of the given <code>pattern</code> replaced.</p>

<p>See <a href="String.html#class-String-label-Substitution+Methods">Substitution Methods</a>.</p>

<p>Related: <a href="String.html#method-i-sub"><code>String#sub</code></a>, <a href="String.html#method-i-gsub"><code>String#gsub</code></a>, <a href="String.html#method-i-gsub-21"><code>String#gsub!</code></a>.</p>

          <div class="method-source-code" id="sub-21-source">
            <pre>static VALUE
rb_str_sub_bang(int argc, VALUE *argv, VALUE str)
{
    VALUE pat, repl, hash = Qnil;
    int iter = 0;
    long plen;
    int min_arity = rb_block_given_p() ? 1 : 2;
    long beg;

    rb_check_arity(argc, min_arity, 2);
    if (argc == 1) {
        iter = 1;
    }
    else {
        repl = argv[1];
        hash = rb_check_hash_type(argv[1]);
        if (NIL_P(hash)) {
            StringValue(repl);
        }
    }

    pat = get_pat_quoted(argv[0], 1);

    str_modifiable(str);
    beg = rb_pat_search(pat, str, 0, 1);
    if (beg &gt;= 0) {
        rb_encoding *enc;
        int cr = ENC_CODERANGE(str);
        long beg0, end0;
        VALUE match, match0 = Qnil;
        struct re_registers *regs;
        char *p, *rp;
        long len, rlen;

        match = rb_backref_get();
        regs = RMATCH_REGS(match);
        if (RB_TYPE_P(pat, T_STRING)) {
            beg0 = beg;
            end0 = beg0 + RSTRING_LEN(pat);
            match0 = pat;
        }
        else {
            beg0 = BEG(0);
            end0 = END(0);
            if (iter) match0 = rb_reg_nth_match(0, match);
        }

        if (iter || !NIL_P(hash)) {
            p = RSTRING_PTR(str); len = RSTRING_LEN(str);

            if (iter) {
                repl = rb_obj_as_string(rb_yield(match0));
            }
            else {
                repl = rb_hash_aref(hash, rb_str_subseq(str, beg0, end0 - beg0));
                repl = rb_obj_as_string(repl);
            }
            str_mod_check(str, p, len);
            rb_check_frozen(str);
        }
        else {
            repl = rb_reg_regsub(repl, str, regs, RB_TYPE_P(pat, T_STRING) ? Qnil : pat);
        }

        enc = rb_enc_compatible(str, repl);
        if (!enc) {
            rb_encoding *str_enc = STR_ENC_GET(str);
            p = RSTRING_PTR(str); len = RSTRING_LEN(str);
            if (coderange_scan(p, beg0, str_enc) != ENC_CODERANGE_7BIT ||
                coderange_scan(p+end0, len-end0, str_enc) != ENC_CODERANGE_7BIT) {
                rb_raise(rb_eEncCompatError, &quot;incompatible character encodings: %s and %s&quot;,
                         rb_enc_name(str_enc),
                         rb_enc_name(STR_ENC_GET(repl)));
            }
            enc = STR_ENC_GET(repl);
        }
        rb_str_modify(str);
        rb_enc_associate(str, enc);
        if (ENC_CODERANGE_UNKNOWN &lt; cr &amp;&amp; cr &lt; ENC_CODERANGE_BROKEN) {
            int cr2 = ENC_CODERANGE(repl);
            if (cr2 == ENC_CODERANGE_BROKEN ||
                (cr == ENC_CODERANGE_VALID &amp;&amp; cr2 == ENC_CODERANGE_7BIT))
                cr = ENC_CODERANGE_UNKNOWN;
            else
                cr = cr2;
        }
        plen = end0 - beg0;
        rlen = RSTRING_LEN(repl);
        len = RSTRING_LEN(str);
        if (rlen &gt; plen) {
            RESIZE_CAPA(str, len + rlen - plen);
        }
        p = RSTRING_PTR(str);
        if (rlen != plen) {
            memmove(p + beg0 + rlen, p + beg0 + plen, len - beg0 - plen);
        }
        rp = RSTRING_PTR(repl);
        memmove(p + beg0, rp, rlen);
        len += rlen - plen;
        STR_SET_LEN(str, len);
        TERM_FILL(&amp;RSTRING_PTR(str)[len], TERM_LEN(str));
        ENC_CODERANGE_SET(str, cr);

        return str;
    }
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-succ" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              succ &rarr; new_str
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the successor to <code>self</code>. The successor is calculated by incrementing characters.</p>

<p>The first character to be incremented is the rightmost alphanumeric: or, if no alphanumerics, the rightmost character:</p>

<pre class="ruby"><span class="ruby-string">&#39;THX1138&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;THX1139&quot;</span>
<span class="ruby-string">&#39;&lt;&lt;koala&gt;&gt;&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;</span>
<span class="ruby-string">&#39;***&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &#39;**+&#39;</span>
</pre>

<p>The successor to a digit is another digit, “carrying” to the next-left character for a “rollover” from 9 to 0, and prepending another digit if necessary:</p>

<pre class="ruby"><span class="ruby-string">&#39;00&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;01&quot;</span>
<span class="ruby-string">&#39;09&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;10&quot;</span>
<span class="ruby-string">&#39;99&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;100&quot;</span>
</pre>

<p>The successor to a letter is another letter of the same case, carrying to the next-left character for a rollover, and prepending another same-case letter if necessary:</p>

<pre class="ruby"><span class="ruby-string">&#39;aa&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;ab&quot;</span>
<span class="ruby-string">&#39;az&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;ba&quot;</span>
<span class="ruby-string">&#39;zz&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;aaa&quot;</span>
<span class="ruby-string">&#39;AA&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;AB&quot;</span>
<span class="ruby-string">&#39;AZ&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;BA&quot;</span>
<span class="ruby-string">&#39;ZZ&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;AAA&quot;</span>
</pre>

<p>The successor to a non-alphanumeric character is the next character in the underlying character set’s collating sequence, carrying to the next-left character for a rollover, and prepending another character if necessary:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-value">0</span>.<span class="ruby-identifier">chr</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span>
<span class="ruby-identifier">s</span> <span class="ruby-comment"># =&gt; &quot;\x00\x00\x00&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;\x00\x00\x01&quot;</span>
<span class="ruby-identifier">s</span> = <span class="ruby-value">255</span>.<span class="ruby-identifier">chr</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span>
<span class="ruby-identifier">s</span> <span class="ruby-comment"># =&gt; &quot;\xFF\xFF\xFF&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;\x01\x00\x00\x00&quot;</span>
</pre>

<p>Carrying can occur between and among mixtures of alphanumeric characters:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;zz99zz99&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;aaa00aa00&quot;</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;99zz99zz&#39;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;100aa00aa&quot;</span>
</pre>

<p>The successor to an empty String is a new empty String:</p>

<pre class="ruby"><span class="ruby-string">&#39;&#39;</span>.<span class="ruby-identifier">succ</span> <span class="ruby-comment"># =&gt; &quot;&quot;</span>
</pre>

<p><a href="String.html#method-i-next"><code>String#next</code></a> is an alias for <a href="String.html#method-i-succ"><code>String#succ</code></a>.</p>

          <div class="method-source-code" id="succ-source">
            <pre>VALUE
rb_str_succ(VALUE orig)
{
    VALUE str;
    str = rb_str_new(RSTRING_PTR(orig), RSTRING_LEN(orig));
    rb_enc_cr_str_copy_for_substr(str, orig);
    return str_succ(str);
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-next">next</a>
        </div>

      </div>

      <div id="method-i-succ-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              succ! &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Equivalent to <a href="String.html#method-i-succ"><code>String#succ</code></a>, but modifies <code>self</code> in place; returns <code>self</code>.</p>

<p><a href="String.html#method-i-next-21"><code>String#next!</code></a> is an alias for <a href="String.html#method-i-succ-21"><code>String#succ!</code></a>.</p>

          <div class="method-source-code" id="succ-21-source">
            <pre>static VALUE
rb_str_succ_bang(VALUE str)
{
    rb_str_modify(str);
    str_succ(str);
    return str;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-next-21">next!</a>
        </div>

      </div>

      <div id="method-i-sum" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              sum(n = 16) &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a basic <code>n</code>-bit checksum of the characters in <code>self</code>; the checksum is the sum of the binary value of each byte in <code>self</code>, modulo <code>2**n - 1</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">sum</span>     <span class="ruby-comment"># =&gt; 532</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-value">4</span>)  <span class="ruby-comment"># =&gt; 4</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">sum</span>(<span class="ruby-value">64</span>) <span class="ruby-comment"># =&gt; 532</span>
<span class="ruby-string">&#39;тест&#39;</span>.<span class="ruby-identifier">sum</span>      <span class="ruby-comment"># =&gt; 1405</span>
<span class="ruby-string">&#39;こんにちは&#39;</span>.<span class="ruby-identifier">sum</span>  <span class="ruby-comment"># =&gt; 2582</span>
</pre>

<p>This is not a particularly strong checksum.</p>

          <div class="method-source-code" id="sum-source">
            <pre>static VALUE
rb_str_sum(int argc, VALUE *argv, VALUE str)
{
    int bits = 16;
    char *ptr, *p, *pend;
    long len;
    VALUE sum = INT2FIX(0);
    unsigned long sum0 = 0;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; (bits = NUM2INT(argv[0])) &lt; 0) {
        bits = 0;
    }
    ptr = p = RSTRING_PTR(str);
    len = RSTRING_LEN(str);
    pend = p + len;

    while (p &lt; pend) {
        if (FIXNUM_MAX - UCHAR_MAX &lt; sum0) {
            sum = rb_funcall(sum, &#39;+&#39;, 1, LONG2FIX(sum0));
            str_mod_check(str, ptr, len);
            sum0 = 0;
        }
        sum0 += (unsigned char)*p;
        p++;
    }

    if (bits == 0) {
        if (sum0) {
            sum = rb_funcall(sum, &#39;+&#39;, 1, LONG2FIX(sum0));
        }
    }
    else {
        if (sum == INT2FIX(0)) {
            if (bits &lt; (int)sizeof(long)*CHAR_BIT) {
                sum0 &amp;= (((unsigned long)1)&lt;&lt;bits)-1;
            }
            sum = LONG2FIX(sum0);
        }
        else {
            VALUE mod;

            if (sum0) {
                sum = rb_funcall(sum, &#39;+&#39;, 1, LONG2FIX(sum0));
            }

            mod = rb_funcall(INT2FIX(1), idLTLT, 1, INT2FIX(bits));
            mod = rb_funcall(mod, &#39;-&#39;, 1, INT2FIX(1));
            sum = rb_funcall(sum, &#39;&amp;&#39;, 1, mod);
        }
    }
    return sum;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-swapcase" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              swapcase(*options) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string containing the characters in <code>self</code>, with cases reversed; each uppercase character is downcased; each lowercase character is upcased:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;Hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;Hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">swapcase</span>         <span class="ruby-comment"># =&gt; &quot;hELLO wORLD!&quot;</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-swapcase-21"><code>String#swapcase!</code></a>.</p>

          <div class="method-source-code" id="swapcase-source">
            <pre>static VALUE
rb_str_swapcase(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (RSTRING_LEN(str) == 0 || !RSTRING_PTR(str)) return str_duplicate(rb_cString, str);
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }
    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-swapcase-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              swapcase!(*options) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Upcases each lowercase character in <code>self</code>; downcases uppercase character; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;Hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;Hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">swapcase!</span>        <span class="ruby-comment"># =&gt; &quot;hELLO wORLD!&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;hELLO wORLD!&quot;</span>
<span class="ruby-string">&#39;&#39;</span>.<span class="ruby-identifier">swapcase!</span>       <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-swapcase"><code>String#swapcase</code></a>.</p>

          <div class="method-source-code" id="swapcase-21-source">
            <pre>static VALUE
rb_str_swapcase_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE | ONIGENC_CASE_DOWNCASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_c" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_c  &rarr;  complex
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a complex which denotes the string form.  The parser ignores leading whitespaces and trailing garbage.  Any digit sequences can be separated by an underscore.  Returns zero for null or garbage string.</p>

<pre class="ruby"><span class="ruby-string">&#39;9&#39;</span>.<span class="ruby-identifier">to_c</span>           <span class="ruby-comment">#=&gt; (9+0i)</span>
<span class="ruby-string">&#39;2.5&#39;</span>.<span class="ruby-identifier">to_c</span>         <span class="ruby-comment">#=&gt; (2.5+0i)</span>
<span class="ruby-string">&#39;2.5/1&#39;</span>.<span class="ruby-identifier">to_c</span>       <span class="ruby-comment">#=&gt; ((5/2)+0i)</span>
<span class="ruby-string">&#39;-3/2&#39;</span>.<span class="ruby-identifier">to_c</span>        <span class="ruby-comment">#=&gt; ((-3/2)+0i)</span>
<span class="ruby-string">&#39;-i&#39;</span>.<span class="ruby-identifier">to_c</span>          <span class="ruby-comment">#=&gt; (0-1i)</span>
<span class="ruby-string">&#39;45i&#39;</span>.<span class="ruby-identifier">to_c</span>         <span class="ruby-comment">#=&gt; (0+45i)</span>
<span class="ruby-string">&#39;3-4i&#39;</span>.<span class="ruby-identifier">to_c</span>        <span class="ruby-comment">#=&gt; (3-4i)</span>
<span class="ruby-string">&#39;-4e2-4e-2i&#39;</span>.<span class="ruby-identifier">to_c</span>  <span class="ruby-comment">#=&gt; (-400.0-0.04i)</span>
<span class="ruby-string">&#39;-0.0-0.0i&#39;</span>.<span class="ruby-identifier">to_c</span>   <span class="ruby-comment">#=&gt; (-0.0-0.0i)</span>
<span class="ruby-string">&#39;1/2+3/4i&#39;</span>.<span class="ruby-identifier">to_c</span>    <span class="ruby-comment">#=&gt; ((1/2)+(3/4)*i)</span>
<span class="ruby-string">&#39;ruby&#39;</span>.<span class="ruby-identifier">to_c</span>        <span class="ruby-comment">#=&gt; (0+0i)</span>
</pre>

<p>Polar form:</p>

<pre class="ruby"><span class="ruby-identifier">include</span> <span class="ruby-constant">Math</span>
<span class="ruby-string">&quot;1.0@0&quot;</span>.<span class="ruby-identifier">to_c</span>        <span class="ruby-comment">#=&gt; (1+0.0i)</span>
<span class="ruby-node">&quot;1.0@#{PI/2}&quot;</span>.<span class="ruby-identifier">to_c</span>  <span class="ruby-comment">#=&gt; (0.0+1i)</span>
<span class="ruby-node">&quot;1.0@#{PI}&quot;</span>.<span class="ruby-identifier">to_c</span>    <span class="ruby-comment">#=&gt; (-1+0.0i)</span>
</pre>

<p>See <a href="Complex.html"><code>Kernel.Complex</code></a>.</p>

          <div class="method-source-code" id="to_c-source">
            <pre>static VALUE
string_to_c(VALUE self)
{
    char *s;
    VALUE num;

    rb_must_asciicompat(self);

    s = RSTRING_PTR(self);

    if (s &amp;&amp; s[RSTRING_LEN(self)]) {
        rb_str_modify(self);
        s = RSTRING_PTR(self);
        s[RSTRING_LEN(self)] = &#39;\0&#39;;
    }

    if (!s)
        s = (char *)&quot;&quot;;

    (void)parse_comp(s, 0, &amp;num);

    return num;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_d" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_d  &rarr; bigdecimal
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the result of interpreting leading characters in <code>str</code> as a <a href="BigDecimal.html"><code>BigDecimal</code></a>.</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal&#39;</span>
<span class="ruby-identifier">require</span> <span class="ruby-string">&#39;bigdecimal/util&#39;</span>

<span class="ruby-string">&quot;0.5&quot;</span>.<span class="ruby-identifier">to_d</span>             <span class="ruby-comment"># =&gt; 0.5e0</span>
<span class="ruby-string">&quot;123.45e1&quot;</span>.<span class="ruby-identifier">to_d</span>        <span class="ruby-comment"># =&gt; 0.12345e4</span>
<span class="ruby-string">&quot;45.67 degrees&quot;</span>.<span class="ruby-identifier">to_d</span>   <span class="ruby-comment"># =&gt; 0.4567e2</span>
</pre>

<p>See also <a href="BasicObject.html#method-c-new"><code>BigDecimal::new</code></a>.</p>

          <div class="method-source-code" id="to_d-source">
            <pre><span class="ruby-comment"># File ext/bigdecimal/lib/bigdecimal/util.rb, line 72</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">to_d</span>
  <span class="ruby-constant">BigDecimal</span>.<span class="ruby-identifier">interpret_loosely</span>(<span class="ruby-keyword">self</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_f" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_f &rarr; float
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the result of interpreting leading characters in <code>self</code> as a Float:</p>

<pre class="ruby"><span class="ruby-string">&#39;3.14159&#39;</span>.<span class="ruby-identifier">to_f</span>  <span class="ruby-comment"># =&gt; 3.14159</span>
<span class="ruby-string">&#39;1.234e-2&#39;</span>.<span class="ruby-identifier">to_f</span> <span class="ruby-comment"># =&gt; 0.01234</span>
</pre>

<p>Characters past a leading valid number (in the given <code>base</code>) are ignored:</p>

<pre class="ruby"><span class="ruby-string">&#39;3.14 (pi to two places)&#39;</span>.<span class="ruby-identifier">to_f</span> <span class="ruby-comment"># =&gt; 3.14</span>
</pre>

<p>Returns zero if there is no leading valid number:</p>

<pre class="ruby"><span class="ruby-string">&#39;abcdef&#39;</span>.<span class="ruby-identifier">to_f</span> <span class="ruby-comment"># =&gt; 0.0</span>
</pre>

          <div class="method-source-code" id="to_f-source">
            <pre>static VALUE
rb_str_to_f(VALUE str)
{
    return DBL2NUM(rb_str_to_dbl(str, FALSE));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_i" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_i(base = 10) &rarr; integer
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the result of interpreting leading characters in <code>self</code> as an integer in the given <code>base</code> (which must be in (0, 2..36)):</p>

<pre class="ruby"><span class="ruby-string">&#39;123456&#39;</span>.<span class="ruby-identifier">to_i</span>     <span class="ruby-comment"># =&gt; 123456</span>
<span class="ruby-string">&#39;123def&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">16</span>) <span class="ruby-comment"># =&gt; 1195503</span>
</pre>

<p>With <code>base</code> zero, string <code>object</code> may contain leading characters to specify the actual base:</p>

<pre class="ruby"><span class="ruby-string">&#39;123def&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">0</span>)   <span class="ruby-comment"># =&gt; 123</span>
<span class="ruby-string">&#39;0123def&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">0</span>)  <span class="ruby-comment"># =&gt; 83</span>
<span class="ruby-string">&#39;0b123def&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; 1</span>
<span class="ruby-string">&#39;0o123def&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; 83</span>
<span class="ruby-string">&#39;0d123def&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; 123</span>
<span class="ruby-string">&#39;0x123def&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">0</span>) <span class="ruby-comment"># =&gt; 1195503</span>
</pre>

<p>Characters past a leading valid number (in the given <code>base</code>) are ignored:</p>

<pre class="ruby"><span class="ruby-string">&#39;12.345&#39;</span>.<span class="ruby-identifier">to_i</span>   <span class="ruby-comment"># =&gt; 12</span>
<span class="ruby-string">&#39;12345&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">2</span>) <span class="ruby-comment"># =&gt; 1</span>
</pre>

<p>Returns zero if there is no leading valid number:</p>

<pre class="ruby"><span class="ruby-string">&#39;abcdef&#39;</span>.<span class="ruby-identifier">to_i</span> <span class="ruby-comment"># =&gt; 0</span>
<span class="ruby-string">&#39;2&#39;</span>.<span class="ruby-identifier">to_i</span>(<span class="ruby-value">2</span>)   <span class="ruby-comment"># =&gt; 0</span>
</pre>

          <div class="method-source-code" id="to_i-source">
            <pre>static VALUE
rb_str_to_i(int argc, VALUE *argv, VALUE str)
{
    int base = 10;

    if (rb_check_arity(argc, 0, 1) &amp;&amp; (base = NUM2INT(argv[0])) &lt; 0) {
        rb_raise(rb_eArgError, &quot;invalid radix %d&quot;, base);
    }
    return rb_str_to_inum(str, base, FALSE);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_r" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_r  &rarr;  rational
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the result of interpreting leading characters in <code>str</code> as a rational.  Leading whitespace and extraneous characters past the end of a valid number are ignored. Digit sequences can be separated by an underscore. If there is not a valid number at the start of <code>str</code>, zero is returned.  This method never raises an exception.</p>

<pre class="ruby"><span class="ruby-string">&#39;  2  &#39;</span>.<span class="ruby-identifier">to_r</span>       <span class="ruby-comment">#=&gt; (2/1)</span>
<span class="ruby-string">&#39;300/2&#39;</span>.<span class="ruby-identifier">to_r</span>       <span class="ruby-comment">#=&gt; (150/1)</span>
<span class="ruby-string">&#39;-9.2&#39;</span>.<span class="ruby-identifier">to_r</span>        <span class="ruby-comment">#=&gt; (-46/5)</span>
<span class="ruby-string">&#39;-9.2e2&#39;</span>.<span class="ruby-identifier">to_r</span>      <span class="ruby-comment">#=&gt; (-920/1)</span>
<span class="ruby-string">&#39;1_234_567&#39;</span>.<span class="ruby-identifier">to_r</span>   <span class="ruby-comment">#=&gt; (1234567/1)</span>
<span class="ruby-string">&#39;21 June 09&#39;</span>.<span class="ruby-identifier">to_r</span>  <span class="ruby-comment">#=&gt; (21/1)</span>
<span class="ruby-string">&#39;21/06/09&#39;</span>.<span class="ruby-identifier">to_r</span>    <span class="ruby-comment">#=&gt; (7/2)</span>
<span class="ruby-string">&#39;BWV 1079&#39;</span>.<span class="ruby-identifier">to_r</span>    <span class="ruby-comment">#=&gt; (0/1)</span>
</pre>

<p>NOTE: “0.3”.to_r isn’t the same as 0.3.to_r.  The former is equivalent to “3/10”.to_r, but the latter isn’t so.</p>

<pre class="ruby"><span class="ruby-string">&quot;0.3&quot;</span>.<span class="ruby-identifier">to_r</span> <span class="ruby-operator">==</span> <span class="ruby-value">3</span><span class="ruby-operator">/</span><span class="ruby-value">10r</span>  <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-value">0.3</span>.<span class="ruby-identifier">to_r</span>   <span class="ruby-operator">==</span> <span class="ruby-value">3</span><span class="ruby-operator">/</span><span class="ruby-value">10r</span>  <span class="ruby-comment">#=&gt; false</span>
</pre>

<p>See also <a href="Kernel.html#method-i-Rational"><code>Kernel#Rational</code></a>.</p>

          <div class="method-source-code" id="to_r-source">
            <pre>static VALUE
string_to_r(VALUE self)
{
    VALUE num;

    rb_must_asciicompat(self);

    num = parse_rat(RSTRING_PTR(self), RSTRING_END(self), 0, TRUE);

    if (RB_FLOAT_TYPE_P(num) &amp;&amp; !FLOAT_ZERO_P(num))
        rb_raise(rb_eFloatDomainError, &quot;Infinity&quot;);
    return num;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-to_s" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_s &rarr; self or string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code> if <code>self</code> is a String, or <code>self</code> converted to a String if <code>self</code> is a subclass of String.</p>

<p><a href="String.html#method-i-to_str"><code>String#to_str</code></a> is an alias for <a href="String.html#method-i-to_s"><code>String#to_s</code></a>.</p>

          <div class="method-source-code" id="to_s-source">
            <pre>static VALUE
rb_str_to_s(VALUE str)
{
    if (rb_obj_class(str) != rb_cString) {
        return str_duplicate(rb_cString, str);
    }
    return str;
}</pre>
          </div>
        </div>

        <div class="aliases">
          Also aliased as: <a href="String.html#method-i-to_str">to_str</a>
        </div>

      </div>

      <div id="method-i-to_str" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">to_str</span><span
              class="method-args">()</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>self</code> if <code>self</code> is a String, or <code>self</code> converted to a String if <code>self</code> is a subclass of String.</p>

<p><a href="String.html#method-i-to_str"><code>String#to_str</code></a> is an alias for <a href="String.html#method-i-to_s"><code>String#to_s</code></a>.</p>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-to_s">to_s</a>
        </div>
      </div>

      <div id="method-i-to_sym" class="method-detail method-alias">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              to_sym   &rarr; symbol
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns the <a href="Symbol.html"><code>Symbol</code></a> corresponding to <em>str</em>, creating the symbol if it did not previously exist. See <a href="Symbol.html#method-i-id2name"><code>Symbol#id2name</code></a>.</p>

<pre class="ruby"><span class="ruby-string">&quot;Koala&quot;</span>.<span class="ruby-identifier">intern</span>         <span class="ruby-comment">#=&gt; :Koala</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;cat&#39;</span>.<span class="ruby-identifier">to_sym</span>       <span class="ruby-comment">#=&gt; :cat</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-value">:cat</span>              <span class="ruby-comment">#=&gt; true</span>
<span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;@cat&#39;</span>.<span class="ruby-identifier">to_sym</span>      <span class="ruby-comment">#=&gt; :@cat</span>
<span class="ruby-identifier">s</span> <span class="ruby-operator">==</span> <span class="ruby-value">:@cat</span>             <span class="ruby-comment">#=&gt; true</span>
</pre>

<p>This can also be used to create symbols that cannot be represented using the <code>:xxx</code> notation.</p>

<pre class="ruby"><span class="ruby-string">&#39;cat and dog&#39;</span>.<span class="ruby-identifier">to_sym</span>   <span class="ruby-comment">#=&gt; :&quot;cat and dog&quot;</span>
</pre>

        </div>


        <div class="aliases">
          Alias for: <a href="String.html#method-i-intern">intern</a>
        </div>
      </div>

      <div id="method-i-toeuc" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#toeuc   &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to EUC-JP</p>

          <div class="method-source-code" id="toeuc-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 224</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">toeuc</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">toeuc</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-tojis" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#tojis   &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to ISO-2022-JP</p>

          <div class="method-source-code" id="tojis-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 218</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tojis</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">tojis</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-tolocale" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#tolocale   &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to locale encoding</p>

          <div class="method-source-code" id="tolocale-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 254</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tolocale</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">tolocale</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-tosjis" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#tosjis   &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to Shift_JIS</p>

          <div class="method-source-code" id="tosjis-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 230</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">tosjis</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">tosjis</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-toutf16" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#toutf16   &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to UTF-16</p>

          <div class="method-source-code" id="toutf16-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 242</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">toutf16</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">toutf16</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-toutf32" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#toutf32   &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to UTF-32</p>

          <div class="method-source-code" id="toutf32-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 248</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">toutf32</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">toutf32</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-toutf8" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              String#toutf8   &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Convert <code>self</code> to UTF-8</p>

          <div class="method-source-code" id="toutf8-source">
            <pre><span class="ruby-comment"># File ext/nkf/lib/kconv.rb, line 236</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">toutf8</span>; <span class="ruby-constant">Kconv</span>.<span class="ruby-identifier">toutf8</span>(<span class="ruby-keyword">self</span>) <span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-tr" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              tr(selector, replacements) &rarr; new_string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with each character specified by string <code>selector</code> translated to the corresponding character in string <code>replacements</code>. The correspondence is <em>positional</em>:</p>
<ul><li>
<p>Each occurrence of the first character specified by <code>selector</code> is translated to the first character in <code>replacements</code>.</p>
</li><li>
<p>Each occurrence of the second character specified by <code>selector</code> is translated to the second character in <code>replacements</code>.</p>
</li><li>
<p>And so on.</p>
</li></ul>

<p>Example:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;el&#39;</span>, <span class="ruby-string">&#39;ip&#39;</span>) <span class="ruby-comment">#=&gt; &quot;hippo&quot;</span>
</pre>

<p>If <code>replacements</code> is shorter than <code>selector</code>, it is implicitly padded with its own last character:</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;aeiou&#39;</span>, <span class="ruby-string">&#39;-&#39;</span>)   <span class="ruby-comment"># =&gt; &quot;h-ll-&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;aeiou&#39;</span>, <span class="ruby-string">&#39;AA-&#39;</span>) <span class="ruby-comment"># =&gt; &quot;hAll-&quot;</span>
</pre>

<p>Arguments <code>selector</code> and <code>replacements</code> must be valid character selectors (see <a href="character_selectors_rdoc.html">Character Selectors</a>), and may use any of its valid forms, including negation, ranges, and escaping:</p>

<pre class="ruby"><span class="ruby-comment"># Negation.</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;^aeiou&#39;</span>, <span class="ruby-string">&#39;-&#39;</span>) <span class="ruby-comment"># =&gt; &quot;-e--o&quot;</span>
<span class="ruby-comment"># Ranges.</span>
<span class="ruby-string">&#39;ibm&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;b-z&#39;</span>, <span class="ruby-string">&#39;a-z&#39;</span>) <span class="ruby-comment"># =&gt; &quot;hal&quot;</span>
<span class="ruby-comment"># Escapes.</span>
<span class="ruby-string">&#39;hel^lo&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;\^aeiou&#39;</span>, <span class="ruby-string">&#39;-&#39;</span>)     <span class="ruby-comment"># =&gt; &quot;h-l-l-&quot;    # Escaped leading caret.</span>
<span class="ruby-string">&#39;i-b-m&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;b\-z&#39;</span>, <span class="ruby-string">&#39;a-z&#39;</span>)       <span class="ruby-comment"># =&gt; &quot;ibabm&quot;     # Escaped embedded hyphen.</span>
<span class="ruby-string">&#39;foo\\bar&#39;</span>.<span class="ruby-identifier">tr</span>(<span class="ruby-string">&#39;ab\\&#39;</span>, <span class="ruby-string">&#39;XYZ&#39;</span>)    <span class="ruby-comment"># =&gt; &quot;fooZYXr&quot;   # Escaped backslash.</span>
</pre>

          <div class="method-source-code" id="tr-source">
            <pre>static VALUE
rb_str_tr(VALUE str, VALUE src, VALUE repl)
{
    str = str_duplicate(rb_cString, str);
    tr_trans(str, src, repl, 0);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-tr-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              tr!(selector, replacements) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-tr"><code>String#tr</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p>

          <div class="method-source-code" id="tr-21-source">
            <pre>static VALUE
rb_str_tr_bang(VALUE str, VALUE src, VALUE repl)
{
    return tr_trans(str, src, repl, 0);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-tr_s" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              tr_s(selector, replacements) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-tr"><code>String#tr</code></a>, but also squeezes the modified portions of the translated string; returns a new string (translated and squeezed).</p>

<pre class="ruby"><span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">tr_s</span>(<span class="ruby-string">&#39;l&#39;</span>, <span class="ruby-string">&#39;r&#39;</span>)   <span class="ruby-comment">#=&gt; &quot;hero&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">tr_s</span>(<span class="ruby-string">&#39;el&#39;</span>, <span class="ruby-string">&#39;-&#39;</span>)  <span class="ruby-comment">#=&gt; &quot;h-o&quot;</span>
<span class="ruby-string">&#39;hello&#39;</span>.<span class="ruby-identifier">tr_s</span>(<span class="ruby-string">&#39;el&#39;</span>, <span class="ruby-string">&#39;hx&#39;</span>) <span class="ruby-comment">#=&gt; &quot;hhxo&quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-squeeze"><code>String#squeeze</code></a>.</p>

          <div class="method-source-code" id="tr_s-source">
            <pre>static VALUE
rb_str_tr_s(VALUE str, VALUE src, VALUE repl)
{
    str = str_duplicate(rb_cString, str);
    tr_trans(str, src, repl, 1);
    return str;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-tr_s-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              tr_s!(selector, replacements) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-tr_s"><code>String#tr_s</code></a>, but modifies <code>self</code> in place. Returns <code>self</code> if any changes were made, <code>nil</code> otherwise.</p>

<p>Related: <a href="String.html#method-i-squeeze-21"><code>String#squeeze!</code></a>.</p>

          <div class="method-source-code" id="tr_s-21-source">
            <pre>static VALUE
rb_str_tr_s_bang(VALUE str, VALUE src, VALUE repl)
{
    return tr_trans(str, src, repl, 1);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-undump" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              undump &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns an unescaped version of <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s_orig</span> = <span class="ruby-string">&quot;\f\x00\xff\\\&quot;&quot;</span>    <span class="ruby-comment"># =&gt; &quot;\f\u0000\xFF\\\&quot;&quot;</span>
<span class="ruby-identifier">s_dumped</span> = <span class="ruby-identifier">s_orig</span>.<span class="ruby-identifier">dump</span>       <span class="ruby-comment"># =&gt; &quot;\&quot;\\f\\x00\\xFF\\\\\\\&quot;\&quot;&quot;</span>
<span class="ruby-identifier">s_undumped</span> = <span class="ruby-identifier">s_dumped</span>.<span class="ruby-identifier">undump</span> <span class="ruby-comment"># =&gt; &quot;\f\u0000\xFF\\\&quot;&quot;</span>
<span class="ruby-identifier">s_undumped</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">s_orig</span>         <span class="ruby-comment"># =&gt; true</span>
</pre>

<p>Related: <a href="String.html#method-i-dump"><code>String#dump</code></a> (inverse of <a href="String.html#method-i-undump"><code>String#undump</code></a>).</p>

          <div class="method-source-code" id="undump-source">
            <pre>static VALUE
str_undump(VALUE str)
{
    const char *s = RSTRING_PTR(str);
    const char *s_end = RSTRING_END(str);
    rb_encoding *enc = rb_enc_get(str);
    VALUE undumped = rb_enc_str_new(s, 0L, enc);
    bool utf8 = false;
    bool binary = false;
    int w;

    rb_must_asciicompat(str);
    if (rb_str_is_ascii_only_p(str) == Qfalse) {
        rb_raise(rb_eRuntimeError, &quot;non-ASCII character detected&quot;);
    }
    if (!str_null_check(str, &amp;w)) {
        rb_raise(rb_eRuntimeError, &quot;string contains null byte&quot;);
    }
    if (RSTRING_LEN(str) &lt; 2) goto invalid_format;
    if (*s != &#39;&quot;&#39;) goto invalid_format;

    /* strip &#39;&quot;&#39; at the start */
    s++;

    for (;;) {
        if (s &gt;= s_end) {
            rb_raise(rb_eRuntimeError, &quot;unterminated dumped string&quot;);
        }

        if (*s == &#39;&quot;&#39;) {
            /* epilogue */
            s++;
            if (s == s_end) {
                /* ascii compatible dumped string */
                break;
            }
            else {
                static const char force_encoding_suffix[] = &quot;.force_encoding(\&quot;&quot;; /* &quot;\&quot;)&quot; */
                static const char dup_suffix[] = &quot;.dup&quot;;
                const char *encname;
                int encidx;
                ptrdiff_t size;

                /* check separately for strings dumped by older versions */
                size = sizeof(dup_suffix) - 1;
                if (s_end - s &gt; size &amp;&amp; memcmp(s, dup_suffix, size) == 0) s += size;

                size = sizeof(force_encoding_suffix) - 1;
                if (s_end - s &lt;= size) goto invalid_format;
                if (memcmp(s, force_encoding_suffix, size) != 0) goto invalid_format;
                s += size;

                if (utf8) {
                    rb_raise(rb_eRuntimeError, &quot;dumped string contained Unicode escape but used force_encoding&quot;);
                }

                encname = s;
                s = memchr(s, &#39;&quot;&#39;, s_end-s);
                size = s - encname;
                if (!s) goto invalid_format;
                if (s_end - s != 2) goto invalid_format;
                if (s[0] != &#39;&quot;&#39; || s[1] != &#39;)&#39;) goto invalid_format;

                encidx = rb_enc_find_index2(encname, (long)size);
                if (encidx &lt; 0) {
                    rb_raise(rb_eRuntimeError, &quot;dumped string has unknown encoding name&quot;);
                }
                rb_enc_associate_index(undumped, encidx);
            }
            break;
        }

        if (*s == &#39;\\&#39;) {
            s++;
            if (s &gt;= s_end) {
                rb_raise(rb_eRuntimeError, &quot;invalid escape&quot;);
            }
            undump_after_backslash(undumped, &amp;s, s_end, &amp;enc, &amp;utf8, &amp;binary);
        }
        else {
            rb_str_cat(undumped, s++, 1);
        }
    }

    return undumped;
invalid_format:
    rb_raise(rb_eRuntimeError, &quot;invalid dumped string; not wrapped with &#39;\&quot;&#39; nor &#39;\&quot;...\&quot;.force_encoding(\&quot;...\&quot;)&#39; form&quot;);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-unicode_normalize" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              unicode_normalize(form = :nfc) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a copy of <code>self</code> with <a href="https://unicode.org/reports/tr15">Unicode normalization</a> applied.</p>

<p>Argument <code>form</code> must be one of the following symbols (see <a href="https://unicode.org/reports/tr15/#Norm_Forms">Unicode normalization forms</a>):</p>
<ul><li>
<p><code>:nfc</code>: Canonical decomposition, followed by canonical composition.</p>
</li><li>
<p><code>:nfd</code>: Canonical decomposition.</p>
</li><li>
<p><code>:nfkc</code>: Compatibility decomposition, followed by canonical composition.</p>
</li><li>
<p><code>:nfkd</code>: Compatibility decomposition.</p>
</li></ul>

<p>The encoding of <code>self</code> must be one of:</p>
<ul><li>
<p>Encoding::UTF_8</p>
</li><li>
<p>Encoding::UTF_16BE</p>
</li><li>
<p>Encoding::UTF_16LE</p>
</li><li>
<p>Encoding::UTF_32BE</p>
</li><li>
<p>Encoding::UTF_32LE</p>
</li><li>
<p>Encoding::GB18030</p>
</li><li>
<p>Encoding::UCS_2BE</p>
</li><li>
<p>Encoding::UCS_4BE</p>
</li></ul>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-string">&quot;a\u0300&quot;</span>.<span class="ruby-identifier">unicode_normalize</span>      <span class="ruby-comment"># =&gt; &quot;a&quot;</span>
<span class="ruby-string">&quot;\u00E0&quot;</span>.<span class="ruby-identifier">unicode_normalize</span>(<span class="ruby-value">:nfd</span>) <span class="ruby-comment"># =&gt; &quot;a &quot;</span>
</pre>

<p>Related: <a href="String.html#method-i-unicode_normalize-21"><code>String#unicode_normalize!</code></a>, <a href="String.html#method-i-unicode_normalized-3F"><code>String#unicode_normalized?</code></a>.</p>

          <div class="method-source-code" id="unicode_normalize-source">
            <pre>static VALUE
rb_str_unicode_normalize(int argc, VALUE *argv, VALUE str)
{
    return unicode_normalize_common(argc, argv, str, id_normalize);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-unicode_normalize-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              unicode_normalize!(form = :nfc) &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-unicode_normalize"><code>String#unicode_normalize</code></a>, except that the normalization is performed on <code>self</code>.</p>

<p>Related <a href="String.html#method-i-unicode_normalized-3F"><code>String#unicode_normalized?</code></a>.</p>

          <div class="method-source-code" id="unicode_normalize-21-source">
            <pre>static VALUE
rb_str_unicode_normalize_bang(int argc, VALUE *argv, VALUE str)
{
    return rb_str_replace(str, unicode_normalize_common(argc, argv, str, id_normalize));
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-unicode_normalized-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              unicode_normalized?(form = :nfc) &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is in the given <code>form</code> of Unicode normalization, <code>false</code> otherwise. The <code>form</code> must be one of <code>:nfc</code>, <code>:nfd</code>, <code>:nfkc</code>, or <code>:nfkd</code>.</p>

<p>Examples:</p>

<pre class="ruby"><span class="ruby-string">&quot;a\u0300&quot;</span>.<span class="ruby-identifier">unicode_normalized?</span>       <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&quot;a\u0300&quot;</span>.<span class="ruby-identifier">unicode_normalized?</span>(<span class="ruby-value">:nfd</span>) <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&quot;\u00E0&quot;</span>.<span class="ruby-identifier">unicode_normalized?</span>        <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&quot;\u00E0&quot;</span>.<span class="ruby-identifier">unicode_normalized?</span>(<span class="ruby-value">:nfd</span>)  <span class="ruby-comment"># =&gt; false</span>
</pre>

<p>Raises an exception if <code>self</code> is not in a Unicode encoding:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&quot;\xE0&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&#39;ISO-8859-1&#39;</span>)
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">unicode_normalized?</span> <span class="ruby-comment"># Raises Encoding::CompatibilityError.</span>
</pre>

<p>Related: <a href="String.html#method-i-unicode_normalize"><code>String#unicode_normalize</code></a>, <a href="String.html#method-i-unicode_normalize-21"><code>String#unicode_normalize!</code></a>.</p>

          <div class="method-source-code" id="unicode_normalized-3F-source">
            <pre>static VALUE
rb_str_unicode_normalized_p(int argc, VALUE *argv, VALUE str)
{
    return unicode_normalize_common(argc, argv, str, id_normalized_p);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-unpack" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              unpack(template, offset: 0) &rarr; array
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Extracts data from <code>self</code>, forming objects that become the elements of a new array; returns that array. See <a href="packed_data_rdoc.html">Packed Data</a>.</p>

          <div class="method-source-code" id="unpack-source">
            <pre><span class="ruby-comment"># File pack.rb, line 19</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unpack</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-value">offset:</span> <span class="ruby-value">0</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">pack_unpack</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-identifier">offset</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-unpack1" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              unpack1(template, offset: 0) &rarr; object
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Like <a href="String.html#method-i-unpack"><code>String#unpack</code></a>, but unpacks and returns only the first extracted object. See <a href="packed_data_rdoc.html">Packed Data</a>.</p>

          <div class="method-source-code" id="unpack1-source">
            <pre><span class="ruby-comment"># File pack.rb, line 28</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">unpack1</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-value">offset:</span> <span class="ruby-value">0</span>)
  <span class="ruby-constant">Primitive</span>.<span class="ruby-identifier">pack_unpack1</span>(<span class="ruby-identifier">fmt</span>, <span class="ruby-identifier">offset</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-upcase" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              upcase(*options) &rarr; string
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a string containing the upcased characters in <code>self</code>:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;Hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;Hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">upcase</span>           <span class="ruby-comment"># =&gt; &quot;HELLO WORLD!&quot;</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-upcase-21"><code>String#upcase!</code></a>, <a href="String.html#method-i-downcase"><code>String#downcase</code></a>, <a href="String.html#method-i-downcase-21"><code>String#downcase!</code></a>.</p>

          <div class="method-source-code" id="upcase-source">
            <pre>static VALUE
rb_str_upcase(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE;
    VALUE ret;

    flags = check_case_options(argc, argv, flags);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        ret = rb_str_new(RSTRING_PTR(str), RSTRING_LEN(str));
        str_enc_copy(ret, str);
        upcase_single(ret);
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY) {
        ret = rb_str_new(0, RSTRING_LEN(str));
        rb_str_ascii_casemap(str, ret, &amp;flags, enc);
    }
    else {
        ret = rb_str_casemap(str, &amp;flags, enc);
    }

    return ret;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-upcase-21" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              upcase!(*options) &rarr; self or nil
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Upcases the characters in <code>self</code>; returns <code>self</code> if any changes were made, <code>nil</code> otherwise:</p>

<pre class="ruby"><span class="ruby-identifier">s</span> = <span class="ruby-string">&#39;Hello World!&#39;</span> <span class="ruby-comment"># =&gt; &quot;Hello World!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">upcase!</span>          <span class="ruby-comment"># =&gt; &quot;HELLO WORLD!&quot;</span>
<span class="ruby-identifier">s</span>                  <span class="ruby-comment"># =&gt; &quot;HELLO WORLD!&quot;</span>
<span class="ruby-identifier">s</span>.<span class="ruby-identifier">upcase!</span>          <span class="ruby-comment"># =&gt; nil</span>
</pre>

<p>The casing may be affected by the given <code>options</code>; see <a href="case_mapping_rdoc.html">Case Mapping</a>.</p>

<p>Related: <a href="String.html#method-i-upcase"><code>String#upcase</code></a>, <a href="String.html#method-i-downcase"><code>String#downcase</code></a>, <a href="String.html#method-i-downcase-21"><code>String#downcase!</code></a>.</p>

          <div class="method-source-code" id="upcase-21-source">
            <pre>static VALUE
rb_str_upcase_bang(int argc, VALUE *argv, VALUE str)
{
    rb_encoding *enc;
    OnigCaseFoldType flags = ONIGENC_CASE_UPCASE;

    flags = check_case_options(argc, argv, flags);
    str_modify_keep_cr(str);
    enc = str_true_enc(str);
    if (case_option_single_p(flags, enc, str)) {
        if (upcase_single(str))
            flags |= ONIGENC_CASE_MODIFIED;
    }
    else if (flags&amp;ONIGENC_CASE_ASCII_ONLY)
        rb_str_ascii_casemap(str, str, &amp;flags, enc);
    else
        str_shared_replace(str, rb_str_casemap(str, &amp;flags, enc));

    if (ONIGENC_CASE_MODIFIED&amp;flags) return str;
    return Qnil;
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-upto" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              upto(other_string, exclusive = false) {|string| ... } &rarr; self
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          <div class="method-heading">
            <span class="method-callseq">
              upto(other_string, exclusive = false) &rarr; new_enumerator
            </span>
          </div>
        </div>

        <div class="method-description">
          <p>With a block given, calls the block with each String value returned by successive calls to <a href="String.html#method-i-succ"><code>String#succ</code></a>; the first value is <code>self</code>, the next is <code>self.succ</code>, and so on; the sequence terminates when value <code>other_string</code> is reached; returns <code>self</code>:</p>

<pre class="ruby"><span class="ruby-string">&#39;a8&#39;</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-string">&#39;b6&#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">s</span>, <span class="ruby-string">&#39; &#39;</span> } <span class="ruby-comment"># =&gt; &quot;a8&quot;</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">a8</span> <span class="ruby-identifier">a9</span> <span class="ruby-identifier">b0</span> <span class="ruby-identifier">b1</span> <span class="ruby-identifier">b2</span> <span class="ruby-identifier">b3</span> <span class="ruby-identifier">b4</span> <span class="ruby-identifier">b5</span> <span class="ruby-identifier">b6</span>
</pre>

<p>If argument <code>exclusive</code> is given as a truthy object, the last value is omitted:</p>

<pre class="ruby"><span class="ruby-string">&#39;a8&#39;</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-string">&#39;b6&#39;</span>, <span class="ruby-keyword">true</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">print</span> <span class="ruby-identifier">s</span>, <span class="ruby-string">&#39; &#39;</span> } <span class="ruby-comment"># =&gt; &quot;a8&quot;</span>
</pre>

<p>Output:</p>

<pre class="ruby"><span class="ruby-identifier">a8</span> <span class="ruby-identifier">a9</span> <span class="ruby-identifier">b0</span> <span class="ruby-identifier">b1</span> <span class="ruby-identifier">b2</span> <span class="ruby-identifier">b3</span> <span class="ruby-identifier">b4</span> <span class="ruby-identifier">b5</span>
</pre>

<p>If <code>other_string</code> would not be reached, does not call the block:</p>

<pre class="ruby"><span class="ruby-string">&#39;25&#39;</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-string">&#39;5&#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-identifier">s</span> }
<span class="ruby-string">&#39;aa&#39;</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-string">&#39;a&#39;</span>) {<span class="ruby-operator">|</span><span class="ruby-identifier">s</span><span class="ruby-operator">|</span> <span class="ruby-identifier">fail</span> <span class="ruby-identifier">s</span> }
</pre>

<p>With no block given, returns a new Enumerator:</p>

<pre class="ruby"><span class="ruby-string">&#39;a8&#39;</span>.<span class="ruby-identifier">upto</span>(<span class="ruby-string">&#39;b6&#39;</span>) <span class="ruby-comment"># =&gt; #&lt;Enumerator: &quot;a8&quot;:upto(&quot;b6&quot;)&gt;</span>
</pre>

          <div class="method-source-code" id="upto-source">
            <pre>static VALUE
rb_str_upto(int argc, VALUE *argv, VALUE beg)
{
    VALUE end, exclusive;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;end, &amp;exclusive);
    RETURN_ENUMERATOR(beg, argc, argv);
    return rb_str_upto_each(beg, end, RTEST(exclusive), str_upto_i, Qnil);
}</pre>
          </div>
        </div>


      </div>

      <div id="method-i-valid_encoding-3F" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-callseq">
              valid_encoding? &rarr; true or false
            </span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns <code>true</code> if <code>self</code> is encoded correctly, <code>false</code> otherwise:</p>

<pre class="ruby"><span class="ruby-string">&quot;\xc2\xa1&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>).<span class="ruby-identifier">valid_encoding?</span> <span class="ruby-comment"># =&gt; true</span>
<span class="ruby-string">&quot;\xc2&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>).<span class="ruby-identifier">valid_encoding?</span>     <span class="ruby-comment"># =&gt; false</span>
<span class="ruby-string">&quot;\x80&quot;</span>.<span class="ruby-identifier">force_encoding</span>(<span class="ruby-string">&quot;UTF-8&quot;</span>).<span class="ruby-identifier">valid_encoding?</span>     <span class="ruby-comment"># =&gt; false</span>
</pre>

          <div class="method-source-code" id="valid_encoding-3F-source">
            <pre>static VALUE
rb_str_valid_encoding_p(VALUE str)
{
    int cr = rb_enc_str_coderange(str);

    return RBOOL(cr != ENC_CODERANGE_BROKEN);
}</pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.5.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

